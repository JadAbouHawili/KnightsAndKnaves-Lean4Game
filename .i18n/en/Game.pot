msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-02\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: `True`
#. ยง1: `True`
#. ยง2: `trivial`
#: Game.Levels.Simp_World.L02_true_or
msgid "\n"
"Now we want to prove ยง0. But ยง1 is always true, so the proof is trivial.\n"
"\n"
"The ยง2 tactic will do the job.\n"
""
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#: Game.Levels.Logic.L03_Or
msgid "We have a proof that ยง0 is true, and we want to prove ยง1"
msgstr ""

#. ยง0: `A.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L07_difftype
msgid "\n"
"Let's start by proving ยง0\n"
""
msgstr ""

#. ยง0: `x`
#. ยง1: `2`
#. ยง2: `x=2`
#. ยง3: `rw`
#. ยง4: `rw`
#. ยง5: `A=B`
#. ยง6: `A`
#. ยง7: `B`
#. ยง8: `rw [h]`
#. ยง9: `h : x=3`
#. ยง10: `x`
#. ยง11: `3`
#: Game.Levels.EquationalReasoning.L03_rw
msgid "We will learn how to substitute a variable with its value, for example how to substitiute ยง0 by ยง1 if we know that ยง2.\n"
"\n"
"This can be done using the tactic ยง3 (short for 'rewrite').\n"
"\n"
"ยง4 takes a proof of ยง5 and replaces all the ยง6s in the goal with ยง7s.\n"
"\n"
"So ยง8 where ยง9 will replace all the ยง10s of the goal with ยง11."
msgstr ""

#. ยง0: `ยฌC`
#. ยง1: `nC : ยฌC`
#. ยง2: `A โ ยฌC`
#. ยง3: `A`
#. ยง4: `(A โ ยฌC) โ A`
#. ยง5: `A`
#. ยง6: `A โ ยฌC`
#. ยง7: `A`
#. ยง8: `A โ ยฌC`
#. ยง9: ```
#. iff_true_right (ha : a)
#. : (b โ a) โ b
#. ```
#. ยง10: `A โ ยฌC`
#. ยง11: `A`
#. ยง12: `b โ a`
#. ยง13: `A โ ยฌC`
#. ยง14: `stB`
#. ยง15: ```
#. B โ (A โ ยฌC)
#. ```
#. ยง16: ```
#. B โ A
#. ```
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "\n"
"\n"
"Since ยง0 is true by ยง1, then ยง2 and ยง3 have the same truth value, i.e. ยง4\n"
"\n"
"If ยง5 is true then ยง6 is true, and if ยง7 is false then ยง8 is false.\n"
"\n"
"Use\n"
"ยง9\n"
"to replace ยง10 with ยง11.\n"
"(In our case, ยง12 is ยง13)\n"
"\n"
"This reduction would transform ยง14 from\n"
"ยง15\n"
"to\n"
"ยง16\n"
""
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: `constructor`
#. ยง1: `โจโฉ`
#: Game.Levels.KnightsAndKnaves2.L06_
msgid "\n"
"Split using ยง0 or use ยง1 notation.\n"
""
msgstr ""

#. ยง0: `A.isKnight`
#: Game.Levels.DSL_Knights_Knaves.L07_difftype
msgid "\n"
"Change this to a goal about knights,\n"
"and assume ยง0\n"
""
msgstr ""

#. ยง0: `isKnight A`
#. ยง1: `ยฌisKnave A`
#. ยง2: `knight_to_knave`
#. ยง3: `knight_to_knave`
#. ยง4: `hypothesis`
#. ยง5: `knight_to_knave`
#. ยง6: `*`
#. ยง7: ```
#. simp [isKnight_notisKnaveIff]
#. ```
#. ยง8: ```
#. isKnight_notisKnaveIff
#. : A.isKnight โ ยฌA.isKnave
#. ```
#. ยง9: `A.isKnight`
#. ยง10: `ยฌA.isKnave`
#. ยง11: `A`
#: Game.Doc.tactic_doc
#: Game.Doc.tactic_doc
msgid "Rewrites all expression asserting being a knight into the equivalent expression of not being knave\n"
"\n"
"Changes all instances of ยง0 to ยง1\n"
"\n"
"# Change the Goal\n"
"ยง2\n"
"\n"
"# Change the Hypothesis\n"
"ยง3 at ยง4\n"
"\n"
"# Change the goal and all hypothesis\n"
"ยง5 at *\n"
"\n"
"The ยง6 is called the 'wildcard', and it matches anything.\n"
"\n"
"# Under the hood\n"
"The tactic is simply a macro abbreviating:\n"
"ยง7\n"
"where\n"
"ยง8\n"
"\n"
"ยง9 and ยง10 always have the same truth value regardless of what ยง11 is, so they can be interchanged"
msgstr ""

#. ยง0: `ยฌP`
#. ยง1: `P โ False`
#. ยง2: ```
#. hnP : ยฌP
#. ```
#. ยง3: `unfold Not at hnP`
#. ยง4: ```
#. hnP : P โ False
#. ```
#. ยง5: $
#. \\begin{array}{|c c|}
#. \\hline
#. P & ยฌP \\
#. \\hline
#. T & F \\
#. F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง6: $
#. \\begin{array}{|c|c|}
#. \\hline
#. P & P โ False \\
#. \\hline
#. T & F \\
#. F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง7: `ยฌP`
#. ยง8: `P โ False`
#. ยง9: `ยฌP`
#. ยง10: `ยฌP`
#. ยง11: `P`
#. ยง12: `False`
#. ยง13: `ยฌP`
#. ยง14: `intro`
#: Game.Doc.doc
msgid "## Implication defintion\n"
"ยง0 is equivalent to ยง1\n"
"\n"
"Given\n"
"ยง2\n"
"ยง3 will result in:\n"
"ยง4\n"
"\n"
"## Truth table\n"
"ยง5\n"
"\n"
"ยง6\n"
"\n"
"Notice that this definition is an implication and that the truth table with ยง7 and the truth table with ยง8 are identical.\n"
"\n"
"## ยง9 as the goal\n"
"What this means is that to prove ยง10, we assume ยง11 and derive a contradiction, i.e. constructing an object of type ยง12.\n"
"In other words, having ยง13 as a goal, you have to start the proof with ยง14 because you are proving an implication."
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `knave`
#: Game.Levels.DSL_Knights_Knaves.L07_difftype
msgid "\n"
"Now that ยง0 is a knave, we can conclude ยง1 was lying and ยง2 is in fact a ยง3.\n"
"\n"
"Then, close the goal.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `A`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `A`
#. ยง7: `B`
#. ยง8: `A`
#. ยง9: `C`
#. ยง10: `B`
#. ยง11: `B`
#. ยง12: `C`
#. ยง13: `B.isKnave`
#. ยง14: `have`
#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "Three of the inhabitants ยง0, ยง1, and ยง2 were standing together in a garden.\n"
"\n"
"A stranger passed by and asked ยง3, 'Are you a knight or a knave?' ยง4 answered, but rather indistinctly, so the stranger could not make out what he said.\n"
"\n"
"The stranger then asked ยง5, 'What did ยง6 say?' ยง7 replied, 'ยง8 said that he is a knave.'\n"
"\n"
"At this point the third man, ยง9, said, 'Don't believe ยง10; he is lying!'\n"
"\n"
"The question is, what are ยง11 and ยง12?\n"
"\n"
"Change the goal to ยง13 (using the ยง14 tactic)"
msgstr ""

#. ยง0: `ยซ{cont}ยป`
#. ยง1: `ยฌisKnave A`
#. ยง2: `ยซ{cont}ยป.left : ยฌisKnave A`
#. ยง3: `ยซ{AKnave}ยป : isKnave A`
#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid "\n"
"The left side of ยง0 is ยง1 (ยง2) which contradicts ยง3.\n"
""
msgstr ""

#. ยง0: `ยฌP`
#. ยง1: `ยฌQ`
#. ยง2: `P`
#. ยง3: `Q`
#: Game.Doc.doc
msgid "If we know that ยง0,ยง1 have the same truth value then ยง2,ยง3 have the same truth value."
msgstr ""

#. ยง0: `โ`
#. ยง1: $$
#. \\begin{array}{|c|c|c|}
#. \\hline
#. P & Q & P โ Q \\\\
#. \\hline
#. T & T & T \\\\
#. \\hline
#. T & F & F \\\\
#. \\hline
#. F & T & T \\\\
#. \\hline
#. F & F & T \\\\
#. \\hline
#. \\end{array}
#. $$
#. ยง2: `P`
#. ยง3: `False`
#. ยง4: `False`
#. ยง5: $$
#. \\begin{array}{|c|c|c|}
#. \\hline
#. Q & False โ Q \\\\
#. \\hline
#. T & T \\\\
#. \\hline
#. F & T \\\\
#. \\hline
#. \\end{array}
#. $$
#. ยง6: `False โ Q`
#. ยง7: `Q`
#. ยง8: `Q`
#. ยง9: `False`
#. ยง10: `False`
#: Game.Doc.doc
msgid "False.elim : False โ C says that from False, any desired proposition C holds.\n"
"\n"
"## Intuitively\n"
"\n"
"Let's check the ยง0 truth table:\n"
"ยง1\n"
"\n"
"Let's focus on part of the truth table where ยง2 is ยง3, because we want to see what ยง4 implies.\n"
"ยง5\n"
"\n"
"We have that the implication ยง6 is true regardless what ยง7 represents and regardless whether ยง8 is true or is false.\n"
"\n"
"So ยง9 implies any proposition. This principle is known as: 'From ยง10 anything follows'."
msgstr ""

#. ยง0: `B.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
msgid "\n"
"First prove ยง0\n"
""
msgstr ""

#. ยง0: ```
#. h : False
#. ```
#. ยง1: ```
#. hP : P
#. hnP : ยฌP
#. ```
#. ยง2: `contradiction`
#. ยง3: `False`
#: Game.Doc.tactic_doc
msgid "Contradiction is a tactic that detects if you have contradictory assumptions and if so, closes the goal.\n"
"\n"
"Having\n"
"ยง0\n"
"or\n"
"ยง1\n"
"(or other 'simple' contradictions)\n"
"ยง2 will close any goal.\n"
"\n"
"This is because from ยง3, anything follows."
msgstr ""

#. ยง0: `simp [not_or] at h`
#. ยง1: `rw [not_or] at h`
#: Game.Levels.Simp_World.L03_not_or
#: Game.Levels.Simp_World.L04_not_and_or
msgid "ยง0 instead of ยง1 also works."
msgstr ""

#. ยง0: `False`
#: Game.Levels.Logic.L09_False
msgid "From ยง0, anything follows."
msgstr ""

#. ยง0: `contradiction`
#. ยง1: ```
#. h : False
#. ```
#. ยง2: ```
#. hP : P
#. hnP : ยฌP
#. ```
#. ยง3: ```
#. hP : P
#. ```
#. ยง4: `ยฌP`
#: Game.Doc.tactic_doc
msgid "The ยง0 tactic works for the following proofs states:\n"
"ยง1\n"
"\n"
"ยง2\n"
"\n"
"and\n"
"ยง3\n"
"where Lean knows that ยง4 is true.\n"
"\n"
"Example:\n"
"-- disjoint\n"
"You need to show that having two sets being disjoint (i.e. sharing no common element) and having a common element is a contradiction."
msgstr ""

#. ยง0: `cases`
#. ยง1: `h : P or Q`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `R`
#. ยง5: `R`
#. ยง6: `cases h`
#: Game.Levels.Logic.L06_cases
msgid "In this level, we will do a 'proof by cases' using the ยง0 tactic.\n"
"\n"
"By ยง1, we have two cases:\n"
"ยง2 being true or ยง3 being true.\n"
"\n"
"If we consider each case individually and prove ยง4, then we can conclude that ยง5 is true.\n"
"\n"
"To do this, start with ยง6"
msgstr ""

#. ยง0: `iff_of_true`
#. ยง1: `A โ ยฌC`
#: Game.Levels.KnightsAndKnaves2.L06_
#: Game.Levels.KnightsAndKnaves2.L06_
msgid "\n"
"Use ยง0 to prove ยง1\n"
""
msgstr ""

#. ยง0: `โง`
#. ยง1: `x=2`
#. ยง2: `P`
#. ยง3: `y=6`
#. ยง4: `Q`
#. ยง5: `x=2 โง y=6`
#. ยง6: `P โง Q`
#. ยง7: `x=2 and y=6`
#. ยง8: `P and Q`
#. ยง9: `x=2 โง y=6`
#. ยง10: `P โง Q`
#. ยง11: `x=2`
#. ยง12: `P`
#. ยง13: `y=6`
#. ยง14: `Q`
#. ยง15: `x=2`
#. ยง16: `P`
#. ยง17: `y=6`
#. ยง18: `Q`
#. ยง19: `T`
#. ยง20: `F`
#. ยง21: $
#. \\begin{array}{|c|c|c|}
#. \\hline
#. x=2 & y=6 & x=2 โง y=6 \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & F \\
#. \\hline
#. F & F & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง22: `x=2 and y=6`
#. ยง23: `P and Q`
#. ยง24: `x=2`
#. ยง25: `P`
#. ยง26: `y=6`
#. ยง27: `Q`
#. ยง28: `P`
#. ยง29: `Q`
#. ยง30: `P`
#. ยง31: `Q`
#. ยง32: $
#. \\begin{array}{|c|c|c|}
#. \\hline
#. P & Q & P โง Q \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & F \\
#. \\hline
#. F & F & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง33: `P and Q`
#. ยง34: `P`
#. ยง35: `Q`
#. ยง36: `P and Q`
#. ยง37: `P`
#. ยง38: `Q`
#. ยง39: `and`
#. ยง40: `And.intro`
#. ยง41: ```
#. And.intro (left : P)
#.           (right : Q)
#. : P and Q
#. ```
#. ยง42: `And.intro`
#. ยง43: `P`
#. ยง44: `Q`
#. ยง45: `P and Q`
#. ยง46: ```
#. And.intro arg1 arg2
#. ```
#. ยง47: `arg1 : P`
#. ยง48: `arg2 : Q`
#. ยง49: `(And.intro arg1 arg2) : P and Q`
#. ยง50: `P and Q`
#. ยง51: `exact`
#: Game.Levels.Logic.L02_And
msgid "In this level, we introduce the ยง0 logical connective (read as 'and').\n"
"\n"
"Remember the following example:\n"
"Given the two propositions ยง1 (ยง2), ยง3 (ยง4), we can construct a new propositon ยง5 (ยง6) which is read as ยง7 (ยง8).\n"
"\n"
"What is the truth value of this new proposition ยง9 (ยง10)?\n"
"Well, it would depend on the truth value of the two component propositions ยง11 (ยง12), ยง13 (ยง14).\n"
"\n"
"What possibilities are there for each's truth value? ยง15 (ยง16) can either be true or false and similarly for ยง17 (ยง18). Here is a truth table that goes through all these possibilities:\n"
"ยง19 stands for true\n"
"ยง20 stands for false\n"
"ยง21\n"
"\n"
"\n"
"The proposition ยง22 (ยง23) is true when ยง24 (ยง25) is true AND ยง26 (ยง27) is true.\n"
"In other words, if ยง28 is true AND ยง29 is true regardless of what proposition ยง30 stands for, ยง31 stands for. The only thing that matters is their truth value.\n"
"Therefore, the more general truth table is the same:\n"
"ยง32\n"
"\n"
"Notice that ยง33 is true when both ยง34 is true and ยง35 is true, being false otherwise.\n"
"\n"
"From this, we conclude that we can prove ยง36 if we have a proof of ยง37 and a proof of ยง38.\n"
"\n"
"This is called the ยง39 introduction rule ยง40:\n"
"ยง41\n"
"\n"
"You can think of ยง42 as a function that takes two inputs: a proof of ยง43, a proof of ยง44 and returns a proof of ยง45.\n"
"\n"
"For example:\n"
"ยง46\n"
"where ยง47, ยง48, ยง49.\n"
"\n"
"Use it to construct an object of type ยง50, and use ยง51 to close the goal."
msgstr ""

#. ยง0: `B`
#. ยง1: `A`
#. ยง2: `C`
#: Game.Levels.DSL_Knights_Knaves.L09_same
msgid "\n"
"Therefore, from ยง0's statement, conclude that ยง1 and ยง2 are not the same, i.e. are different.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#. ยง2: ```
#. A : Prop
#. ```
#. ยง3: `A`
#. ยง4: `A`
#. ยง5: `A`
#. ยง6: `A`
#. ยง7: `A`
#. ยง8: `A`
#. ยง9: `ยฌA`
#. ยง10: `A`
#. ยง11: ```
#. A or ยฌA
#. ```
#. ยง12: `A`
#. ยง13: `P`
#. ยง14: `A`
#. ยง15: `P`
#. ยง16: ```
#. A โ P
#. ```
#. ยง17: `P`
#. ยง18: `A`
#. ยง19: ```
#. P โ A
#. ```
#. ยง20: ```
#. A โ P
#. ```
#. ยง21: `A`
#. ยง22: `P`
#. ยง23: ```
#. ยฌA โ ยฌP
#. ```
#. ยง24: `P`
#. ยง25: `A`
#. ยง26: ```
#. ยฌP โ ยฌA
#. ```
#. ยง27: ```
#. ยฌA โ ยฌP
#. ```
#. ยง28: ```
#. A โง ยฌA
#. ```
#: Game.Doc.doc
msgid "Say we have an islander ยง0 who could be a knight or a knave.\n"
"\n"
"ยง1 is represented as\n"
"ยง2\n"
"where having the proposition ยง3 being true means the islander ยง4 is a knight and having the proposition ยง5 being false means the islander ยง6 is a knave.\n"
"\n"
"Now, we intrepret having a proof of ยง7 as ยง8 being a knight, and having a proof of ยง9 as ยง10 being a knave.\n"
"\n"
"From this, every islander being a knight or a knave is represented as follows:\n"
"ยง11\n"
"\n"
"Knights always tell the truth, so if ยง12 makes some statement ยง13 we have that ยง14 being a knight implies that the statement ยง15 is true\n"
"ยง16\n"
"Moreover, the statement ยง17 being true means that ยง18 is telling the truth, i.e. is a knight\n"
"ยง19\n"
"which can be combined as\n"
"ยง20\n"
"\n"
"Similarly for ยง21 being a knave which implies that the statement ยง22 is false\n"
"ยง23\n"
"Moreover, the statement ยง24 being false means that ยง25 is lying, i.e. is a knave\n"
"ยง26\n"
"which are combined as\n"
"ยง27\n"
"\n"
"No islander can be a knight and a knave at the same time because\n"
"ยง28\n"
"is false.\n"
"\n"
"This representation captures the rules of the knights and knaves puzzle which are:\n"
"- Every islander is either a knight or a knave\n"
"- No islander is both a knight and a knave at the same time\n"
"- Knights always tell the truth, knaves always lie."
msgstr ""

#. ยง0: `not_iff'`
#: Game.Levels.DSL_Knights_Knaves.L09_same
msgid "\n"
"Use ยง0\n"
""
msgstr ""

#. ยง0: ```
#. cases isKnight_or_isKnave A
#. ```
#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "\n"
"Try\n"
"ยง0\n"
""
msgstr ""

#: Game
msgid "Knights And Knaves Game"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `unfold oneisknight at ยซ{hF}ยป`
#. ยง3: `simp`
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
msgid "\n"
"We now know that there is only one knight but we also know that ยง0 is a knight and ยง1 is a knight. This is the contradiction needed to close the goal.\n"
"\n"
"Start by ยง2 and using ยง3\n"
""
msgstr ""

#. ยง0: `or`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `h : P or Q`
#. ยง4: `Q`
#. ยง5: `hnQ : ยฌQ`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `Q`
#. ยง9: `P`
#. ยง10: `ยฌQ`
#. ยง11: `Q = False`
#. ยง12: `P or Q`
#. ยง13: `P or False`
#. ยง14: ```
#. eq_false (h : ยฌp) : p = False
#. ```
#: Game.Levels.Simp_World.L01_or_false
msgid "The simplification here concerns ยง0.\n"
"\n"
"We know that either ยง1 is true or ยง2 is true by ยง3.\n"
"\n"
"We also know that ยง4 is false by ยง5.\n"
"\n"
"Intution would now say that, given two cases ยง6 or ยง7 and knowing that its not ยง8 then it must be ยง9. Let's now do this simplification.\n"
"\n"
"We have ยง10 which means ยง11\n"
"\n"
"Rewrite the expression ยง12 into ยง13 using the theorem\n"
"ยง14"
msgstr ""

#. ยง0: `ยซ{notoneknight}ยป`
#. ยง1: `A,B`
#. ยง2: `C`
#. ยง3: `ยซ{notoneknight}ยป`
#. ยง4: `simp`
#. ยง5: `C`
#. ยง6: `C`
#. ยง7: `ยซ{notallknave}ยป : ยฌallKnaves`
#. ยง8: `unfold allKnaves at ยซ{notallknave}ยป`
#. ยง9: `A.isKnave and B.isKnave and C.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"ยง0 means that there are no knights or there are two or more knights.\n"
"\n"
"Since we know that ยง1 are knaves then it is the former, i.e. there are no knights. This means that ยง2 is a knave.\n"
"\n"
"To obtain this result:\n"
"- First start by unfolding ยง3.\n"
"- Use ยง4 given what you know to simplify the obtained expression after unfolding.\n"
"- The final answer after simplification would be that ยง5 is a knave.\n"
"\n"
"After obtaining that ยง6 is a knave, we now know that everyone is a knave but we also know that ยง7 and so a contradiction.\n"
"\n"
"To obtain this contradiction, ยง8 then simplify the unfolded expression or construct a proof of ยง9.\n"
""
msgstr ""

#. ยง0: `isKnave A โจ isKnave B`
#. ยง1: `โจ`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "\n"
"Let's first prove ยง0. Type ยง1 by \\\\or.\n"
""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_orIff
msgid "\n"
"Use constructor\n"
""
msgstr ""

#: Game.Levels.Logic.L04_Implication
msgid "Implication, โ"
msgstr ""

#. ยง0: `โ`
#. ยง1: `=`
#. ยง2: `โ`
#: Game.Levels.KnightsAndKnaves2.L03_iff_iff
msgid "\n"
"Remember the interpretation where you can treat ยง0 like ยง1 (refer to ยง2 docs for an example).\n"
""
msgstr ""

#. ยง0: `โจ`
#: Game.Levels.Logic.L03_Or
msgid "Or, ยง0"
msgstr ""

#. ยง0: `hA : A`
#. ยง1: `BC : B โง C`
#. ยง2: `stA`
#. ยง3: `A`
#. ยง4: `CnA : C โง ยฌA`
#. ยง5: `stB`
#. ยง6: `BC.left : B`
#. ยง7: `False`
#. ยง8: `hA : A`
#. ยง9: `CnA.right : ยฌA`
#. ยง10: `have`
#: Game.Levels.KnightsAndKnaves2.L02_Introduction
msgid "\n"
"Assuming ยง0:\n"
"- Prove ยง1 from ยง2 using ยง3\n"
"- Prove ยง4 using ยง5, ยง6\n"
"- Prove ยง7 using ยง8,ยง9.\n"
"\n"
"Each can be done in one step, so the appropriate ยง10 syntax should be used.\n"
""
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "Proving an implication, Implication as the goal"
msgstr ""

#. ยง0: `not_and_or`
#. ยง1: `ยซ{st}ยป`
#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "\n"
"Use ยง0 at ยง1\n"
""
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L09_same
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "\n"
"Take cases for ยง0\n"
""
msgstr ""

#. ยง0: `ยฌisKnave A`
#. ยง1: `knight_to_knave`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "\n"
"Change the goal to ยง0 using the ยง1 tactic\n"
""
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "In the next levels, we will discuss how to construct new propositions from existing ones."
msgstr ""

#. ยง0: `rfl`
#. ยง1: `a`
#. ยง2: `a = a`
#. ยง3: `rfl`
#. ยง4: `rfl`
#. ยง5: `A=B`
#. ยง6: `A`
#. ยง7: `B`
#. ยง8: `rfl`
#. ยง9: `rfl`
#. ยง10: `rfl`
#. ยง11: `exact rfl`
#. ยง12: `rfl`
#. ยง13: `a = a`
#. ยง14: `a`
#. ยง15: ```
#. x - 7 = x - 7
#. ```
#. ยง16: `rfl`
#: Game.Doc.tactic_doc
msgid "ยง0 is short for reflexivity. In the context of numbers, it is the property that for any number ยง1, ยง2.\n"
"\n"
"ยง3 also applies more generally, ยง4 will close any goal of the form ยง5 where ยง6,ยง7 are identical. If needed, ยง8 will unfold both sides into their definitions and then check if they are equal. In other words, ยง9 can prove the equality of two things that are 'equal by definition'.\n"
"\n"
"In fact, ยง10 is not a tactic but syntactic sugar for ยง11. ยง12 is of type ยง13 for any ยง14.\n"
"\n"
"## Examples\n"
"ยง15\n"
"ยง16 will close this goal."
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "\n"
"exact And.intro hP hQ\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#. ยง2: ```
#. A.isKnight
#. ```
#. ยง3: `A`
#. ยง4: ```
#. A.isKnave
#. ```
#. ยง5: `A`
#. ยง6: ```
#. isKnight_or_isKnave (A : Islander)
#. : A.isKnight or A.isKnave
#. ```
#. ยง7: ```
#. knight_said
#. : (A said P) โ A.isKnight โ P
#. said_knight
#. : (A said P) โ  P โ A.isKnight
#. ```
#. ยง8: ```
#. knave_said
#. : (A said P) โ  A.isKnave โ ยฌP
#. said_knave
#. : (A said P) โ  ยฌP โ A.isKnave
#. ```
#. ยง9: `A`
#. ยง10: ```
#. not_isKnight_and_isKnave (A : Islander)
#. : ยฌ (A.isKnight โง A.isKnave)
#. ```
#: Game.Doc.doc
msgid "The setting is an island.\n"
"Every islander will make a statement. There are two types of islanders, 'knights' that always tell the truth, and 'knaves' that always lie.\n"
"\n"
"We give english statements and their corresponding translation to lean.\n"
"\n"
"Given an islander ยง0\n"
"\n"
"ยง1 is a knight\n"
"ยง2\n"
"\n"
"ยง3 is a knave\n"
"ยง4\n"
"\n"
"ยง5 is either a knight or a knave\n"
"ยง6\n"
"\n"
"Knights always tell the truth.\n"
"ยง7\n"
"\n"
"Knaves always lie.\n"
"ยง8\n"
"\n"
"Since knights always tell the truth and knaves always lie, no islander can be both a knight and a knave. ยง9 is not a knight and a knave at the same time. This is represented as:\n"
"ยง10\n"
"\n"
"The objective is to conclude who is a knight and who is a knave, based on the statements of several inhabitants. This will be done using logical reasoning."
msgstr ""

#. ยง0: `Goal`
#. ยง1: `Goal`
#. ยง2: `Lean`
#. ยง3: `mathlib`
#. ยง4: `Goal`
#. ยง5: `Goal`
#. ยง6: `Lean`
#. ยง7: `Objects`
#. ยง8: `Assumptions`
#. ยง9: `Goal`
#. ยง10: `Lean`
#. ยง11: `Lean`
#: Game
msgid "This is a gamification of mathematical proofs. Every level has a ยง0, which is what you are trying to prove. Closing the ยง1 means you have proven the theorem and there is nothing else to do.\n"
"\n"
"You will use the ยง2 theorem prover, and its mathematical library ยง3.\n"
"\n"
"# Right Side Pane(Docs Pane)\n"
"Let's explain what's going on in the right side pane.\n"
"\n"
"This is where you can find the tactics, definitions, and theorems at your disposal which were introduced in previous levels.\n"
"\n"
"Clicking on one will display an overview and some examples. This will be available to you at all times when working on the levels. Refer back to it whenever you need to.\n"
"\n"
"Any new tactic, theorem, or definition introduced in a level will be highlighted in a yellow color.\n"
"\n"
"\n"
"We now discuss each section in the right side pane.\n"
"## Tactics\n"
"In this puzzle game, you will use tactics to manipulate the ยง4 and close it, essentially proving the ยง5. Tactics will be incrementally introduced, and tactics that haven't been introduced yet will have a lock icon which means you can't use them yet.\n"
"\n"
"## Definitions\n"
"The point of this game is not just to showcase ยง6, but also to learn some mathematics. Relevant definitions will be displayed here.\n"
"\n"
"## Theorems\n"
"Here is listed theorems to use throughout the levels. Some you would have proven in previous levels and others are presented for you to use but without having proven them. An intuitive explanation of why the theorem makes sense will be presented as well when it is introduced.\n"
"\n"
"# Official Documentation\n"
"The Docs in the right side pane are custom written to provide only what you need to progress through the game.\n"
"\n"
"You can of course go deeper by searching through the [official docs](https://leanprover-community.github.io/mathlib4_docs/)\n"
"\n"
"## Editor Mode\n"
"\n"
"You can view them inside a level by entering editor mode and hovering over the term.\n"
"\n"
"You can enter editor mode by clicking the icon next to the hamburger menu that is in the top right hand corner when you are in a level\n"
"\n"
"# Level Structure\n"
"\n"
"Within every level, you have the ยง7 (if any), ยง8 (if any), and ยง9 for the current level. This is called the initial proof state.\n"
"\n"
"There will also be a text input to execute tactics accordingly.\n"
"\n"
"ยง10 tracks the proof state as you execute tactics and makes sure you made no mistakes.\n"
"You will execute tactics one by one until ยง11 tells you that you have closed the goal.\n"
"\n"
"# More info\n"
"You can click the hamburger menu in the top right then 'Game Info' for more information:\n"
"- Sources Of Puzzles\n"
"etc..."
msgstr ""

#. ยง0: `B`
#. ยง1: `C`
#. ยง2: `simp`
#. ยง3: `ยซ{one}ยป`
#. ยง4: `ยซ{AKnave}ยป`
#. ยง5: `ยซ{BKnight}ยป`
#. ยง6: `C`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"We now have that not everyone is a knave and that there is only one knight. Since we know that knight is ยง0, then ยง1 can't be a knight and must be a knave.\n"
"\n"
"Use ยง2,ยง3,ยง4,ยง5 to prove that ยง6 is a knave.\n"
"\n"
"After which, you can close the goal.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: ```
#. knight_or_knave A
#. ```
#. ยง2: `h : A.isKnight`
#. ยง3: `h:A.isKnave`
#. ยง4: ```
#. knight_or_knave A with AKnight AKnave
#. ```
#. ยง5: `AKnight : A.isKnight`
#. ยง6: `AKnave : A.isKnave`
#. ยง7: `knight_or_knave A`
#. ยง8: ```
#. cases isKnight_orisKnave A
#. ```
#. ยง9: `isKnight_or_isKnave A : A.isKnight or A.isKnave`
#: Game.Doc.tactic_doc
msgid "For an islander ยง0,\n"
"ยง1\n"
"takes two cases, the first being ยง2 and the second being ยง3\n"
"\n"
"You can choose the name of the hypothesis of each case by\n"
"ยง4\n"
"which gives the first case ยง5 and the second case ยง6.\n"
"\n"
"# Under the hood\n"
"ยง7 is just a macro for\n"
"ยง8\n"
"where ยง9"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `ยฌA.isKnight`
#. ยง5: `ยฌ`
#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "Suppose ยง0 says, 'I am a knave, but ยง1 isn't.'\n"
"What are ยง2 and ยง3?\n"
"\n"
"Change the goal to ยง4. You write ยง5 by \\\\not."
msgstr ""

#. ยง0: `knave_to_knight`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"Change the goal from ยง0\n"
""
msgstr ""

#. ยง0: `2 = 2`
#. ยง1: `rfl`
#. ยง2: `rfl`
#. ยง3: `a`
#. ยง4: `a = a`
#: Game.Levels.EquationalReasoning.L01_rfl
msgid "In this exercise, we will prove ยง0\n"
"\n"
"ยง1 will do the job.\n"
"\n"
"ยง2 is short for reflexivity, which is the property that for any number ยง3, ยง4"
msgstr ""

#: Game.Doc.doc
msgid "A is a knight, so whatever A said is true"
msgstr ""

#. ยง0: `CorB`
#: Game.Levels.KnightsAndKnaves2.L05_iff
msgid "\n"
"Now consider cases for ยง0 and for every case prove the goal.\n"
"\n"
"(proof by cases)\n"
""
msgstr ""

#. ยง0: `P,Q`
#. ยง1: `P,Q`
#. ยง2: `P โ Q`
#: Game.Doc.doc
msgid "If two propositions are true, then they have the same truth value.\n"
"\n"
"If we know ยง0  then we can conclude that ยง1 have the same truth value, i.e. ยง2"
msgstr ""

#: Game.Levels.Simp_World
msgid "Simplification"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "I am a knave, I am a liar"
msgstr ""

#. ยง0: `A.isKnight`
#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid "\n"
"Change the goal to ยง0\n"
""
msgstr ""

#. ยง0: $Name~~~$
#. ยง1: $Ascii~~~$
#. ยง2: $Unicode~~~$
#. ยง3: $Unicode Cmd$
#. ยง4: `True`
#. ยง5: `False`
#. ยง6: `Not`
#. ยง7: `\\not`
#. ยง8: `\\neg`
#. ยง9: `/` | โง | `
#. ยง10: `  |
#. | Or | `
#. ยง11: ` | โจ |  `
#. ยง12: `  |
#. | Implies | `
#. ยง13: ` | โ |  `
#. ยง14: ` |
#. | Iff | `
#. ยง15: ` | โ | `
#. ยง16: ` |
#. 
#. ### **Other Unicode**
#. | $Name$ | $Unicode~~~$ | $Unicode Cmd$ |
#. | --- | :---: | --- |
#. | Angle brackets | โจโฉ | `
#. ยง17: ` |
#. | Left Arrow | โ | `
#. ยง18: ` `
#. ยง19: ` `
#. ยง20: ` `
#: Game.Doc.doc
msgid "### **Logic Constants & Operators**\n"
"| ยง0 | ยง1 | ยง2 | ยง3 |\n"
"| --- | :---: | :---: | --- |\n"
"| True | ยง4 |  |  |\n"
"| False | ยง5 |  |  |\n"
"| Not | ยง6 | ยฌ |  ยง7 ยง8  |\n"
"| And | ยง9\\\\andยง10\\\\/ยง11\\\\orยง12->ยง13\\\\impยง14<->ยง15\\\\iffยง16\\\\<>ยง17\\\\lยง18\\\\leftarrowยง19\\\\getsยง20\\\\<-` |"
msgstr ""

#. ยง0: `B`
#. ยง1: `h : B`
#. ยง2: `AiffC : A โ C`
#. ยง3: `stB`
#. ยง4: `h`
#: Game.Levels.KnightsAndKnaves2.L05_iff
msgid "\n"
"We are now in the case where ยง0 is true, ยง1.\n"
"\n"
"Prove ยง2 using ยง3, ยง4.\n"
""
msgstr ""

#. ยง0: `ยฌ(P โ Q)`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `ยฌ(P โ Q)`
#. ยง6: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{ยฌ(P โ Q)} \\\\
#. \\hline
#. T & F & T \\\\
#. \\hline
#. F & T & T \\\\
#. \\hline
#. \\end{array}
#. $
#. ยง7: `ยฌP`
#. ยง8: `Q`
#. ยง9: `ยฌP โ Q`
#: Game.Doc.doc
msgid "ยง0 means that ยง1 ,ยง2 don't have the same truth value, i.e. one of them is true and the other is false.\n"
"\n"
"Here are the values for ยง3,ยง4 where ยง5 is satisfied:\n"
"ยง6\n"
"\n"
"We can conclude that ยง7,ยง8 have the same truth value (ยง9)."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `P โง Q`
#. ยง2: `P`
#. ยง3: `Q`
#: Game.Doc.tactic_doc
msgid "The ยง0 tactic will split a goal of the form ยง1 into two subgoals ยง2,ยง3 where you can deal with each one separately."
msgstr ""

#: Game.Doc.doc
msgid "A said something true, so A is a knight."
msgstr ""

#. ยง0: ```
#. Objects
#. P : Prop
#. 
#. Assumptions
#. hP : P
#. 
#. Goal:
#. P
#. ```
#. ยง1: `hP : P`
#. ยง2: `P : Prop`
#. ยง3: `hP`
#. ยง4: `P`
#. ยง5: `P`
#. ยง6: `exact hP`
#. ยง7: `hP`
#. ยง8: `hP`
#. ยง9: `exact h`
#: Game.Doc.tactic_doc
msgid "## Overview\n"
"For the following proof state:\n"
"ยง0\n"
"Remember that ยง1 where ยง2 means ยง3 is a proof of ยง4.\n"
"\n"
"Since the goal is to prove ยง5, the only thing we have to do is to let Lean know that we do have such a proof. This is done by ยง6.\n"
"\n"
"In other words, ยง7 is EXACTLY whats needed to prove the goal, the type of ยง8 EXACTLY matches the goal, so ยง9 will do the job."
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "Equational Reasoning"
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
msgid "\n"
"Now this is the second case where ยง0 is a knave.\n"
"\n"
"Conclude that ยง1's statement is false\n"
""
msgstr ""

#. ยง0: `have`
#. ยง1: `R`
#. ยง2: `Q`
#. ยง3: `have hQ : Q`
#. ยง4: `Q`
#. ยง5: `hQ`
#: Game.Levels.Logic.L10_have
msgid "In this level, we introduce the ยง0 tactic.\n"
"You have to prove ยง1 but to do that, you need ยง2 first.\n"
"\n"
"Use ยง3 to change the goal to proving ยง4. And when the proof is done, it would be named ยง5 and added to the assumptions in the proof state."
msgstr ""

#. ยง0: `hPQ`
#. ยง1: `hP`
#. ยง2: `Q`
#: Game.Levels.Logic.L10_have
msgid "\n"
"ยง0 takes ยง1 and gives you a proof of ยง2\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `unfold allKnaves`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"Now we have that everybody is a knave, but we know ยง0 is a knight. Therefore, we have a contradiction.\n"
"\n"
"ยง1 and obtain a contradiction.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `B`
#: Game.Levels.DSL_Knights_Knaves.L07_difftype
msgid "You stumble into ยง0,ยง1.\n"
"\n"
"ยง2 says 'ยง3 is a knight'\n"
"\n"
"ยง4 says 'We are different types'"
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.EquationalReasoning.L01_rfl
msgid "ยง0, A Number Equals Itself"
msgstr ""

#. ยง0: `B`
#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "\n"
"Assume that ยง0 is a knight.\n"
""
msgstr ""

#. ยง0: ```
#. P โจ Q
#. ```
#. ยง1: `P Q : Prop`
#. ยง2: `left`
#. ยง3: `P`
#: Game.Doc.tactic_doc
#: Game.Doc.tactic_doc
msgid "Having the goal of the form:\n"
"ยง0\n"
"for ยง1, ยง2 transforms the goal to ยง3."
msgstr ""

#. ยง0: `knight_said`
#. ยง1: `A`
#. ยง2: `A`
#. ยง3: `A`
#. ยง4: `have`
#. ยง5: `knight_said`
#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "\n"
"ยง0\n"
"\n"
"ยง1 is a knight, so whatever ยง2 said is true.\n"
"\n"
"Prove ยง3's statement using ยง4,ยง5\n"
""
msgstr ""

#. ยง0: `simp at hP`
#. ยง1: `hP : ยฌยฌP`
#. ยง2: `hP : P`
#. ยง3: `simp [not_not] at hP`
#. ยง4: `not_not`
#. ยง5: `@simp`
#: Game.Levels.Simp_World.L05_not_not
msgid "ยง0 simplifies ยง1 into ยง2\n"
"\n"
"You don't have to do ยง3 because ยง4 is marked as a ยง5 lemma."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A`
#. ยง3: `C`
#. ยง4: `C`
#: Game.Levels.DSL_Knights_Knaves.L09_same
msgid "\n"
"Now that ยง0 is a knave.\n"
"We can conclude ยง1 is a knight.\n"
"\n"
"which means that ยง2 and ยง3 have the same type, obtaining that ยง4 is a knave and closing the goal.\n"
""
msgstr ""

#. ยง0: `cases`
#: Game.Levels.Logic.L06_cases
msgid "Proof by ยง0"
msgstr ""

#. ยง0: `hC : C`
#. ยง1: `hB : B`
#. ยง2: `stB`
#. ยง3: `C โง ยฌA`
#. ยง4: `hA : A`
#. ยง5: `stA`
#. ยง6: `B โง C`
#. ยง7: `False`
#. ยง8: `hA: A`
#. ยง9: `hnA : ยฌA`
#. ยง10: `hB : B`
#. ยง11: `C โง ยฌA`
#. ยง12: `stB.mpr`
#. ยง13: `\\<\\>`
#. ยง14: `And.intro`
#: Game.Levels.KnightsAndKnaves2.L02_Introduction
msgid "\n"
"Assuming ยง0:\n"
"- Prove ยง1 using ยง2, ยง3\n"
"- Prove ยง4 using ยง5, ยง6\n"
"- Prove ยง7 from ยง8,ยง9\n"
"\n"
"For proving ยง10, you would need to pass a proof of ยง11 to ยง12. The ยง13 notation is appropriate here (although you could just use ยง14).\n"
""
msgstr ""

#. ยง0: `Robert`
#. ยง1: `Ira`
#. ยง2: `Robert`
#. ยง3: `Ira`
#. ยง4: `Ira`
#. ยง5: `Robert`
#. ยง6: `Robert`
#. ยง7: `Ira`
#. ยง8: `Ira`
#. ยง9: `Ira.isKnight`
#: Game.Levels.DSL_Knights_Knaves.L08_sametype
msgid "You have met a group of 2 islanders. Their names are ยง0 and ยง1.\n"
"\n"
"ยง2 says: ยง3 is my type.\n"
"\n"
"ยง4 says: ยง5 is truthful.\n"
"\n"
"A knight or a knave will say they are the same type as a knight. So when ยง6 says they are the same type as ยง7, we know that ยง8 is a knight.\n"
"\n"
"Let's start by proving ยง9"
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid "\n"
"Conclude ยง0's statement.\n"
""
msgstr ""

#: Game.Doc.doc
msgid "You can't be a knight and a knave at the same time.\n"
"\n"
"You can't lie and tell the truth at the same time."
msgstr ""

#. ยง0: `B`
#. ยง1: `stB`
#. ยง2: `CiffnA.symm : C โ ยฌA`
#: Game.Levels.KnightsAndKnaves2.L06_
#: Game.Levels.KnightsAndKnaves2.L06_
msgid "\n"
"Prove ยง0 using ยง1, ยง2 (symm for 'symmetry').\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `B`
#. ยง4: `C`
#. ยง5: `A`
#: Game.Levels.KnightsAndKnaves2.L07_orIff
msgid "ยง0: ยง1 is a knight or ยง2 is a knight.\n"
"ยง3: ยง4 is a knave, if and only if ยง5 is a knave"
msgstr ""

#. ยง0: `B.isKnight`
#. ยง1: `A`
#: Game.Levels.DSL_Knights_Knaves.L07_difftype
msgid "\n"
"So, ยง0 by ยง1's statement\n"
""
msgstr ""

#. ยง0: `โง`
#. ยง1: $
#. \\begin{array}{|c c|c|}
#. \\hline
#. P & Q & \\text{P and Q} \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง2: `โง`
#. ยง3: `T`
#. ยง4: `F`
#. ยง5: $
#. \\begin{array}{|c c|c|}
#. \\hline
#. P & Q & \\text{P and Q} \\
#. \\hline
#. T & T & T \\
#. T & F & F \\
#. F & T & F \\
#. F & F & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง6: `P and Q`
#. ยง7: `P`
#. ยง8: `Q`
#: Game.Doc.doc
msgid "ยง0 read as 'and'\n"
"Truth table:\n"
"\n"
"ยง1\n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective, i.e. the truth value of the compound statement depending on the truth value of the propositions it connects.\n"
"The following truth table illustrates this for the previously discussed ยง2 connective.\n"
"ยง3 stands for true\n"
"ยง4 stands for false\n"
"\n"
"ยง5\n"
"\n"
"Notice that ยง6 is true when both ยง7 is true and ยง8 is true, being false otherwise."
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Simp_World.L09_not_iff_not
msgid "This was the last simplification theorem.\n"
"\n"
"Some of these you will use in the next two worlds solving knights and knaves logic puzzles (or use the ยง0 tactic if you prefer)."
msgstr ""

#. ยง0: `ยฌC`
#. ยง1: `ยฌC โจ A`
#. ยง2: `ยฌB`
#. ยง3: `stBn`
#. ยง4: ```
#. _ and _ and _
#. ```
#. ยง5: ```
#. ยฌA and (ยฌB and ยฌC)
#. ```
#. ยง6: ```
#. And.intro (_) (And.intro _ _)
#. ```
#. ยง7: `_`
#. ยง8: ```
#. โจ_,_,_โฉ
#. ```
#. ยง9: `_`
#. ยง10: `have`
#. ยง11: `ยฌB and ยฌC`
#: Game.Levels.KnightsAndKnaves2.L02_Introduction
msgid "\n"
"Using ยง0, we get ยง1 which gives ยง2 using ยง3.\n"
"\n"
"After which, you need to close the goal of the form\n"
"ยง4\n"
"\n"
"The goal is implicitly\n"
"ยง5\n"
"\n"
"You can use\n"
"ยง6\n"
"replacing ยง7 with the appropriate terms.\n"
"\n"
"Moreover,\n"
"you could also use the โจโฉ notation,\n"
"ยง8\n"
"replacing the ยง9 with the appropriate terms.\n"
"\n"
"You could even use ยง10 to first prove ยง11 and add it to the hypothesis,then prove the goal.\n"
""
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `(P โ Q) โง (Q โ P)`
#. ยง2: $
#. \\begin{array}{|c c|c c|c|}
#. \\hline
#. P & Q & P โ Q & Q โ P & P โ Q \\
#. \\hline
#. T & T & T & T & T \\
#. \\hline
#. T & F & F & T & F \\
#. \\hline
#. F & T & T & F & F \\
#. \\hline
#. F & F & T & T & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง3: `P โ Q`
#. ยง4: `P,Q`
#. ยง5: `P,Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `P`
#. ยง9: `Q`
#. ยง10: `P`
#. ยง11: `Q`
#. ยง12: ```
#. h : P โ Q
#. h.mp : P โ Q
#. h.mpr : Q โ P
#. ```
#. ยง13: `h.mp`
#. ยง14: `h.mpr`
#. ยง15: `P โ Q`
#. ยง16: `P = Q`
#. ยง17: `P`
#. ยง18: `Q`
#. ยง19: `P โ Q`
#. ยง20: `P = Q`
#. ยง21: `rw`
#. ยง22: `=`
#. ยง23: ```
#. h : P โ Q
#. hP : P
#. ```
#. ยง24: `rw [h] at hP`
#. ยง25: ```
#. h : P โ Q
#. hP : Q
#. ```
#: Game.Doc.doc
msgid "## Truth Table\n"
"ยง0  is defined as ยง1.\n"
"\n"
"Its truth table looks like the folowing:\n"
"ยง2\n"
"\n"
"So, ยง3 is true when ยง4 are true or ยง5 are false, i.e. when ยง6 and ยง7 have the same truth value. Therefore, ยง8 and ยง9 are equivalent from a truth value perspective regardless what the statement of ยง10 and of ยง11 is.\n"
"\n"
"## Extracting Each Implication\n"
"ยง12\n"
"ยง13 is the forward direction and ยง14 is the backward direction.\n"
"\n"
"## ยง15 is ยง16\n"
"Since ยง17, ยง18 have the same truth value, they can be used interchangeably.\n"
"You can think of ยง19 as ยง20 and use ยง21 in the same way you would if there was an actual ยง22 in the expression.\n"
"\n"
"For example:\n"
"ยง23\n"
"Doing ยง24 results in:\n"
"ยง25"
msgstr ""

#. ยง0: `A`
#. ยง1: ```
#. Asaid : A said A.isKnave
#. ```
#. ยง2: `False`
#. ยง3: `A`
#. ยง4: `A`
#. ยง5: ```
#. isKnight_or_isKnave
#. (A : Islander)
#. : A.isKnight or A.isKnave
#. ```
#. ยง6: `A`
#. ยง7: `A`
#. ยง8: `A`
#. ยง9: `A`
#. ยง10: `False`
#. ยง11: `A`
#. ยง12: `A`
#. ยง13: `A`
#. ยง14: `A`
#. ยง15: `False`
#. ยง16: `cases`
#. ยง17: `isKnight_or_isKnave`
#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "In this level, we present the 'I am a knave' puzzle.\n"
"\n"
"The given islander ยง0 says 'I am a knave'\n"
"ยง1\n"
"\n"
"The goal is to prove ยง2. Given the rules of the game, and that ยง3 says 'I am a knave' we have a contradiction.\n"
"\n"
"By the rules of the game, we know that ยง4 is either a knight or a knave.\n"
"ยง5\n"
"\n"
"If ยง6 were a knight, then ยง7's statement is true then ยง8 is a knave but that's impossible. So, if ยง9 were a knight then we can prove ยง10.\n"
"\n"
"If ยง11 were a knave, then ยง12's statement would be false, i.e. ยง13 is not a knave but thats impossible as well. So, if ยง14 were a knave then we can prove ยง15.\n"
"\n"
"We consider every case using the ยง16 tactic, and ยง17."
msgstr ""

#. ยง0: `ยฌP`
#. ยง1: `P`
#. ยง2: `False`
#. ยง3: `P`
#. ยง4: `False`
#: Game.Levels.Logic.L08_Not
#: Game.Levels.Logic.L08_Not
msgid "Remember that an implication acts like a function, that takes a proof of whats on the left hand returning a proof of whats on the right hand side.\n"
"\n"
"For this level, ยง0 being true tells us that a proof of ยง1 gives us a proof of ยง2. We have a proof of ยง3. Therefore we can obtain a proof of ยง4 which is the goal."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: ```
#. iff_of_true (ha : a) (hb : b)
#.   : a โ b
#. ```
#: Game.Levels.Simp_World.L07_iff_of_true
msgid "Here, we have that ยง0,ยง1 are both true.\n"
"\n"
"The relevant theorem,\n"
"ยง2"
msgstr ""

#. ยง0: `ยฌ(P โ Q)`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `ยฌ(P โ Q)`
#. ยง6: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{ยฌ(P โ Q)} \\
#. \\hline
#. T & F & T \\
#. \\hline
#. F & T & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง7: `ยฌP`
#. ยง8: `Q`
#. ยง9: `ยฌP โ Q`
#. ยง10: `P`
#. ยง11: `ยฌQ`
#. ยง12: `P โ ยฌQ`
#. ยง13: ```
#. not_iff : ยฌ(a โ b) โ (ยฌa โ b)
#. ```
#: Game.Levels.Simp_World.L08_not_iff
msgid "ยง0 means that ยง1 ,ยง2 don't have the same truth value, i.e. one of them is true and the other is false.\n"
"\n"
"Here are the values for ยง3,ยง4 where ยง5 is satisfied:\n"
"ยง6\n"
"\n"
"We can conclude that ยง7,ยง8 have the same truth value (ยง9), and that ยง10,ยง11 have the same truth value (ยง12).\n"
"\n"
"The theorem for the former simplification:\n"
"ยง13"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid "ยง0 says 'I am a knave or ยง1 is a knight'."
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `A`
#. ยง7: `C`
#. ยง8: `B`
#. ยง9: `B`
#. ยง10: `C`
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
msgid "Suppose the stranger, instead of asking ยง0 what he is,\n"
"asked ยง1, 'How many knights are among you?'\n"
"\n"
"Again ยง2 answers indistinctly. So the stranger asks ยง3, 'What did ยง4 say?\n"
"\n"
"ยง5 replies, 'ยง6 said that there is one knight among us.\n"
"\n"
"Then ยง7 says, 'Don't believe ยง8; he is lying!'\n"
"\n"
"Now what are ยง9 and ยง10?"
msgstr ""

#. ยง0: `ยซ{cont}ยป`
#. ยง1: `not_or`
#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid "\n"
"Simplify ยง0 using ยง1\n"
""
msgstr ""

#: Game
msgid "From the basics to Knights And Knaves"
msgstr ""

#. ยง0: `ยฌยฌP`
#. ยง1: `ยฌP โ False`
#. ยง2: `ยฌP`
#. ยง3: `False`
#: Game.Levels.Simp_World.L05_not_not
msgid "\n"
"Remember that ยง0 means ยง1. You know ยง2 and want to prove ยง3\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `contradiction`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "\n"
"But we already knew that ยง0 is a knave, ยง1.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#: Game.Levels.DSL_Knights_Knaves.L10_allofus
msgid "\n"
"So, ยง0's statement is false.\n"
"\n"
"Conclude that ยง1 is a knave.\n"
""
msgstr ""

#. ยง0: `ยฌC.isKnight`
#: Game.Levels.DSL_Knights_Knaves.L09_same
msgid "\n"
"Conclude ยง0 and close the goal.\n"
""
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `P`
#. ยง4: `P`
#. ยง5: `h : P`
#. ยง6: `P : Prop`
#. ยง7: `h`
#. ยง8: `P`
#. ยง9: `p โง q`
#. ยง10: `p`
#. ยง11: `q`
#. ยง12: `p โง q`
#: Game.Doc.doc
msgid "You can think of a proposition as a statement that is either true or false (obviously, it can't be both at the same time).\n"
"\n"
"Moreover, these statements are denoted by a symbol like ยง0,ยง1,ยง2.\n"
"\n"
"For an object of type ยง3 where ยง4 is of type Prop, i.e. ยง5 where ยง6, ยง7 would be a proof or a witness that ยง8 is true.\n"
"\n"
"# Constructing new propositions from old ones\n"
"The atomic propositions in the compound proposition ยง9 are : ยง10, ยง11. Of course, ยง12 can be used to construct more complicated propositions.\n"
"\n"
"## Connecting Propositions With A Logical Connective\n"
"This truth value depends on the truth value of the propositions it was built out of and the rules of the logical connective. This is clearly illustrated in a truth table.\n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective, i.e. the truth value of the compound statement depending on the truth value of the propositions it connects."
msgstr ""

#: Game.Levels.Logic
msgid "Logic"
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "Propositional Knights and Knaves"
msgstr ""

#: Game
msgid "A guided experience that teaches you everything you need to know to understand and solve knights and knaves logic puzzles, including the basics of lean and logic.\n"
"\n"
"Based on statements made, you will deductively conclude who is a knight (truthful) and who is a knave (liar)."
msgstr ""

#. ยง0: `nB : ยฌB`
#. ยง1: `CdiffA : ยฌ(ยฌC โ ยฌA)`
#. ยง2: `stBn`
#. ยง3: `nB`
#. ยง4: `simp`
#. ยง5: `nB : ยฌB`
#. ยง6: `stA`
#. ยง7: `stA : A โ C`
#. ยง8: `B โจ C`
#. ยง9: `C`
#. ยง10: `C`
#. ยง11: `B`
#. ยง12: `not_iff_not`
#. ยง13: `ยฌC โ ยฌA`
#. ยง14: `CdiffA`
#. ยง15: `C โ A`
#. ยง16: `False`
#. ยง17: `CdiffA`
#. ยง18: `stA.symm : A โ C`
#: Game.Levels.KnightsAndKnaves2.L07_orIff
msgid "\n"
"Assuming ยง0:\n"
"- Prove ยง1 using ยง2, ยง3\n"
"- Using ยง4 and ยง5, reduce ยง6 to ยง7 (ยง8, ยง9 have the same truth value (for ยง10 being true or false) when ยง11 is false).\n"
"- Using ยง12, reduce ยง13 in ยง14 to ยง15.\n"
"- Prove ยง16 using ยง17, ยง18\n"
""
msgstr ""

#. ยง0: `have`
#. ยง1: `A`
#: Game.Levels.KnightsAndKnaves2.L06_
#: Game.Levels.KnightsAndKnaves2.L07_orIff
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "\n"
"Use ยง0 to set ยง1 as the goal\n"
""
msgstr ""

#. ยง0: `Gary`
#. ยง1: `Xavier`
#. ยง2: `Alice`
#: Game.Levels.KnightsAndKnaves2.L04_
msgid "\n"
"Use ยง0 to prove ยง1 and ยง2 and close the goal.\n"
""
msgstr ""

#. ยง0: `knight_or_knave A with AKnight AKnave`
#. ยง1: `knight_or_knave A`
#. ยง2: `h : A.isKnight`
#. ยง3: `h: A.isKnave`
#. ยง4: `h : A.isKnight`
#. ยง5: `A`
#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "\n"
"For the previous step, you also have the option of using the custom tactic ยง0. This would allow you to name the hypothesis of every case.\n"
"\n"
"You could also just do ยง1 without specifying any names.\n"
"\n"
"Go back and try it before proceeding\n"
"\n"
"You get two cases, the first where ยง2 and the second where ยง3\n"
"\n"
"We are now in the first case where ยง4\n"
"So, we can conclude that ยง5's statement is true.\n"
""
msgstr ""

#. ยง0: `knave_to_knight`
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
msgid "\n"
"As usual, from ยง0\n"
""
msgstr ""

#. ยง0: `False`
#. ยง1: `P`
#. ยง2: `ยฌP`
#. ยง3: `P`
#. ยง4: `ยฌP`
#. ยง5: `False`
#. ยง6: ```
#. hP: P
#. hnP: ยฌP
#. ```
#. ยง7: `hnP : ยฌP`
#. ยง8: `P โ False`
#. ยง9: `hnP hP : False`
#. ยง10: `False.elim : False โ Q`
#. ยง11: `Q : Prop`
#. ยง12: `False.elim (hnP hP) : Q`
#. ยง13: `contradiction`
#. ยง14: `False.elim`
#: Game.Doc.doc
msgid "Proving ยง0 means deriving a contradiction.\n"
"\n"
"A contradiction is when ยง1 and ยง2 are both true. We say that ยง3 and ยง4 contradict each other.\n"
"\n"
"# Principle of explosion, from ยง5 anything follows.\n"
"This principle asserts that if you have contradictory assumptions then you can prove anything.\n"
"ยง6\n"
"Since ยง7 is ยง8, we can obtain ยง9.\n"
"\n"
"Moreover, we know that ยง10 for any ยง11 and so ยง12. (using ยง13 would close the goal as well, without having to use ยง14)"
msgstr ""

#. ยง0: `Zoey`
#. ยง1: `ยฌZoey`
#. ยง2: `ยฌZoey โ False`
#. ยง3: `ยฌยฌZoey`
#. ยง4: `Zoey`
#. ยง5: `by_contra hnZ`
#. ยง6: `ยฌZoey`
#. ยง7: ```
#. hnZ : ยฌZoey
#. ```
#: Game.Levels.KnightsAndKnaves2.L01_Intro
msgid "\n"
"To prove ยง0, we will do a proof by contradiction.\n"
"\n"
"We will assume ยง1 and show a contradiction, proving that ยง2, i.e. ยง3 which is equivalent to ยง4.\n"
"\n"
"ยง5 will assume ยง6 adding,\n"
"ยง7\n"
"to the list of assumptions in the proof state.\n"
""
msgstr ""

#. ยง0: `C`
#. ยง1: `ยฌC`
#. ยง2: `stA`
#. ยง3: `ยฌTrue`
#. ยง4: `eq_true`
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "\n"
"We have proven ยง0\n"
"\n"
"Rewrite ยง1 in ยง2 as ยง3 using ยง4\n"
""
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `ยซ{hP}ยป`
#: Game.Levels.Logic.L05_ImpGoal
msgid "\n"
"We have a proof of ยง0 and we want to prove ยง1.\n"
"\n"
"ยง2 exactly matches the goal.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "ยง0 says 'I am a knave or ยง1 is a knave'."
msgstr ""

#. ยง0: `have`
#. ยง1: ```
#. have theorem-name := proof
#. ```
#. ยง2: `Q`
#. ยง3: ```
#. hPQ hP
#. ```
#. ยง4: `have hQ := hPQ hP`
#. ยง5: `hQ : Q`
#. ยง6: `Q`
#. ยง7: `hQ`
#: Game.Levels.Logic.L11_have
msgid "Coming back to ยง0,\n"
"\n"
"If you can prove something in one step, then\n"
"ยง1\n"
"will do.\n"
"\n"
"For example, you can obtain a proof of ยง2 in one step by\n"
"ยง3\n"
"then ยง4 will add ยง5 to the proof state, i.e. you have proven ยง6 and ยง7 is the proof."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `B`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"Now, we know that ยง0 is a knave and ยง1 is a knight.\n"
"\n"
"Conclude ยง2's statement.\n"
""
msgstr ""

#. ยง0: `ยซ{allKnave}ยป.left`
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "\n"
"ยง0 will do it.\n"
""
msgstr ""

#. ยง0: `rw [ยซ{h}ยป]`
#. ยง1: `rw [ยซ{g}ยป]`
#: Game.Levels.EquationalReasoning.L03_rw
msgid "Do ยง0 or ยง1 and observe what happens."
msgstr ""

#. ยง0: `ยฌP,ยฌQ`
#. ยง1: `P,Q`
#. ยง2: `P โ Q`
#: Game.Doc.doc
msgid "If two propositions are false, then they have the same truth value.\n"
"\n"
"If we know ยง0  then we can conclude that ยง1 have the same truth value, i.e. ยง2"
msgstr ""

#. ยง0: `BorC : B โจ C`
#. ยง1: `ยซ{hB}ยป`
#: Game.Levels.KnightsAndKnaves2.L07_orIff
msgid "\n"
"Prove ยง0 using ยง1\n"
""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid "\n"
"Close the goal\n"
""
msgstr ""

#. ยง0: `4 * y = 16`
#. ยง1: `4`
#. ยง2: `y = 4`
#. ยง3: ```
#. Nat.mul_left_cancel firstarg
#.                     secondarg
#. ```
#. ยง4: `firstarg`
#. ยง5: `four_pos`
#. ยง6: `secondarg`
#. ยง7: `h`
#. ยง8: `Nat.mul_left_cancel firstarg secondarg`
#. ยง9: `firstarg`
#. ยง10: `secondarg`
#. ยง11: `exact`
#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "We know that ยง0. Dividing both sides by ยง1 gives us ยง2 which is the goal.\n"
"\n"
"The theorem to do this is:\n"
"ยง3\n"
"where ยง4 is a theorem that the number you are cancelling from both sides is positive, in our case this would be ยง5.\n"
"\n"
"ยง6 would be the equation you are working with, in this case ยง7.\n"
"\n"
"ยง8 would be a proof of the resulting equation after cancelling the positive number specified in ยง9 from both sides of the equation specified in ยง10.\n"
"\n"
"Give this proof to Lean using ยง11."
msgstr ""

#. ยง0: `Zoey`
#. ยง1: `ยฌZoey`
#: Game.Levels.KnightsAndKnaves2.L01_Intro
msgid "\n"
"We have ยง0 and ยง1\n"
""
msgstr ""

#. ยง0: `B.isKnight`
#. ยง1: `B`
#: Game.Levels.DSL_Knights_Knaves.L10_allofus
msgid "\n"
"We are at the case where ยง0\n"
"Conclude that ยง1's statement is true\n"
""
msgstr ""

#. ยง0: ```
#. Objects
#. P : Prop
#. 
#. Assumptions
#. hP : P
#. 
#. Goal
#. P
#. ```
#. ยง1: `assumption`
#: Game.Doc.tactic_doc
msgid "The assumption tactic searches for an assumption that matches the goal, and closes the goal if it finds one.\n"
"\n"
"Given,\n"
"ยง0\n"
"ยง1 will close the goal."
msgstr ""

#. ยง0: `stA`
#. ยง1: `iff_true : (p โ True) = p`
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "\n"
"Rewrite ยง0 using ยง1.\n"
""
msgstr ""

#. ยง0: `B.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"Assume ยง0.\n"
""
msgstr ""

#. ยง0: `B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `C`
#. ยง4: `unfold allKnaves`
#. ยง5: `A,B`
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "\n"
"Now we are in the case where ยง0 is a knave.\n"
"\n"
"Notice what we have.\n"
"\n"
"We have that ยง1 is a knave, ยง2 is a knave, and that not everyone is a knave.\n"
"\n"
"So ยง3 must be a knight.\n"
"\n"
"Solving this is in the same spirit of what you previously did.\n"
"\n"
"ยง4 then simplify it using the fact that ยง5 are knaves\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: ```
#. isKnight A : Prop
#. ```
#. ยง2: ```
#. A.isKnight : Prop
#. ```
#. ยง3: `A`
#: Game.Doc.doc
msgid "For an Islander ยง0,\n"
"ยง1\n"
"or\n"
"ยง2\n"
"is the proposition that ยง3 is a knight."
msgstr ""

#. ยง0: `3 + 3 = 6`
#. ยง1: `rw`
#. ยง2: `rfl`
#. ยง3: `3`
#. ยง4: `6`
#. ยง5: ```
#. rw [h,g]
#. ```
#. ยง6: ```
#. rw [h]
#. rw [g]
#. ```
#: Game.Levels.EquationalReasoning.L03_rw
msgid "Our goal is now ยง0. The ยง1 tactic implicitly executes ยง2 after doing the rewrite which unfolds the numbers ยง3 and ยง4 to what they are defined as, and it turns out both sides are identical.\n"
"\n"
"Another solution:\n"
"ยง5\n"
"instead of\n"
"ยง6"
msgstr ""

#: Game.Doc.doc
msgid "A is a knave, so whatever A said is false"
msgstr ""

#. ยง0: ```
#. or_true (p : Prop)
#. : (p or True) = True
#. ```
#. ยง1: `simp`
#. ยง2: ```
#. simp [h]
#. ```
#. ยง3: `simp`
#: Game.Levels.Simp_World.L02_true_or
msgid "There's an analogous theorem\n"
"ยง0\n"
"\n"
"To solve with ยง1,\n"
"ยง2\n"
"\n"
"Try ยง3 before moving on."
msgstr ""

#. ยง0: `dsl_iamknave`
#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
msgid "\n"
"Use ยง0.\n"
""
msgstr ""

#. ยง0: `ยซ{orexp}ยป`
#. ยง1: `simp`
#. ยง2: `A`
#. ยง3: `isKnave A`
#. ยง4: `ยซ{orexp}ยป`
#. ยง5: `ยฌisKnight A`
#. ยง6: `simp`
#. ยง7: `A`
#. ยง8: `ยซ{orexp}ยป`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "\n"
"ยง0 can be simplified, using ยง1 and the fact that ยง2 is a knight and that knights are not knaves.\n"
"\n"
"First, change ยง3 in ยง4 to ยง5 then use ยง6 and the fact that ยง7 is a knight to simplify ยง8\n"
""
msgstr ""

#. ยง0: `Nat.mul_left_cancel`
#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "ยง0, Divide both sides of an equation"
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "\n"
"Assume ยง0 is a knight, and conclude that everyone must be a knave.\n"
""
msgstr ""

#. ยง0: `ยซ{g}ยป`
#: Game.Levels.EquationalReasoning.L03_rw
msgid "You should use ยง0 now."
msgstr ""

#. ยง0: `Mel`
#. ยง1: `ยฌZoey`
#. ยง2: `stZn`
#: Game.Levels.KnightsAndKnaves2.L01_Intro
#: Game.Levels.KnightsAndKnaves2.L05_iff
#: Game.Levels.KnightsAndKnaves2.L05_iff
#: Game.Levels.KnightsAndKnaves2.L07_orIff
msgid "\n"
"Prove ยง0 using ยง1, ยง2.\n"
""
msgstr ""

#. ยง0: ```
#. stG.mpr : (Alice โ Gary) โ Gary
#. ```
#. ยง1: ```
#. stG.mpr stA : Gary
#. ```
#: Game.Levels.KnightsAndKnaves2.L04_
msgid "\n"
"Note that,\n"
"ยง0\n"
"and so\n"
"ยง1\n"
""
msgstr ""

#. ยง0: `Nat.mul_left_cancel`
#. ยง1: ```
#. Nat.mul_left_cancel
#. (np : 0 < n)
#. (h : n * m = n * k)
#. : m = k
#.   ```
#. ยง2: `Nat.mul_left_cancel`
#. ยง3: `np`
#. ยง4: `n`
#. ยง5: `h`
#. ยง6: `n`
#. ยง7: `:`
#. ยง8: `n`
#. ยง9: `m = k`
#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "Here is the type signature of ยง0:\n"
"  ยง1\n"
"  ยง2 takes two arguments which are:\n"
"   - ยง3, a proof that some number ยง4 is positive.\n"
"   - ยง5, an equation which has ยง6 on both sides of the equation multiplied on the left.\n"
"\n"
"  The result is what's after ยง7, canceling ยง8 from both sides of the equation giving a proof ยง9."
msgstr ""

#. ยง0: `A`
#. ยง1: ```
#. not_isKnight_and_isKnave
#. (AKnight : isKnight A)
#. (AKnave : isKnave A) : False
#. ```
#. ยง2: `False`
#. ยง3: `contradiction`
#. ยง4: `A`
#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "\n"
"We know ยง0 is a knight and a knave.\n"
"This is a contradiction\n"
"\n"
"Recall\n"
"ยง1\n"
"\n"
"You can use this to prove ยง2, or use ยง3 which has been modified to handle when ยง4 is a knight and a knave.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "\n"
"ยง0 is a knight, so we can conclude ยง1's statement.\n"
""
msgstr ""

#. ยง0: `have`
#. ยง1: `A`
#. ยง2: `A`
#. ยง3: `ยฌยฌA`
#. ยง4: `A`
#. ยง5: `ยฌA โ False`
#. ยง6: `by_contra`
#. ยง7: `by_contra h`
#. ยง8: `h : ยฌA`
#. ยง9: `False`
#. ยง10: `nA : ยฌA`
#. ยง11: `nCnB : ยฌC โง ยฌB`
#. ยง12: `stAn`
#. ยง13: `AdiffC : ยฌ(A โ C)`
#. ยง14: `stBn`
#. ยง15: `nCnB.right : ยฌB`
#. ยง16: `AiffC : A โ C`
#. ยง17: `iff_of_false (ha : ยฌa) (hb : ยฌb) : a โ b `
#. ยง18: `nA:ยฌA`
#. ยง19: `nCnB.left : ยฌC`
#. ยง20: `False`
#. ยง21: `AdiffC : ยฌ(A โ C)`
#. ยง22: `AiffC : (A โ C)`
#: Game.Levels.KnightsAndKnaves2.L05_iff
msgid "\n"
"Use ยง0 to set ยง1 as the new goal.\n"
"\n"
"We want to prove ยง2, to do this we will prove ยง3 (which is equivalent to ยง4), i.e. ยง5. The tactic ยง6 facilitates this.\n"
"\n"
"ยง7 assumes ยง8 and changes the goal to ยง9.\n"
"\n"
"This is called a proof by contradiction because we are assuming the negation of what we want to prove and getting a contradiction.\n"
"\n"
"Assuming ยง10,\n"
"- Prove ยง11 from ยง12\n"
"- Prove ยง13 from ยง14, ยง15\n"
"- Prove ยง16 from ยง17, ยง18, ยง19\n"
"- Prove ยง20 from ยง21  ยง22\n"
""
msgstr ""

#. ยง0: ```
#. not_iff' : ยฌ(P โ Q) โ (P โ ยฌQ)
#. ```
#: Game.Levels.Simp_World.L08_not_iff
msgid "Analogous Theorem:\n"
"ยง0"
msgstr ""

#. ยง0: `Lean`
#. ยง1: `mathlib`
#. ยง2: `Lean`
#. ยง3: `Lean`
#. ยง4: `Lean`
#. ยง5: `Lean`
#. ยง6: `Lean`
#: Game
msgid "Many technical details have been skipped for the sake of not getting bogged down with ยง0 and its mathematical library ยง1, but focus on the aspects of reasoning and proof. You can search https://leanprover-community.github.io/mathlib4_docs/ for more information about any tactic or theorem used.\n"
"\n"
"# Editor Mode\n"
"Editor mode mimics the ยง2 experience in vscode which is the most common way to use ยง3.\n"
"\n"
"To access editor mode, click on the icon next to the hamburger menu in the top right when in a level.\n"
"\n"
"## vscode-like environment\n"
"Hovering over tactics/theorems will give you the official documentation.\n"
"\n"
"# Links\n"
"## Documentation\n"
"https://leanprover-community.github.io/mathlib4_docs/\n"
"\n"
"https://lean-lang.org/documentation/\n"
"\n"
"https://leanprover-community.github.io/\n"
"\n"
"https://lean-lang.org/\n"
"\n"
"https://github.com/leanprover-community/mathlib4\n"
"\n"
"\n"
"## Zulip, ask questions\n"
"Zulip chat for ยง4 has been a very useful resource to resolve issues when formalizing the exercises, you can visit it and ask questions in the '#new members' stream. You can also view messages without signing up. There are other streams dedicated to various topics you can check out as well.\n"
"\n"
"https://leanprover.zulipchat.com/\n"
"\n"
"https://zulip.com/case-studies/lean/\n"
"\n"
"## Knights and Knaves\n"
"\n"
"### Sources for the puzzles:\n"
"\n"
"Some puzzles were taken as is, other were modified or inspired variations.\n"
"\n"
"- Wolfram Cloud [Puzzle\n"
"Generator](https://www.wolframcloud.com/objects/demonstrations/KnightsAndKnavesPuzzleGenerator-source.nb)\n"
"\n"
"- [382 Puzzles](https://philosophy.hku.hk/think/logic/knights.php)\n"
"\n"
"- [What Is The Name Of This Book](https://raymondsmullyan.com/books/what-is-the-name-of-this-book/) by Raymond Smullyan\n"
"\n"
"### Insightful:\n"
"\n"
"- Knights and Knaves in a logic programming language (prolog):\n"
"https://www.youtube.com/watch?v=oEAa2pQKqQU\n"
"\n"
"- Blog post series, includes introduction, representation and formalization, automated solutions using other provers, and creating your own puzzles.\n"
"https://summerofgodel.blogspot.com/2019/04/table-of-contents-for-series-of-posts.html?\n"
"\n"
"# Rules\n"
"You can relax the rules and skip levels.\n"
"\n"
"This is not recommended for if you have never used ยง5 before because every level depends on\n"
"introduced tactics/theorems/ideas in previous levels. Moreover, relaxing the rules would ruin the\n"
"structured/guided experience this game is supposed to offer. If that is what you are looking for, then don't relax the rules.\n"
"\n"
"# Github, Level Solutions\n"
"[Github Repository](https://github.com/JadAbouHawili/KnightsAndKnaves-Lean4Game)\n"
"\n"
"You can view the ยง6 code for every level there (and the solution if you are really stuck).\n"
"\n"
"# Other Knights and Knaves Educational Games\n"
"[Timer Game](https://en.oiler.education/bul)\n"
"\n"
"[Terminal-Like](https://christopherphelps.trinket.io/sites/knight_knave_puzzler)"
msgstr ""

#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Doc.doc
#: Game.Levels.Logic.L03_Or
#: Game.Levels.Logic.L06_cases
#: Game.Levels.Logic.L11_have
#: Game.Levels.Logic.L11_have
#: Game.Levels.Simp_World.L06_iff_of_false
#: Game.Levels.Simp_World.L07_iff_of_true
#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
#: Game.Levels.DSL_Knights_Knaves.L03_prob26
#: Game.Levels.DSL_Knights_Knaves.L03_prob26
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
#: Game.Levels.DSL_Knights_Knaves.L05_prob29
#: Game.Levels.DSL_Knights_Knaves.L06_prob33
#: Game.Levels.DSL_Knights_Knaves.L06_prob33
#: Game.Levels.DSL_Knights_Knaves.L07_difftype
#: Game.Levels.DSL_Knights_Knaves.L07_difftype
#: Game.Levels.DSL_Knights_Knaves.L08_sametype
#: Game.Levels.DSL_Knights_Knaves.L08_sametype
#: Game.Levels.DSL_Knights_Knaves.L09_same
#: Game.Levels.DSL_Knights_Knaves.L09_same
#: Game.Levels.DSL_Knights_Knaves.L10_allofus
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
#: Game.Levels.DSL_Knights_Knaves.L12_31
#: Game.Levels.DSL_Knights_Knaves.L12_31
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
#: Game.Levels.KnightsAndKnaves2.L01_Intro
#: Game.Levels.KnightsAndKnaves2.L01_Intro
#: Game.Levels.KnightsAndKnaves2.L02_Introduction
#: Game.Levels.KnightsAndKnaves2.L03_iff_iff
#: Game.Levels.KnightsAndKnaves2.L03_iff_iff
#: Game.Levels.KnightsAndKnaves2.L04_
#: Game.Levels.KnightsAndKnaves2.L04_
#: Game.Levels.KnightsAndKnaves2.L05_iff
#: Game.Levels.KnightsAndKnaves2.L05_iff
#: Game.Levels.KnightsAndKnaves2.L06_
#: Game.Levels.KnightsAndKnaves2.L06_
#: Game.Levels.KnightsAndKnaves2.L07_orIff
#: Game.Levels.KnightsAndKnaves2.L07_orIff
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid ""
msgstr ""

#. ยง0: `have`
#. ยง1: ```
#. have theorem-name := expression
#. ```
#. ยง2: `expression : P`
#. ยง3: `P : Prop`
#. ยง4: `expression`
#. ยง5: `P`
#. ยง6: ```
#. theorem-name : P
#. ```
#. ยง7: `P`
#. ยง8: `theorem-name`
#. ยง9: ```
#. have theorem-name : theorem-prop
#. ```
#. ยง10: `theorem-prop : Prop`
#. ยง11: `theorem-name : theorem-prop`
#. ยง12: `theorem-prop`
#. ยง13: ```
#. have a : 2=2
#. ```
#. ยง14: `2=2`
#. ยง15: `a : 2=2`
#: Game.Doc.tactic_doc
msgid "The ยง0 tactic allows you to add theorems to the context (which you would have to prove, of course).\n"
"\n"
"## One step\n"
"If the proof is one step, then the following:\n"
"ยง1\n"
"will do, where ยง2 with ยง3, i.e. ยง4 is a proof of ยง5\n"
"\n"
"The result would be adding the following to the hypothesis:\n"
"ยง6\n"
"\n"
"You are storing the proof of ยง7 in ยง8 so that you don't have to construct this proof everytime you need it.\n"
"\n"
"## Multiple steps\n"
"If the proof is multiple steps, then:\n"
"ยง9\n"
"will change the current goal to ยง10 which is what you want to prove.\n"
"\n"
"After being proven, the original goal is restored with ยง11 added (which is a proof of the proposition ยง12)\n"
"\n"
"### Example\n"
"ยง13\n"
"will change the goal to ยง14, which after proving would restore the original goal with the theorem ยง15 added and ready to be used."
msgstr ""

#. ยง0: ```
#. Assumptions:
#. h : A = B
#. 
#. Goal:
#. some expression involving A
#. ```
#. ยง1: `rw [h]`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `rw [h] at h'`
#. ยง5: `h'`
#. ยง6: `h`
#. ยง7: `A`
#. ยง8: `B`
#. ยง9: `rw [โh]`
#. ยง10: `h`
#. ยง11: `B`
#. ยง12: `A`
#. ยง13: `=`
#. ยง14: `โ`
#. ยง15: `rw [h]`
#. ยง16: `h : x=2`
#. ยง17: `h : P โ Q`
#: Game.Doc.tactic_doc
msgid "Given the following:\n"
"ยง0\n"
"\n"
"ยง1 would change the goal by replacing every occurrence of ยง2 with ยง3.\n"
"\n"
"Moreover ยง4 would apply the rewrite on an assumption ยง5 instead of the goal.\n"
"\n"
"By default, rw uses an equation in the forward direction, matching the left-hand side of the equation ยง6 with an occurrence of ยง7 in the goal, and replaces it with the right-hand side, i.e. ยง8.\n"
"\n"
"The notation ยง9 can be used to instruct the tactic to use the equality ยง10 in the reverse direction, i.e. replace an occurrence of ยง11 with ยง12.\n"
"\n"
"## Behavior with ยง13 and ยง14\n"
"For ยง15, the behavior is exactly the same for both, whether you had ยง16 or ยง17."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `P`
#. ยง3: `P`
#. ยง4: `intro`
#. ยง5: `intro h`
#. ยง6: `h`
#: Game.Levels.Logic.L05_ImpGoal
msgid "The goal, translated to English, is: 'If ยง0 is true, then ยง1 is true'.\n"
"\n"
"To prove such a goal, we need to assume that ยง2 is true. Then, we have to prove that ยง3 is true.\n"
"\n"
"To do this, we need to assume the premise, i.e. introduce it to our assumptions. We can do this using the ยง4 tactic. ยง5 will introduce an assumption ยง6."
msgstr ""

#. ยง0: `Q`
#. ยง1: `ยซ{hQ}ยป : Q`
#. ยง2: `hQR`
#. ยง3: `ยซ{hQ}ยป`
#. ยง4: `R`
#: Game.Levels.Logic.L10_have
msgid "\n"
"Now that you proved ยง0, its proof ยง1 has been added to the assumptions.\n"
"\n"
"ยง2 takes ยง3 and gives you a proof of ยง4 which is the goal.\n"
""
msgstr ""

#. ยง0: `B.isKnave`
#. ยง1: `ยฌB.isKnight`
#: Game.Levels.DSL_Knights_Knaves.L10_allofus
msgid "\n"
"Now we have that ยง0.\n"
"Get ยง1\n"
""
msgstr ""

#. ยง0: `ยฌA.isKnight`
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "\n"
"Start by proving ยง0\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `B`
#. ยง4: `C`
#. ยง5: `A`
#: Game.Levels.KnightsAndKnaves2.L02_Introduction
msgid "ยง0: ยง1 is a knight and ยง2 is a knight.\n"
"\n"
"ยง3: ยง4 is a knight and ยง5 is a knave."
msgstr ""

#. ยง0: `โ`
#. ยง1: `P โ Q`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `P โ Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P`
#. ยง8: `Q`
#. ยง9: `P`
#. ยง10: `Q`
#. ยง11: $
#. \\begin{array}{|c|c|c|}
#. \\hline
#. P & Q & P โ Q \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง12: `P โ Q`
#. ยง13: `P`
#. ยง14: `Q`
#. ยง15: `P โ Q`
#. ยง16: `P`
#. ยง17: `Q`
#. ยง18: `P`
#. ยง19: `P โ Q`
#. ยง20: `Q`
#. ยง21: `Q`
#. ยง22: `P`
#. ยง23: `Q`
#. ยง24: `P`
#. ยง25: `P`
#. ยง26: `P`
#. ยง27: `P โ Q`
#. ยง28: `P โ Q`
#. ยง29: `Q`
#. ยง30: `Q`
#. ยง31: `P`
#. ยง32: `Q`
#. ยง33: `ptoq : P โ Q`
#. ยง34: `hP : P`
#. ยง35: `Q`
#. ยง36: `exact`
#: Game.Levels.Logic.L04_Implication
msgid "In this level, we introduce the logical implication ยง0 connective.\n"
"Logical implication ยง1 is made up of two components:\n"
"- The premise, which in this case is ยง2\n"
"- The conclusion, which in this case is ยง3\n"
"\n"
"ยง4 is read as 'If ยง5 is true, then ยง6 is true'.\n"
"ยง7 being true IMPLIES ยง8 being true. A proof of ยง9 IMPLIES a proof of ยง10.\n"
"\n"
"# Truth table\n"
"ยง11\n"
"\n"
"A statement ยง12 is false when ยง13 is true and ยง14 false, it's true otherwise.\n"
"This is because this is the only case where the meaning of ยง15 is violated, i.e. we have that ยง16 is true so ยง17 is supposed to be true as well but it's not.\n"
"\n"
"When ยง18 is false, the implication ยง19 is always true regardless of the truth value of ยง20. That's because the implication does not tell us what ยง21 should be when ยง22 is false -- it only tells us that ยง23 must be true when ยง24 is true.\n"
"\n"
"In the current proof state, we know ยง25 (i.e. ยง26 is true), and we know ยง27 (i.e. ยง28 is true). Therefore, we can conclude ยง29 (i.e. ยง30 is true ).\n"
"\n"
"You can think of logical implication as a function with one input and one output. It takes a proof of ยง31 and returns a proof of ยง32.\n"
"\n"
"Give ยง33 the proof ยง34 to get a proof of ยง35.\n"
"\n"
"You can then use ยง36 to close the goal"
msgstr ""

#. ยง0: `rw`
#. ยง1: `ยฌยฌP`
#. ยง2: `P`
#. ยง3: `not_not`
#: Game.Levels.Simp_World.L05_not_not
msgid "\n"
"ยง0 ยง1 to ยง2 using ยง3.\n"
""
msgstr ""

#. ยง0: `Mel and Zoey`
#. ยง1: `Mel`
#. ยง2: `stM`
#: Game.Levels.KnightsAndKnaves2.L01_Intro
#: Game.Levels.KnightsAndKnaves2.L05_iff
#: Game.Levels.KnightsAndKnaves2.L06_
#: Game.Levels.KnightsAndKnaves2.L06_
#: Game.Levels.KnightsAndKnaves2.L06_
#: Game.Levels.KnightsAndKnaves2.L07_orIff
#: Game.Levels.KnightsAndKnaves2.L07_orIff
msgid "\n"
"Prove ยง0 using ยง1, ยง2\n"
""
msgstr ""

#. ยง0: `โง`
#: Game.Levels.Logic.L02_And
msgid "And, ยง0"
msgstr ""

#. ยง0: `A`
#. ยง1: `C`
#. ยง2: `B`
#. ยง3: `B`
#. ยง4: `A`
#. ยง5: `C`
#: Game.Levels.KnightsAndKnaves2.L05_iff
msgid "ยง0: ยง1 is a knight or ยง2 is a knight.\n"
"\n"
"ยง3: ยง4 is a knight, if and only if ยง5 is a knight."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `B`
#. ยง3: `C`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: ```
#. allKnights
#. allKnaves
#. ```
#. ยง7: `unfold`
#. ยง8: ```
#. A.isKnight โง B.isKnight โง C.isKnave
#. ```
#. ยง9: ```
#. unfold allKnights at stB
#. ```
#. ยง10: `allKnaves`
#. ยง11: `unfold`
#: Game.Levels.DSL_Knights_Knaves.L10_allofus
msgid "ยง0 says ยง1 is a knight\n"
"\n"
"ยง2 says all of us are knights\n"
"\n"
"ยง3 says ยง4  is a knight or ยง5 is a knight\n"
"\n"
"Notice in the proof state,\n"
"ยง6\n"
"\n"
"You can ยง7 to get\n"
"ยง8\n"
"by\n"
"ยง9\n"
"(similarly for ยง10)\n"
"\n"
"However, this will make the proof state look cluttered so don't ยง11."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid "\n"
"The left side of or is false and so can be simplified.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `A`
#. ยง6: `B`
#. ยง7: `A`
#. ยง8: `B`
#. ยง9: `C`
#. ยง10: `A.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "Again we have three people, ยง0, ยง1, ยง2, each of whom is either a knight or a knave.\n"
"\n"
"ยง3 and ยง4 make the following statements:\n"
"\n"
"ยง5: All of us are knaves.\n"
"\n"
"ยง6: Exactly one of us is a knight.\n"
"\n"
"What are ยง7, ยง8, ยง9?\n"
"\n"
"Change the goal to ยง10"
msgstr ""

#. ยง0: `left`
#. ยง1: `right`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "\n"
"Choose which side to prove, ยง0 or ยง1?\n"
""
msgstr ""

#. ยง0: `โฉ`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: ```
#. A โฉ B
#. ```
#. ยง4: `A โฉ B`
#. ยง5: `A`
#. ยง6: `B`
#. ยง7: `x โ A โฉ B โ x โ A โง x โ B`
#. ยง8: `A โฉ B = โ`
#. ยง9: `A`
#. ยง10: `B`
#. ยง11: `A`
#. ยง12: `B`
#. ยง13: `x โ A โ x โ B`
#. ยง14: `x โ B โ x โ A`
#. ยง15: `inleft_notinright`
#. ยง16: `inright_notinleft`
#: Game.Doc.doc
msgid "ยง0 is an operator on sets.\n"
"\n"
"Applying it to two sets ยง1,ยง2:\n"
"ยง3\n"
"\n"
"ยง4 is itself another set, containing elements that are in both ยง5 and ยง6.\n"
"In other words, ยง7.\n"
"\n"
"ยง8 means that ยง9 and ยง10 have no common element, i.e. no element of ยง11 belongs to both and no element of ยง12 belongs to both.\n"
"In other words, ยง13, ยง14 which are ยง15 and ยง16 respectively."
msgstr ""

#. ยง0: `A`
#. ยง1: `ยฌยฌA`
#. ยง2: `ยฌA โ False`
#. ยง3: `by_contra`
#. ยง4: `ยฌA`
#. ยง5: `False`
#. ยง6: `hA : ยฌA`
#. ยง7: `hCnB : C โง ยฌ B`
#. ยง8: `stAn`
#. ยง9: `nA`
#. ยง10: `AsameC : ยฌ(ยฌA โ C)`
#. ยง11: `stBn`
#. ยง12: `hCnB.right : ยฌB`
#. ยง13: `nAiffC : ยฌA โ C`
#. ยง14: `iff_of_true`
#. ยง15: `nA`
#. ยง16: `hCnB.left : C`
#. ยง17: `False`
#. ยง18: `nAiffC`
#. ยง19: `AsameC`
#. ยง20: `ยฌA โ False`
#. ยง21: `ยฌยฌA`
#. ยง22: `A`
#: Game.Levels.KnightsAndKnaves2.L06_
msgid "\n"
"We want to prove ยง0, to do this we will prove ยง1, i.e. ยง2. The tactic ยง3 facilitates this, assuming ยง4 and changing the goal to ยง5.\n"
"\n"
"Assuming ยง6:\n"
"- Prove ยง7 using ยง8, ยง9.\n"
"- Prove ยง10 using ยง11, ยง12\n"
"- Prove ยง13 using ยง14, ยง15, ยง16\n"
"- Prove ยง17 from ยง18 and ยง19 therefore proving that ยง20, i.e. ยง21, i.e. ยง22\n"
""
msgstr ""

#. ยง0: `False`
#: Game.Levels.Logic.L08_Not
msgid "In the next level, we will explore what it means to have proven ยง0, and what it means to have contradictory assumptions/propositions."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#: Game.Levels.Logic.L04_Implication
msgid "In the next level, you will learn how to deal with an implication as the goal you have to prove."
msgstr ""

#. ยง0: `unfold oneisknight at ยซ{notoneknight}ยป`
#. ยง1: `simp`
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
msgid "\n"
"It is not true that there is one knight, but that is the case so contradiction\n"
"\n"
"ยง0 and use ยง1\n"
""
msgstr ""

#. ยง0: `stR`
#. ยง1: `ยฌIra.isKnight`
#. ยง2: `Robert.isKnight โ Ira.isKnight `
#. ยง3: `ยฌ Robert.isKnight`
#: Game.Levels.DSL_Knights_Knaves.L08_sametype
msgid "\n"
"We will now simplify ยง0.\n"
"\n"
"Because ยง1, ยง2 can be simplified to ยง3\n"
""
msgstr ""

#. ยง0: `by_contra`
#. ยง1: `not_not`
#: Game.Levels.Simp_World.L05_not_not
msgid "ยง0, ยง1"
msgstr ""

#. ยง0: `have`
#. ยง1: `ยฌA`
#: Game.Levels.KnightsAndKnaves2.L02_Introduction
#: Game.Levels.KnightsAndKnaves2.L02_Introduction
msgid "\n"
"Use ยง0 to set ยง1 as the new goal.\n"
""
msgstr ""

#. ยง0: `Ira`
#. ยง1: `Robert`
#: Game.Levels.DSL_Knights_Knaves.L08_sametype
msgid "\n"
"Now that ยง0 is a knight, conclude that ยง1 is a knight and close the goal.\n"
""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "This is it for this approach of knights and knaves.\n"
"\n"
"If you want more, you can try the other approaches."
msgstr ""

#. ยง0: `True or Q`
#. ยง1: `True`
#. ยง2: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{P or Q} \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & T \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง3: `P or Q`
#. ยง4: `P = True`
#. ยง5: `True or Q`
#. ยง6: `True`
#. ยง7: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{P or Q} \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง8: ```
#. true_or (p : Prop) : (True or p) = True
#. ```
#: Game.Levels.Simp_World.L02_true_or
msgid "\n"
"We can simplify ยง0 to ยง1\n"
"\n"
"ยง2\n"
"ยง3 is always true for ยง4, i.e. ยง5 and ยง6 have the same truth value.\n"
"\n"
"ยง7\n"
"\n"
"You can use the theorem\n"
"ยง8\n"
""
msgstr ""

#. ยง0: `simp at stA`
#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
#: Game.Levels.DSL_Knights_Knaves.L08_sametype
msgid "\n"
"ยง0\n"
""
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "In this world, you will learn how to solve equations."
msgstr ""

#. ยง0: `ยฌ`
#. ยง1: `P`
#. ยง2: `ยฌP`
#. ยง3: `P`
#. ยง4: `ยฌP`
#. ยง5: $
#. \\begin{array}{|c|c|}
#. \\hline
#. P & ยฌP \\
#. \\hline
#. T & F \\
#. F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง6: `P`
#. ยง7: `ยฌP`
#. ยง8: `hnP`
#. ยง9: `False`
#. ยง10: $
#. \\begin{array}{|c|c|c|}
#. \\hline
#. P & Q & P โ Q \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง11: `Q=False`
#. ยง12: $
#. \\begin{array}{|c|c|}
#. \\hline
#. P & P โ False \\
#. \\hline
#. T & F \\
#. F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง13: `P`
#. ยง14: `ยฌP`
#. ยง15: `P โ False`
#. ยง16: `ยฌP โ (P โ False)`
#. ยง17: `ยฌP`
#. ยง18: `P`
#. ยง19: `P`
#. ยง20: `ยฌP`
#. ยง21: `unfold Not`
#. ยง22: `ยฌ`
#. ยง23: `unfold Not at hnP`
#. ยง24: `hnP`
#: Game.Levels.Logic.L08_Not
msgid "In this level we introduce the negation, the ยง0 connective (read as 'not').\n"
"\n"
"Notice that this is the first logical connective that applies on one proposition only and not two.\n"
"\n"
"The job of this connective (as the name implies), is to negate a proposition:\n"
"- For ยง1 true, ยง2 is false.\n"
"- For ยง3 false, ยง4 is true.\n"
"\n"
"In truth table form:\n"
"ยง5\n"
"\n"
"Notice that since ยง6 is true, ยง7 should be false but in this proof state it is true (by ยง8). This is a contradiction. The goal is to prove ยง9 which means to prove a contradiction.\n"
"\n"
"Note that we don't need to introduce a new symbol to define negation, it can be defined in terms of what we already know.\n"
"\n"
"Consider the following truth table:\n"
"ยง10\n"
"\n"
"Let's focus on the rows where ยง11,\n"
"ยง12\n"
"\n"
"Notice that regardless of the truth value of ยง13, the two propositions ยง14 and ยง15 have the same truth table. Therefore, they can be used interchangeably (we say that these two expressions are logically equivalent, ยง16).\n"
"\n"
"What ยง17 means is that if ยง18 were true, then we can deduce a contradiction. We know that ยง19 is true. Therefore, we can prove a contradiction which is the goal.\n"
"\n"
"To see ยง20 in its implication form, you can do ยง21 to unfold the definition of ยง22. Note that this would apply to the goal, and so ยง23 applies at ยง24."
msgstr ""

#. ยง0: `knave_said`
#. ยง1: `A`
#. ยง2: `A`
#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "\n"
"ยง0\n"
"\n"
"ยง1 is a knave, so whatever ยง2 said is false.\n"
""
msgstr ""

#. ยง0: `ยฌC`
#. ยง1: `stA`
#. ยง2: `eq_true`
#. ยง3: `True โ ยฌB`
#. ยง4: `stA`
#. ยง5: `ยฌB`
#. ยง6: `true_implies`
#. ยง7: `B`
#. ยง8: `stA`
#. ยง9: `A`
#. ยง10: `stB`
#. ยง11: `False`
#. ยง12: `not_iff_self`
#. ยง13: `stA`
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "\n"
"- Rewrite ยง0 in ยง1 with true using ยง2\n"
"- Rewrite ยง3 in ยง4 with ยง5 using ยง6\n"
"- Rewrite ยง7 in ยง8 with ยง9 using ยง10\n"
"- Prove ยง11 using ยง12 and ยง13\n"
""
msgstr ""

#. ยง0: `B`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"Conclude that ยง0's statement is false\n"
""
msgstr ""

#. ยง0: `constructor`
#. ยง1: `P and Q`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `And.intro hP hQ`
#. ยง5: `\\<hP,hQ\\>`
#: Game.Levels.Logic.L02_And
msgid "You can also use the ยง0 tactic which will split the goal ยง1 into two,\n"
"the first being to prove ยง2 and the second being to prove ยง3.\n"
"\n"
"Moreover, instead of ยง4 you can use the notation ยง5 which means the same thing."
msgstr ""

#. ยง0: `exact`
#: Game.Levels.EquationalReasoning.L02_exact
msgid "ยง0, goal is true by assumption"
msgstr ""

#. ยง0: `P`
#. ยง1: `x=2`
#. ยง2: `hP`
#. ยง3: `P`
#. ยง4: `P`
#. ยง5: `Prop`
#. ยง6: `hP`
#. ยง7: `P`
#. ยง8: `P`
#. ยง9: `hP`
#. ยง10: `hP`
#. ยง11: `hP`
#: Game.Levels.Logic.L01_Intro
msgid "This should look familiar.\n"
"\n"
"If it doesn't, then replace ยง0 by ยง1.\n"
"\n"
"ยง2 is of type ยง3 and ยง4 is of type ยง5. So, ยง6 is a proof of ยง7. Our goal is to prove ยง8. We already have such a proof which is ยง9, ยง10 is EXACTLY what we need to prove the goal. The type of ยง11 EXACTLY matches the goal."
msgstr ""

#. ยง0: `C`
#. ยง1: `nC : ยฌC`
#. ยง2: `by_contra nC`
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "\n"
"We will prove ยง0 by contradiction.\n"
"\n"
"Assume ยง1 using ยง2.\n"
""
msgstr ""

#. ยง0: `A.isKnight`
#. ยง1: `B.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L09_same
msgid "\n"
"We are in the case where ยง0\n"
"\n"
"Conclude that ยง1\n"
""
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L12_31
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
msgid "\n"
"Conclude ยง0's statement\n"
""
msgstr ""

#. ยง0: `rw`
#: Game.Levels.EquationalReasoning.L03_rw
msgid "ยง0, Substituting Variables By Their Values"
msgstr ""

#. ยง0: `h : A.isKnave`
#. ยง1: `A`
#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "\n"
"We are now in the second case where ยง0\n"
"So, we can conclude that ยง1's statement is false.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `C`
#. ยง2: `B`
#. ยง3: `B`
#. ยง4: `A`
#. ยง5: `C`
#: Game.Levels.KnightsAndKnaves2.L06_
msgid "ยง0: ยง1 is a knave or ยง2 is a knight.\n"
"\n"
"ยง3: ยง4 is a knave, if and only if ยง5 is a knight."
msgstr ""

#. ยง0: `left`
#. ยง1: `right`
#: Game.Levels.DSL_Knights_Knaves.L10_allofus
msgid "\n"
"ยง0 or ยง1 part of the goal?\n"
""
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Intro"
msgstr ""

#. ยง0: `stR`
#. ยง1: `Robert said ยฌ Robert.isKnight`
#. ยง2: `Robert said Robert.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L08_sametype
msgid "\n"
"ยง0 now becomes ยง1.\n"
"\n"
"Change that to ยง2\n"
"\n"
""
msgstr ""

#. ยง0: `B.isKnight`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"Let's move on to proving ยง0\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `C`
#. ยง2: `B`
#. ยง3: `B`
#. ยง4: `A`
#. ยง5: `C`
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "ยง0: If ยง1 is a knave, then ยง2 is a knave.\n"
"ยง3: ยง4 is a knight, if and only if ยง5 is a knave."
msgstr ""

#. ยง0: `rw [g]`
#: Game.Levels.EquationalReasoning.L03_rw
#: Game.Levels.Logic.L10_have
#: Game.Levels.Simp_World.L01_or_false
#: Game.Levels.Simp_World.L02_true_or
#: Game.Levels.Simp_World.L03_not_or
#: Game.Levels.Simp_World.L04_not_and_or
#: Game.Levels.Simp_World.L06_iff_of_false
#: Game.Levels.Simp_World.L07_iff_of_true
#: Game.Levels.Simp_World.L08_not_iff
#: Game.Levels.Simp_World.L09_not_iff_not
msgid "ยง0"
msgstr ""

#. ยง0: `Objects`
#. ยง1: `Assumptions`
#. ยง2: `Goal`
#. ยง3: `:`
#. ยง4: `:`
#. ยง5: `x`
#. ยง6: `: โ`
#. ยง7: `x : โ`
#. ยง8: `x`
#. ยง9: `1`
#. ยง10: `2`
#. ยง11: `3`
#. ยง12: `h : x=2`
#. ยง13: `h`
#. ยง14: `x=2`
#. ยง15: `h`
#. ยง16: `x=2`
#. ยง17: `x=2`
#. ยง18: `h`
#. ยง19: `x = 2`
#. ยง20: `h : x=2`
#. ยง21: `h`
#. ยง22: `x=2`
#. ยง23: `h`
#. ยง24: `Lean`
#. ยง25: `exact h`
#. ยง26: `h`
#: Game.Levels.EquationalReasoning.L02_exact
msgid "In this level, we have ยง0, ยง1, and the ยง2.\n"
"\n"
"# Objects\n"
"Objects will always be variables (letter symbols) we are working with. What these variables denote is specified after the ยง3, what is after the ยง4 is called the type of the object.\n"
"\n"
"Here, ยง5 denotes a number but we don't know which number it is. The ยง6 in ยง7 means that ยง8 is a natural number (positive numbers like ยง9,ยง10,ยง11, and so on...).\n"
"\n"
"# Assumptions\n"
"As for the assumptions, we have ยง12 which means that ยง13 is an object of type ยง14. This essentially means that ยง15 is an object asserting that the proposition (or statement) ยง16 is true. In other words, we know that ยง17 and ยง18 is a proof of that.\n"
"\n"
"# Goal\n"
"Our goal is to prove that ยง19.\n"
"We must use our assumptions.\n"
"We have that ยง20, i.e. ยง21 is a proof that ยง22.\n"
"\n"
"ยง23 is a proof of our goal, we should let ยง24 know that we have a proof of the goal. Using ยง25 accomplishes this because ยง26 is EXACTLY the goal."
msgstr ""

#. ยง0: `CsameA`
#. ยง1: `CsameA : C โ A`
#. ยง2: `not_iff_not`
#: Game.Levels.KnightsAndKnaves2.L07_orIff
msgid "\n"
"Rewrite ยง0 to ยง1 using ยง2\n"
""
msgstr ""

#. ยง0: `ยฌ(P or Q)`
#. ยง1: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{ยฌ(P or Q)} \\
#. \\hline
#. T & T & F \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & F \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง2: `ยฌP and ยฌQ`
#. ยง3: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{ยฌP and ยฌQ} \\
#. \\hline
#. T & T & F \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & F \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#: Game.Doc.doc
#: Game.Doc.doc
msgid "Notice that ยง0,\n"
"ยง1\n"
"\n"
"has the same truth table as ยง2\n"
"ยง3\n"
"\n"
"Therefore, they are equivalent and can be interchanged."
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "\n"
"Conclude that ยง0's statement is true.\n"
""
msgstr ""

#: Game.Doc.doc
msgid "A said something that is false (i.e. a lie), so A is a knave"
msgstr ""

#. ยง0: ```
#. h : P or False
#. ```
#. ยง1: `P`
#. ยง2: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{P or Q} \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & T \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง3: `Q = False`
#. ยง4: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{P or Q} \\
#. \\hline
#. T & F & T \\
#. \\hline
#. F & F & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง5: `P or Q`
#. ยง6: `P`
#. ยง7: `Q = False`
#. ยง8: `P or False`
#. ยง9: `P`
#. ยง10: `(P or False) โ P`
#. ยง11: `P or False`
#. ยง12: `P`
#. ยง13: $
#. \\begin{array}{|c|c|}
#. \\hline
#. P & \\text{P or False} \\
#. \\hline
#. T & T \\
#. \\hline
#. F & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง14: ```
#. or_false (p : Prop)
#. : (p or False) = p
#. ```
#. ยง15: `h : P or False`
#. ยง16: `h : P`
#. ยง17: `or_false`
#: Game.Levels.Simp_World.L01_or_false
msgid "\n"
"After doing so, we get\n"
"ยง0\n"
"\n"
"We can simplify it to ยง1 (which is the goal), here's why.\n"
"\n"
"The intution behind every simplifiction introduced can be understood from looking at the truth table of the relevant proposition:\n"
"\n"
"\n"
"ยง2\n"
"\n"
"Notice that for ยง3,\n"
"ยง4\n"
"\n"
"ยง5 has the same truth value as ยง6 (for ยง7).\n"
"\n"
"In other words, ยง8 and ยง9 have the same truth value, i.e. ยง10. Whenever ยง11 occurs, we can replace it by ยง12 which is of a simpler form.\n"
"ยง13\n"
"\n"
"The theorem for this simplication\n"
"ยง14\n"
"\n"
"Rewrite at ยง15 obtaining ยง16, using the theorem ยง17.\n"
""
msgstr ""

#. ยง0: `B`
#. ยง1: `B`
#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "\n"
"ยง0 is a knight so whatever ยง1 said is true.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `have`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "\n"
"Let's start with proving that ยง0 is a knight. (use ยง1)\n"
""
msgstr ""

#. ยง0: `Xavier`
#. ยง1: `Gary`
#. ยง2: `Alice`
#. ยง3: `Gary`
#. ยง4: `Alice`
#. ยง5: `Alice`
#. ยง6: `Gary`
#. ยง7: `Gary`
#. ยง8: `Xavier`
#: Game.Levels.KnightsAndKnaves2.L04_
msgid "You have met a group of 3 islanders. Their names are ยง0, ยง1, and ยง2.\n"
"\n"
"ยง3 says: ยง4 is my type.\n"
"\n"
"ยง5 says: ยง6 never lies.\n"
"\n"
"ยง7 says: ยง8 never lies."
msgstr ""

#. ยง0: `ptoq hP : Q`
#: Game.Levels.Logic.L04_Implication
msgid "\n"
"ยง0, this is exactly whats needed to prove the goal.\n"
""
msgstr ""

#. ยง0: `False`
#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "\n"
"If an islander says 'I am a knave', we get a contradiction, i.e. ยง0.\n"
""
msgstr ""

#. ยง0: ```
#. thm : P โ Q
#. ```
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `thm`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: ```
#. thm : P โ Q
#. hP : P
#. ```
#. ยง7: `(thm hP) : Q`
#. ยง8: `P : Prop`
#. ยง9: `Q : Prop`
#. ยง10: `thm`
#. ยง11: `thm`
#. ยง12: `P`
#. ยง13: `P`
#. ยง14: `Q`
#. ยง15: `Q`
#. ยง16: `thm`
#: Game.Doc.doc
msgid "A summary of all the terminology presented throughout the game, in order of appearance.\n"
"\n"
"Theorems represent an implication say:\n"
"ยง0\n"
"\n"
"They work for ยง1,ยง2 of any type. What ยง3 means is the following, give me an object of type ยง4 and i will return an object of type ยง5.\n"
"\n"
"Therefore, theorems expect arguments given in a specific order after which the obtained expression is an object which has the conclusion as its type.\n"
"\n"
"For\n"
"ยง6\n"
"ยง7\n"
"\n"
"For the special case where ยง8, ยง9, the interpretation of ยง10 is what implication in logic means.\n"
"\n"
"What ยง11 means is the following, give me an object of type ยง12 which in this case is a proof of ยง13 and i will return an object of type ยง14 which in this case is a proof of ยง15.\n"
"\n"
"In other words, ยง16 means 'If P is true, then Q is true'."
msgstr ""

#. ยง0: `A`
#. ยง1: `2+2=5`
#. ยง2: `P or False`
#. ยง3: `P`
#. ยง4: `simp`
#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
msgid "ยง0 says 'I am a knave or 2+2=5'.\n"
"\n"
"ยง1 is false\n"
"\n"
"ยง2 is ยง3\n"
"\n"
"Use ยง4 to do these simplications for you."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
msgid "\n"
"This should look familiar.\n"
"\n"
"Don't repeat the proof!\n"
""
msgstr ""

#. ยง0: `by_contra h`
#. ยง1: `P`
#. ยง2: `h : ยฌP`
#. ยง3: `ยฌยฌP`
#. ยง4: `P`
#. ยง5: `P`
#. ยง6: `ยฌQ`
#. ยง7: `Q`
#. ยง8: `ยฌยฌQ`
#: Game.Doc.tactic_doc
msgid "ยง0 proves ยง1 by contradiction, introducing a hypothesis ยง2 and proving False, i.e. proving ยง3 which is equivalent to ยง4.\n"
"\n"
"If ยง5 is a negation ยง6, h : ยง7 will be introduced instead of ยง8."
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid "\n"
"Conclude that ยง0's statement is false.\n"
""
msgstr ""

#. ยง0: `h`
#. ยง1: `simp`
#. ยง2: `h`
#. ยง3: `hnQ`
#. ยง4: ```
#. simp [hnQ] at h
#. ```
#: Game.Levels.Simp_World.L01_or_false
msgid "You can also simplify ยง0 using the ยง1 tactic (which stands for 'simplification').\n"
"\n"
"We want to simplify ยง2 using ยง3, so\n"
"ยง4\n"
"will do.\n"
"\n"
"Try it."
msgstr ""

#. ยง0: `False`
#. ยง1: `False`
#. ยง2: `โ`
#. ยง3: $$
#. \\begin{array}{|c|c|c|}
#. \\hline
#. P & Q & P โ Q \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $$
#. ยง4: `P`
#. ยง5: `False`
#. ยง6: `False`
#. ยง7: $$
#. \\begin{array}{|c|c|c|}
#. \\hline
#. Q & False โ Q \\
#. \\hline
#. T & T \\
#. \\hline
#. F & T \\
#. \\hline
#. \\end{array}
#. $$
#. ยง8: `False โ Q`
#. ยง9: `Q`
#. ยง10: `Q`
#. ยง11: `False`
#. ยง12: `False`
#. ยง13: `False.elim (h : False) : Q`
#. ยง14: `False`
#. ยง15: `Q`
#: Game.Levels.Logic.L09_False
msgid "We proved ยง0, what does this mean? What can we conclude? What does ยง1 IMPLY?\n"
"\n"
"Let's check the ยง2 truth table:\n"
"ยง3\n"
"\n"
"Let's focus on part of the truth table where ยง4 is ยง5, because we want to see what ยง6 implies.\n"
"ยง7\n"
"\n"
"We have that the implication ยง8 is true regardless what ยง9 represents and regardless whether ยง10 is true or is false.\n"
"So ยง11 implies any proposition. This principle is known as: 'From ยง12, anything follows'.\n"
"\n"
"This principle is represented by ยง13 which takes a proof of ยง14, and proves any proposition ยง15."
msgstr ""

#. ยง0: `knight_or_knave`
#: Game.Levels.DSL_Knights_Knaves.L09_same
msgid "\n"
"Remember the ยง0 tactic.\n"
""
msgstr ""

#. ยง0: `hP : P`
#. ยง1: `hQ : Q`
#. ยง2: `hR : R`
#. ยง3: `P โง Q โง R`
#. ยง4: ```
#. exact โจhP,hQ,hRโฉ
#. ```
#. ยง5: `โจโฉ`
#. ยง6: `And.intro`
#: Game.Levels.KnightsAndKnaves2.L06_
msgid "\n"
"Given ยง0, ยง1, ยง2 and the goal ยง3, you can close this goal using:\n"
"ยง4\n"
"where ยง5 is typed as \\\\<\\\\> (this is to avoid nesting ยง6 inside another).\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#. ยง2: ```
#. notknight_said
#. (stA : A said P)
#. ( notKnight : ยฌisKnight A) : ยฌP
#. ```
#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "\n"
"Now that we know that ยง0 is not a knight, we know that what ยง1 said was a lie.\n"
"\n"
"Use\n"
"ยง2\n"
""
msgstr ""

#. ยง0: `P or Q`
#. ยง1: `P,Q`
#. ยง2: `left`
#. ยง3: `right`
#. ยง4: `P or Q`
#. ยง5: `True or Q`
#. ยง6: ```
#. eq_true (h : p)
#.   : p = True
#. ```
#: Game.Levels.Simp_World.L02_true_or
msgid "ยง0 to be true requires at least one of ยง1 to be true.\n"
"\n"
"You have already done this level using ยง2/ยง3 tactic.\n"
"\n"
"Here we introduce a simplification theorem to do it.\n"
"\n"
"But first, rewrite ยง4 to ยง5 using\n"
"ยง6"
msgstr ""

#. ยง0: `cases`
#. ยง1: ```
#. PorQ : P โจ Q
#. 
#. Goal
#. some-goal
#. ```
#. ยง2: `cases PorQ`
#. ยง3: `P`
#. ยง4: `some-goal`
#. ยง5: `Q`
#. ยง6: `some-goal`
#. ยง7: `some-goal`
#. ยง8: `some-goal`
#: Game.Doc.tactic_doc
msgid "# Proof by cases\n"
"The ยง0 tactic enables us to do a 'proof by cases'.\n"
"\n"
"Given,\n"
"ยง1\n"
"ยง2 will first assume ยง3 and ask you to prove ยง4 and then it will assume ยง5 and ask you to prove ยง6.\n"
"\n"
"So in both cases, ยง7 is true. Therefore we can conclude ยง8. This is called a proof by cases."
msgstr ""

#. ยง0: `C`
#. ยง1: `C`
#. ยง2: `have`
#. ยง3: `ยฌ (A.isKnight or B.isKnight)`
#. ยง4: `simp`
#. ยง5: `stC`
#. ยง6: `C said False`
#. ยง7: `C`
#. ยง8: `said_knave`
#. ยง9: `not_false : ยฌFalse`
#. ยง10: `C.isKnave`
#. ยง11: `right`
#. ยง12: `unfold`
#: Game.Levels.DSL_Knights_Knaves.L10_allofus
msgid "\n"
"Now, ยง0's statement is false, so conclude that ยง1 is a knave.\n"
"\n"
"You can do this in a number of ways:\n"
"- Use ยง2 to construct a proof that ยง3\n"
"- Use ยง4 on ยง5, to obtain ยง6. Conclude ยง7 is a knave using ยง8, ยง9.\n"
"\n"
"- etc...\n"
"\n"
"Once you have ยง10 then everyone is a knave (ยง11 side of the goal).\n"
"\n"
"You can ยง12 the goal if that facilitates your reasoning.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `A`
#. ยง6: `B`
#. ยง7: `B`
#. ยง8: `A`
#. ยง9: `C`
#: Game.Levels.DSL_Knights_Knaves.L09_same
msgid "We have three inhabitants, ยง0, ยง1, and ยง2.\n"
"\n"
"Two people are said to be of the same type if they are both knights or both knaves.\n"
"\n"
"ยง3 and ยง4 make the following statements:\n"
"\n"
"ยง5: ยง6 is a knave.\n"
"\n"
"ยง7: ยง8 and ยง9 are of the same type."
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"Now that we know ยง0 is a knave, conclude the negation of ยง1's statement.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `C`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `ยซ{exactlyoneKnave}ยป`
#. ยง7: `unfold exactlyOneIsKnave at ยซ{exactlyoneKnave}ยป`
#. ยง8: `simp`
#. ยง9: `knight_to_knave`
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "\n"
"Notice what we have at our disposal.\n"
"\n"
"We have ยง0 is a knave, ยง1 is a knight, and that there is exactly one knave. So ยง2 must be a knight.\n"
"\n"
"You can obtain ยง3 by using the fact that ยง4 is a knave, ยง5 is a knight and simplifying the expression ยง6.\n"
"\n"
"ยง7 first then use ยง8.\n"
"\n"
"If it doesn't get simplified enough, then change the hypothesis involved from ยง9 or vice versa\n"
""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_allofus
msgid "allKnights or allKnaves"
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "\n"
"Now that ยง0 is not a knight, conclude that not everyone is a knave.\n"
""
msgstr ""

#. ยง0: `ยฌ(P or Q)`
#. ยง1: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{ยฌ(P or Q)} \\
#. \\hline
#. T & T & F \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & F \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง2: `ยฌP and ยฌQ`
#. ยง3: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{ยฌP and ยฌQ} \\
#. \\hline
#. T & T & F \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & F \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง4: `ยฌ(P or Q)`
#. ยง5: `P or Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `P`
#. ยง9: `Q`
#. ยง10: ```
#. not_or : ยฌ(p or q) โ ยฌp and ยฌq
#. ```
#: Game.Levels.Simp_World.L03_not_or
msgid "Notice that ยง0,\n"
"ยง1\n"
"\n"
"has the same truth table as ยง2\n"
"ยง3\n"
"\n"
"Therefore, they are equivalent and can be interchanged.\n"
"\n"
"On a more intuitive level, we can understand ยง4 as meaning ยง5 is not true, i.e. it is not true that either ยง6 or ยง7 is true, i.e. ยง8 is false and ยง9 is false.\n"
"\n"
"The simplification theorem to use,\n"
"ยง10"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves
msgid "DSL Knights and Knaves"
msgstr ""

#. ยง0: `ยฌ(P and Q)`
#. ยง1: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{ยฌ(P and Q)} \\
#. \\hline
#. T & T & F \\
#. \\hline
#. T & F & T \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง2: `ยฌP or ยฌQ`
#. ยง3: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & Q & \\text{ยฌP or ยฌQ} \\
#. \\hline
#. T & T & F \\
#. \\hline
#. T & F & T \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง4: `ยฌ(P and Q)`
#. ยง5: `P and Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: ```
#. not_and_or : ยฌ(p and q) โ ยฌp or ยฌq
#. ```
#: Game.Levels.Simp_World.L04_not_and_or
msgid "Notice that ยง0,\n"
"ยง1\n"
"\n"
"has the same truth table as ยง2\n"
"ยง3\n"
"\n"
"Therefore, they are equivalent and can be interchanged.\n"
"\n"
"On a more intuitive level, we can understand ยง4 as meaning ยง5 is not true, i.e. ยง6,ยง7 can't be true at the same (at least one of them has to be false)\n"
"\n"
"The simplification theorem to use,\n"
"ยง8"
msgstr ""

#. ยง0: `have h : P`
#. ยง1: `P`
#. ยง2: `h`
#: Game.Levels.Logic.L10_have
msgid "ยง0 changes the goal to proving ยง1 and adds the proof ยง2 after that goal is closed."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "allKnaves, exactlyOneIsKnave"
msgstr ""

#. ยง0: `A.isKnave`
#. ยง1: `ยฌA.isKnight`
#: Game.Levels.DSL_Knights_Knaves.L10_allofus
msgid "\n"
"Now we have that ยง0\n"
"Get ยง1\n"
""
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L06_prob33
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
msgid "\n"
"Assume ยง0 is a knight.\n"
""
msgstr ""

#. ยง0: `ยซ{BKnight}ยป : B.isKnight`
#. ยง1: `ยฌB.isKnave`
#. ยง2: `C`
#. ยง3: `C`
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
msgid "\n"
"We know that ยง0 which is ยง1 which means ยง2 told a lie which means ยง3 is a knave.\n"
""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "\n"
"Now close the goal\n"
""
msgstr ""

#. ยง0: `Robert`
#: Game.Levels.DSL_Knights_Knaves.L08_sametype
msgid "\n"
"ยง0 is saying 'I am a knave' which is a contradiction. Use the appropriate theorem\n"
""
msgstr ""

#. ยง0: `knave_said`
#: Game.Doc.doc
msgid "Similar to ยง0."
msgstr ""

#. ยง0: `ยฌIra.isKnight`
#. ยง1: `by_contra`
#: Game.Levels.DSL_Knights_Knaves.L08_sametype
msgid "\n"
"Assume by contradiction that ยง0 using the ยง1 tactic.\n"
""
msgstr ""

#. ยง0: `โจ`
#. ยง1: $
#. \\begin{array}{|c|c|c|}
#. \\hline
#. P & Q & \\text{P or Q} \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & T \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง2: `P or Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `or`
#. ยง6: `left`
#. ยง7: `right`
#. ยง8: `or`
#. ยง9: `P`
#. ยง10: `left`
#: Game.Levels.Logic.L03_Or
msgid "In this level, we introduce the ยง0 logical connective read as 'or'.\n"
"\n"
"Its truth table is as follows:\n"
"ยง1\n"
"\n"
"From this truth table, we conclude that to prove ยง2, we need either ยง3 being true or ยง4 being true (both being true would also mean it's true).\n"
"\n"
"You can tell Lean which side of ยง5 you want to prove by simply executing ยง6 or ยง7.\n"
"\n"
"In our case, we know the left side of ยง8 (ยง9) is true, so use ยง10."
msgstr ""

#. ยง0: `exact`
#. ยง1: `exact h`
#. ยง2: `Lean`
#. ยง3: `h`
#. ยง4: `h`
#. ยง5: `Lean`
#. ยง6: `assumption`
#: Game.Levels.EquationalReasoning.L02_exact
msgid "The ยง0 in ยง1 tells ยง2 that ยง3's type EXACTLY matches the goal. In other words, ยง4 is EXACTLY what we need to prove the goal. ยง5 verifies this and reports that there are no more goals to prove. We are done.\n"
"\n"
"The ยง6 tactic can also be used here which searches for an assumption that matches the goal, and closes the goal if it finds one.\n"
"\n"
"Try it before moving on to the next level."
msgstr ""

#. ยง0: `Zoey`
#. ยง1: `Mel`
#. ยง2: `Zoey`
#. ยง3: `Mel`
#. ยง4: `Zoey`
#. ยง5: `stZ`
#. ยง6: `stZn`
#. ยง7: `Zoey`
#. ยง8: `ยฌMel`
#. ยง9: `ยฌZoey`
#. ยง10: `Mel`
#. ยง11: `Zoey`
#. ยง12: `have`
#: Game.Levels.KnightsAndKnaves2.L01_Intro
msgid "A very special island is inhabited only by knights and knaves. Knights always tell the truth, and knaves always lie.\n"
"\n"
"You meet two inhabitants: ยง0 and ยง1.\n"
"\n"
"ยง2 tells you that Mel is a knave.\n"
"\n"
"ยง3 says, โNeither ยง4 nor I are knaves.โ\n"
"\n"
"Can you determine who is a knight and who is a knave?\n"
"\n"
"Note that ยง5 and ยง6 are saying the same thing, saying that ยง7 and ยง8 have the same truth value, i.e. both are true or both are false is equivalent to saying that ยง9 and ยง10 have the same truth value.\n"
"\n"
"First change the goal to ยง11 using the ยง12 tactic."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "ยง0: All of us are knaves.\n"
"\n"
"ยง1: Exactly one of us is a knave."
msgstr ""

#. ยง0: `simp`
#. ยง1: `hC : C`
#. ยง2: `stB`
#. ยง3: `stB`
#. ยง4: `iff_not_comm`
#. ยง5: `stB : A โ ยฌB`
#. ยง6: `ยฌB`
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "\n"
"- Use ยง0 and ยง1 to simplify ยง2\n"
"- Rewrite ยง3 using ยง4 obtaining ยง5\n"
"- Prove ยง6 using and conclude the goal\n"
""
msgstr ""

#. ยง0: `โจ`
#. ยง1: $
#. \\begin{array}{|c c|c|}
#. \\hline
#. P & Q & \\text{P or Q} \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & T \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `P โจ Q`
#. ยง5: `P or Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `P or Q`
#. ยง9: `left`
#. ยง10: `right`
#: Game.Doc.doc
msgid "ยง0\n"
"\n"
"# Truth Table\n"
"ยง1\n"
"\n"
"From the truth table, we can see that if one of ยง2,ยง3 is true then ยง4 is true.\n"
"\n"
"Therefore, if we have ยง5 as our goal, it is enough to prove ยง6 or to prove ยง7.\n"
"\n"
"Having ยง8 as the goal, you can tell Lean that you want to prove the left side by simply typing ยง9 or the right side by simply typing ยง10."
msgstr ""

#. ยง0: `A`
#. ยง1: `unfold allKnaves at ยซ{allKnave}ยป`
#. ยง2: `A.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "\n"
"This would mean that ยง0 is also a knave, which is absurd.\n"
"\n"
"You can ยง1 and extract ยง2 from that.\n"
""
msgstr ""

#. ยง0: `B`
#: Game.Levels.DSL_Knights_Knaves.L10_allofus
msgid "\n"
"First, take cases for ยง0.\n"
""
msgstr ""

#. ยง0: `B`
#. ยง1: `C`
#. ยง2: `C`
#. ยง3: `B`
#. ยง4: `C`
#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "\n"
"Now that ยง0 is a knave, ยง1's statement is true then ยง2 is a knight.\n"
"\n"
"So you would have ยง3 is a knave and ยง4 is a knight closing the goal.\n"
""
msgstr ""

#. ยง0: `A`
#. ยง1: ```
#. isKnave A : Prop
#. ```
#. ยง2: ```
#. A.isKnave : Prop
#. ```
#. ยง3: `A`
#: Game.Doc.doc
msgid "For an Islander ยง0,\n"
"ยง1\n"
"or\n"
"ยง2\n"
"is the proposition that ยง3 is a knave."
msgstr ""

#. ยง0: `exact hP`
#: Game.Levels.Logic.L01_Intro
msgid "Type ยง0!"
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#. ยง2: ```
#. A : Prop
#. ```
#. ยง3: `A`
#. ยง4: `A`
#. ยง5: `A`
#. ยง6: `A`
#. ยง7: `A`
#. ยง8: `A`
#. ยง9: `ยฌA`
#. ยง10: `A`
#. ยง11: ```
#. A or ยฌA
#. ```
#. ยง12: `A`
#. ยง13: `P`
#. ยง14: `A`
#. ยง15: `P`
#. ยง16: ```
#. A โ P
#. ```
#. ยง17: `P`
#. ยง18: `A`
#. ยง19: ```
#. P โ A
#. ```
#. ยง20: ```
#. A โ P
#. ```
#. ยง21: `A`
#. ยง22: `P`
#. ยง23: ```
#. ยฌA โ ยฌP
#. ```
#. ยง24: `P`
#. ยง25: `A`
#. ยง26: ```
#. ยฌP โ ยฌA
#. ```
#. ยง27: ```
#. ยฌA โ ยฌP
#. ```
#. ยง28: ```
#. A โง ยฌA
#. ```
#. ยง29: `A`
#. ยง30: `A`
#: Game.Levels.KnightsAndKnaves2
msgid "Say we have an islander ยง0 who could be a knight or a knave.\n"
"\n"
"ยง1 is represented as\n"
"ยง2\n"
"where having the proposition ยง3 being true means the islander ยง4 is a knight and having the proposition ยง5 being false means the islander ยง6 is a knave.\n"
"\n"
"Now, we intrepret having a proof of ยง7 as ยง8 being a knight, and having a proof of ยง9 as ยง10 being a knave.\n"
"\n"
"From this, every islander being a knight or a knave is represented as follows:\n"
"ยง11\n"
"\n"
"Knights always tell the truth, so if ยง12 makes some statement ยง13 we have that ยง14 being a knight implies that the statement ยง15 is true\n"
"ยง16\n"
"Moreover, the statement ยง17 being true means that ยง18 is telling the truth, i.e. is a knight\n"
"ยง19\n"
"which can be combined as\n"
"ยง20\n"
"\n"
"Similarly for ยง21 being a knave which implies that the statement ยง22 is false\n"
"ยง23\n"
"Moreover, the statement ยง24 being false means that ยง25 is lying, i.e. is a knave\n"
"ยง26\n"
"which are combined as\n"
"ยง27\n"
"\n"
"No islander can be a knight and a knave at the same time because\n"
"ยง28\n"
"is false.\n"
"\n"
"This representation captures the rules of the knights and knaves puzzle which are:\n"
"- Every islander is either a knight or a knave\n"
"- No islander is both a knight and a knave at the same time\n"
"- Knights always tell the truth, knaves always lie.\n"
"\n"
"Note that you could also take a more explicit truth table approach, where you list all the cases in a truth table and eliminate the cases which contradict the rules of the game (e.g ยง29 being a knight but ยง30's statement being false). If you are left with one possibility then the puzzle has a unique solution, otherwise it has multiple solutions.\n"
"This can be done in [prolog](https://www.youtube.com/watch?v=oEAa2pQKqQU) and [other provers](https://summerofgodel.blogspot.com/2019/04/part-6-propositional-logic-approach-to.html)"
msgstr ""

#. ยง0: `isKnave A`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"Assume ยง0\n"
""
msgstr ""

#. ยง0: ```
#. dsl_iamknave
#. (hAKn : A said A.isKnave)
#. : False
#. ```
#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "We have proven the following theorem:\n"
"ยง0\n"
"which you can use in future levels.\n"
"\n"
"You will need it in the next level."
msgstr ""

#. ยง0: `stA`
#. ยง1: `stG`
#. ยง2: `Gary`
#: Game.Levels.KnightsAndKnaves2.L04_
msgid "\n"
"Use ยง0 and ยง1 to prove ยง2\n"
""
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: `Knight`
#. ยง1: `Knaves`
#. ยง2: ```
#. Objects
#. A : Inhabitant
#. B : Inhabitant
#. C : Inhabitant
#. Knight : Finset Inhabitant
#. Knave : Finset Inhabitant
#. ```
#. ยง3: `Knight โฉ Knave = โ`
#. ยง4: `A โ Knight โจ A โ Knave`
#. ยง5: `A : Inhabitant`
#. ยง6: ```
#. Assumptions:
#. h : Knight โฉ Knave = โ
#. Or : A โ Knight โจ A โ Knave
#. ```
#. ยง7: ```
#. Objects
#. A : Inhabitant
#. B : Inhabitant
#. C : Inhabitant
#. Knight : Finset Inhabitant
#. Knave : Finset Inhabitant
#. 
#. Assumptions
#. h : Knight โฉ Knave = โ
#. Or : A โ Knight โจ A โ Knave
#. ```
#. ยง8: `A`
#. ยง9: `A`
#. ยง10: `A`
#. ยง11: `A`
#. ยง12: `A`
#. ยง13: ```
#. A โ Knight โ statement-of-A
#. statement-of-A โ A โ Knight
#. ```
#. ยง14: `statement-of-A : Prop`
#. ยง15: `A`
#. ยง16: ```
#. stA : A โ Knight โ statement-of-A
#. ```
#. ยง17: ```
#. A says B is a knave
#. ```
#. ยง18: ```
#. A โ Knight โ B โ Knave
#. B โ Knave โ A โ Knight
#. ```
#. ยง19: `โ`
#. ยง20: ```
#. stA : A โ Knight โ B โ Knave
#. ```
#. ยง21: `A`
#. ยง22: `A`
#. ยง23: `A`
#. ยง24: `A`
#. ยง25: `A`
#. ยง26: ```
#. A โ Knave โ ยฌstatement-of-A
#. ยฌstatement-of-A โ A โ Knave
#. ```
#. ยง27: `statement-of-A : Prop`
#. ยง28: `A`
#. ยง29: ```
#. stAn : A โ Knave โ ยฌstatement-of-A
#. ```
#. ยง30: ```
#. A says B is a knave
#. ```
#. ยง31: ```
#. A โ Knave โ ยฌ(B โ Knave)
#. ยฌ(B โ Knave) โ A โ Knave
#. ```
#. ยง32: `โ`
#. ยง33: ```
#. stAn : A โ Knave โ ยฌ(B โ Knave)
#. ```
#: Game.Doc.doc
msgid "## Objects\n"
"\n"
"The objects involved are:\n"
"- of type inhabitant indicated by a capital letter\n"
"- the two finite sets ยง0, ยง1.\n"
"\n"
"As a proof state:\n"
"ยง2\n"
"There will be at most three inhabitants in the puzzles for simplicity, but you can ofcourse have more.\n"
"\n"
"## Assumptions\n"
"Knights tell the true and knaves lie. So no one can be both at the same time, i.e. ยง3\n"
"\n"
"Moreover, every inhabitant is either a knight or a knave, i.e. ยง4 for any ยง5.\n"
"\n"
"As a proof state:\n"
"ยง6\n"
"\n"
"## Summary\n"
"Putting every together:\n"
"ยง7\n"
"\n"
"## Translating statements to formal notation\n"
"Given an inhabitant ยง8,\n"
"\n"
"The translation we use is based on the following:\n"
"- If ยง9 is a knight, then ยง10's statement is true.\n"
"- If ยง11's statement is true, then ยง12 is telling the truth, i.e. is a knight.\n"
"\n"
"Formally:\n"
"ยง13\n"
"where ยง14 represents ยง15's statement.\n"
"\n"
"Combining them we get,\n"
"ยง16\n"
"\n"
"### Quick Example\n"
"If,\n"
"ยง17\n"
"\n"
"then,\n"
"ยง18\n"
"\n"
"Combining them using ยง19:\n"
"ยง20\n"
"\n"
"### Equivalent translations, using knaves\n"
"Given inhabitant ยง21,\n"
"\n"
"The translation we use is based on the following:\n"
"- If ยง22 is a knave, then ยง23's statement is false, i.e. its negation is true.\n"
"- If ยง24's statement is false, then ยง25 is lying, i.e. is a knave.\n"
"\n"
"Formally:\n"
"ยง26\n"
"where ยง27 represents ยง28's statement.\n"
"\n"
"Combining them we get,\n"
"ยง29\n"
"\n"
"### Quick Example\n"
"If,\n"
"ยง30\n"
"\n"
"then,\n"
"ยง31\n"
"\n"
"Combining them using ยง32:\n"
"ยง33"
msgstr ""

#. ยง0: `Objects`
#. ยง1: `Prop`
#. ยง2: `x=2`
#. ยง3: `y=6`
#. ยง4: `h : P`
#. ยง5: `P : Prop`
#. ยง6: `h`
#. ยง7: `P`
#. ยง8: `x=2`
#. ยง9: `P`
#. ยง10: ```
#. Objects
#. P : Prop
#. Assumptions
#. h : P
#. ```
#. ยง11: ```
#. h : `x=2`
#. h' : `y=6`
#. ```
#. ยง12: `P`
#. ยง13: `x=2`
#. ยง14: `Q`
#. ยง15: `y=6`
#. ยง16: `P โง Q`
#. ยง17: `x=2 and y=6`
#. ยง18: `P`
#. ยง19: `Q`
#. ยง20: `P โง Q`
#. ยง21: `x : โ`
#. ยง22: `y : โ`
#. ยง23: `P,Q`
#: Game.Levels.Logic
msgid "In this world, we will be dealing with ยง0 of type ยง1, i.e. propositions. You can think of a proposition as a statement that is either true or false (obviously, it can't be both at the same time). You have seen propositions before like ยง2, ยง3 etc..\n"
"\n"
"When you have ยง4 where ยง5, then we say ยง6 is a proof of the statement ยง7(imagine ยง8 instead of ยง9 if you wish).\n"
"\n"
"In a proof state, this would look like the following:\n"
"ยง10\n"
"\n"
"Moreover, we will discuss constructing new propositions from old ones.\n"
"\n"
"Here's an example in natural language, given the two propositions 'The sun is shining', 'It is Monday', you can construct 'The sun is shining and it is monday'.\n"
"\n"
"Another example would be, having the following:\n"
"ยง11\n"
"where ยง12 is ยง13 and ยง14 is ยง15, we can construct a new proposition ยง16 which is read as ยง17. Here we know what ยง18,ยง19 stand for. But, the proposition ยง20 can still be constructed and reasoned about regardless. Think of reasoning about unknown numbers like ยง21,ยง22 etc...\n"
"\n"
"But here, the values ยง23 can take is either true or false."
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L13_prob27
#: Game.Levels.KnightsAndKnaves2.L06_
msgid "\n"
"Take cases for ยง0.\n"
""
msgstr ""

#. ยง0: `โ`
#: Game.Levels.Logic.L07_LogicalEquivalence
msgid "Logical Equivalence, ยง0"
msgstr ""

#. ยง0: `A`
#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "\n"
"ยง0 is knave and is not a knave.\n"
"contradiction.\n"
""
msgstr ""

#. ยง0: `Lean`
#. ยง1: `A`
#. ยง2: `A`
#. ยง3: ```
#. A.isKnight
#. ```
#. ยง4: `A`
#. ยง5: ```
#. A.isKnave
#. ```
#. ยง6: ```
#. isKnight_or_isKnave (A : Islander)
#. : A.isKnight โจ A.isKnave
#. ```
#. ยง7: ```
#. -- `knight_said`.
#. -- Whatever a knight says,
#. -- it is true.
#. -- A is a knight,
#. -- so whatever A said is true
#. knight_said
#. (stA : A said P)
#. (AKnight : A.isKnight) : P
#. ```
#. ยง8: ```
#. -- `said_knight`
#. -- If what is said is true,
#. -- then knight.
#. -- A said something true,
#. -- so A is a knight.
#. said_knight
#. (stA : A said P)
#. (hP : P) : A.isKnight
#. ```
#. ยง9: ```
#. -- `knave_said`
#. -- Whatever a knave says,
#. -- it is false.
#. -- A is a knave,
#. -- so whatever A said is false
#. knave_said
#. (stA : A said P)
#. (AKnave : A.isKnave) : ยฌP
#. ```
#. ยง10: ```
#. -- `said_knave`
#. -- If what is said is false,
#. -- then knave.
#. -- A said something that is false
#. -- (a lie),
#. -- so A is a knave
#. said_knave
#. (stA : A said P)
#. (hnP : ยฌP) : A.isKnave
#. ```
#. ยง11: ```
#. not_isKnight_and_isKnave
#. (A : Islander)
#.   : ยฌ (A.isKnight โง A.isKnave)
#. ```
#: Game.Levels.DSL_Knights_Knaves
msgid "We will introduce the knights and knaves puzzle here explaining rules of the game and the corresponding ยง0 representation.\n"
"\n"
"The setting is an island.\n"
"Every islander will make a statement. There are two types of islanders, 'knights' and 'knaves'.\n"
"\n"
"For a given islander ยง1,\n"
"- The proposition that ยง2 is a knight:\n"
"ยง3\n"
"- The proposition that ยง4 is a knave:\n"
"ยง5\n"
"\n"
"Every islander is either a knight or a knave:\n"
"ยง6\n"
"\n"
"Knights always tell the truth, and knaves always lie.\n"
"\n"
"\n"
"ยง7\n"
"\n"
"\n"
"ยง8\n"
"\n"
"\n"
"ยง9\n"
"\n"
"ยง10\n"
"\n"
"Since knights always tell the truth and knaves always lie, no islander can be both a knight and a knave.\n"
"ยง11\n"
"\n"
"The objective is to conclude who is a knight and who is a knave, based on the statements of several islanders. This will be done using logical reasoning."
msgstr ""

#. ยง0: `knight_to_knave`
#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid "\n"
"Transform the goal from ยง0.\n"
""
msgstr ""

#. ยง0: `ยซ{hA}ยป`
#. ยง1: `ยซ{hB}ยป`
#. ยง2: `h`
#. ยง3: `constructor`
#. ยง4: `A`
#. ยง5: `B โง C`
#. ยง6: `โจโฉ`
#. ยง7: `And.intro`
#. ยง8: `have`
#. ยง9: `B โง C`
#. ยง10: `And.intro`
#. ยง11: `h : B`
#. ยง12: `stB`
#: Game.Levels.KnightsAndKnaves2.L05_iff
msgid "\n"
"Prove the goal using ยง0, ยง1 ,ยง2.\n"
"\n"
"You can do this in a number of ways:\n"
"\n"
"- Use ยง3 tactic to split the goal in two, the first being ยง4 and the second being ยง5\n"
"- Use ยง6 notation\n"
"- Use ยง7\n"
"- Use ยง8 to first construct a proof of ยง9 then use ยง10\n"
"- etc...\n"
"\n"
"The proof of the second case for ยง11 would require using ยง12.\n"
""
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "The previous two levels showed how to use an implication and how to prove an implication."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P โ Q`
#. ยง4: `P โ Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: ```
#. iff_of_false (ha : ยฌa) (hb : ยฌb)
#.   : a โ b
#. ```
#: Game.Levels.Simp_World.L06_iff_of_false
msgid "ยง0 means that ยง1,ยง2 have the same truth value.\n"
"\n"
"If both of them are true, we can conclude ยง3.\n"
"\n"
"If both of them are false, we can conclude ยง4 as well.\n"
"\n"
"Here, we have that ยง5,ยง6 are both false.\n"
"\n"
"The relevant theorem,\n"
"ยง7"
msgstr ""

#. ยง0: `A`
#. ยง1: `ยซ{AKnave}ยป.left : A.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "\n"
"Now you have that ยง0 is a knave, which is a contradiction\n"
"\n"
"Remeber that ยง1.\n"
""
msgstr ""

#. ยง0: `intro`
#. ยง1: `P โ Q`
#. ยง2: ```
#. Goal:
#. P โ Q
#. ```
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P`
#. ยง8: `intro name`
#: Game.Doc.tactic_doc
msgid "ยง0 tactic is used to deal with goals of the form ยง1.\n"
"\n"
"Having the following:\n"
"ยง2\n"
"We want to prove that 'If ยง3 is true, then ยง4 is true'.\n"
"\n"
"To do this, we first need to assume ยง5 then prove ยง6. Assuming ยง7 is done using ยง8 for any 'name'."
msgstr ""

#. ยง0: `Zoey`
#. ยง1: `stZ`
#. ยง2: `constructor`
#. ยง3: `โจโฉ`
#. ยง4: `And.intro`
#: Game.Levels.KnightsAndKnaves2.L01_Intro
msgid "\n"
"Prove the second goal using ยง0, ยง1\n"
"\n"
"Then close the goal (using ยง2, or ยง3 notation, or ยง4 etc..).\n"
""
msgstr ""

#. ยง0: `False`
#: Game.Doc.doc
msgid "A : I am a knave\n"
"\n"
"This implies a contradiction, ยง0"
msgstr ""

#. ยง0: `ยฌTrue`
#. ยง1: `stA`
#. ยง2: `False`
#. ยง3: `not_true`
#: Game.Levels.KnightsAndKnaves2.L08_imp
#: Game.Levels.KnightsAndKnaves2.L08_imp
msgid "\n"
"Rewrite ยง0 in ยง1 as ยง2 using ยง3\n"
""
msgstr ""

#. ยง0: `โ`
#. ยง1: `=`
#: Game.Levels.Simp_World.L05_not_not
msgid "\n"
"Remember that ยง0 means ยง1. \n"
""
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Simp_World
msgid "In the previous world, we introduced logical connectives and how to construct new propositions using them.\n"
"\n"
"In this world, we have these expressions and some assumptions about their building blocks and we use that information to simplify the expression.\n"
"\n"
"Simplifications will be done manually after which the ยง0 tactic would be introduced."
msgstr ""

#. ยง0: `B`
#: Game.Levels.DSL_Knights_Knaves.L11_prob32
msgid "\n"
"Knowing that ยง0 is a knight, conclude that there is exactly one knave.\n"
""
msgstr ""

#: Game.Levels.Logic.L08_Not
msgid "Not Connective, ยฌ"
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#. ยง2: `ยซ{st}ยป`
#. ยง3: `A.isKnave`
#. ยง4: `knight_to_knave`
#. ยง5: `ยซ{st}ยป`
#. ยง6: `B.isKnave`
#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "\n"
"ยง0 is not a knight means that ยง1 is a knave, so ยง2 could be simplified.\n"
"\n"
"Obtain ยง3 using ยง4, and simplify ยง5 obtaining ยง6.\n"
"\n"
"After that, close the goal\n"
""
msgstr ""

#. ยง0: `AiffC : A โ C`
#. ยง1: `iff_of_true (ha : a) (hb : b) : a โ b`
#. ยง2: `hA : A`
#. ยง3: `h : C`
#. ยง4: `iff_of_true`
#. ยง5: `P โ Q`
#. ยง6: `P`
#. ยง7: `Q`
#: Game.Levels.KnightsAndKnaves2.L05_iff
msgid "\n"
"Prove ยง0 using ยง1, ยง2, ยง3\n"
"\n"
"ยง4 says that we can conclude ยง5 is true when ยง6 is true, ยง7 is true (check the truth table).\n"
""
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌP`
#. ยง2: `ยฌP โ False`
#. ยง3: `ยฌยฌP`
#. ยง4: `ยฌยฌP`
#. ยง5: `P`
#. ยง6: $
#. \\begin{array}{|c | c|c|}
#. \\hline
#. P & ยฌP & \\text{ยฌยฌP}\\
#. \\hline
#. T & F & T \\
#. \\hline
#. F & T & F \\
#. \\hline
#. \\end{array}
#. $
#. ยง7: `ยฌยฌP`
#. ยง8: `P`
#. ยง9: ```
#. not_not : ยฌยฌa โ a
#. ```
#. ยง10: `by_contra`
#. ยง11: `by_contra h`
#. ยง12: `h : ยฌP`
#: Game.Levels.Simp_World.L05_not_not
msgid "In this level, you will learn 'proof by contradiction'.\n"
"\n"
"To prove ยง0, you would assume ยง1 and then prove false, i.e. you would be proving ยง2 which is ยง3.\n"
"\n"
"The truth table shows that ยง4 is equivalent to ยง5,\n"
"ยง6\n"
"\n"
"There are two ways to solve this level, and you should try both.\n"
"\n"
"The first way is using the simplification theorem (to simplify ยง7 to ยง8),\n"
"ยง9\n"
"\n"
"The second is using the ยง10 tactic where ยง11 would be assuming ยง12."
msgstr ""

#. ยง0: `ยฌisKnight B`
#. ยง1: `knave_to_knight`
#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "\n"
"Change the goal to ยง0\n"
"\n"
"Use the ยง1 tactic.\n"
""
msgstr ""

#. ยง0: `ยฌP`
#. ยง1: `ยฌQ`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: ```
#. not_iff_not : (ยฌa โ ยฌb) โ (a โ b)
#. ```
#: Game.Levels.Simp_World.L09_not_iff_not
msgid "If we know that ยง0,ยง1 have the same truth value then ยง2,ยง3 have the same truth value.\n"
"\n"
"The relevant theorem,\n"
"ยง4"
msgstr ""

#. ยง0: `False`
#. ยง1: `False.elim`
#. ยง2: `Q`
#. ยง3: `contradiction`
#. ยง4: `False`
#. ยง5: `contradiction`
#. ยง6: `False`
#. ยง7: `False`
#. ยง8: `False`
#. ยง9: `P`
#. ยง10: `ยฌP`
#. ยง11: `P โ False`
#. ยง12: `P`
#. ยง13: `ยฌP`
#. ยง14: `contradiction`
#. ยง15: `False`
#. ยง16: `contradiction`
#: Game.Levels.Logic.L09_False
msgid "Having proven ยง0, instead of having to use ยง1 to prove ยง2, you can use the the ยง3 tactic. If you were able to prove ยง4, then the ยง5 tactic will prove the goal regardless what the goal is because 'from ยง6, anything follows'.\n"
"\n"
"Proving ยง7 is what's usually called deriving a contradiction, and note that to prove ยง8 you would first need to have a proof ยง9, and a proof of ยง10, i.e. ยง11.\n"
"\n"
"Moreover, having a proof of ยง12 and a proof of ยง13 means you have contradictory theorems. If so, then ยง14 will close any goal without having to prove ยง15 first.\n"
"\n"
"Try the ยง16 tactic before moving on to the next level."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `B`
#. ยง3: `ยฌ(A.isKnight โ B.isKnight)`
#. ยง4: `B`
#. ยง5: `A.isKnight โ B.isKnight`
#. ยง6: `iff_of_true`
#: Game.Levels.DSL_Knights_Knaves.L07_difftype
msgid "\n"
"So ยง0,ยง1 are the same type, but ยง2 being a knight also tells us that they are not. contradiction\n"
"\n"
"Conclude ยง3 from ยง4'statement then prove that ยง5 using ยง6\n"
""
msgstr ""

#. ยง0: ```
#. PsameQ : P โ Q
#. hQ : Q
#. 
#. Goal
#. P
#. ```
#. ยง1: `exact PsameQ.mpr hQ`
#. ยง2: `rw [PsameQ]`
#. ยง3: ```
#. PsameQ : P โ Q
#. hQ : Q
#. 
#. Goal
#. Q
#. ```
#. ยง4: `hQ`
#: Game.Levels.Logic.L07_LogicalEquivalence
msgid "This level could have been\n"
"ยง0\n"
"ยง1 would close the goal.\n"
"\n"
"ยง2 would transform the proof state into\n"
"ยง3\n"
"which you can then close using ยง4."
msgstr ""

#. ยง0: `Robert`
#. ยง1: `Ira`
#. ยง2: `Ira`
#. ยง3: `Robert`
#. ยง4: `Ira`
#. ยง5: ```
#. ( (Ira and Robert) or (ยฌIra and ยฌRobert) )
#. ```
#. ยง6: `Ira โ Robert`
#. ยง7: `stR`
#. ยง8: `Ira โ Robert`
#. ยง9: ```
#. iff_iff_and_or_not_and_not.symm
#. : (a and b or ยฌa and ยฌb ) โ (a โ b)
#. ```
#. ยง10: `stI`
#. ยง11: `Robert`
#. ยง12: `Ira`
#: Game.Levels.KnightsAndKnaves2.L03_iff_iff
msgid "ยง0 says: ยง1 is my type.\n"
"\n"
"ยง2 says: ยง3 is truthful.\n"
"\n"
"'ยง4 is my type' is translated as\n"
"ยง5\n"
"Notice that this is equivalent to ยง6\n"
"\n"
"Replace this expression in ยง7 by ยง8 using\n"
"ยง9\n"
"\n"
"then use ยง10 to prove ยง11 and obtain ยง12."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P โ Q`
#. ยง4: $
#. \\begin{array}{|c c|c|}
#. \\hline
#. P & Q & P โ Q \\
#. \\hline
#. T & T & T \\
#. \\hline
#. T & F & F \\
#. \\hline
#. F & T & T \\
#. \\hline
#. F & F & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง5: `P โ Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `P`
#. ยง9: `Q`
#. ยง10: `P`
#. ยง11: `Q`
#. ยง12: `P`
#. ยง13: `Q`
#. ยง14: `P โ Q`
#. ยง15: `P`
#. ยง16: `Q`
#: Game.Doc.doc
msgid "Logical implication ยง0 is made up of two components:\n"
"- The premise, which in this case is ยง1\n"
"- The conclusion, which in this case is ยง2\n"
"\n"
"ยง3 is read as 'If P is true, then Q is true.\n"
"\n"
"# Truth table\n"
"ยง4\n"
"\n"
"A statement ยง5 is false when ยง6 is true and ยง7 false, it's true otherwise.\n"
"\n"
"# Implication as a function\n"
"What logical implication does is that it takes evidence or proof for ยง8 and transforms it returning a proof of ยง9.\n"
"The truth of ยง10 IMPLIES the truth of ยง11. A proof of ยง12 IMPLIES a proof of ยง13.\n"
"\n"
"In other words, it acts like a function. If you give ยง14 a proof of ยง15, you get a proof of ยง16."
msgstr ""

#. ยง0: `And.intro`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P โง Q`
#. ยง4: `P Q : Prop`
#. ยง5: ```
#. hP : P
#. hQ : Q
#. ```
#. ยง6: `And.intro hP hQ : P โง Q`
#. ยง7: `\\<hP,hQ\\>`
#. ยง8: ```
#. โจhP,hQโฉ : P โง Q
#. ```
#. ยง9: ```
#. And.intro hP hQ : P โง Q
#. ```
#: Game.Doc.doc
msgid "The theorem ยง0 takes a proof of ยง1, a proof of ยง2, and gives a proof of ยง3 where ยง4.\n"
"\n"
"Given,\n"
"ยง5\n"
"we have ยง6\n"
"\n"
"## Alternative Notation\n"
"Typed as ยง7,\n"
"ยง8\n"
"instead of\n"
"ยง9"
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "\n"
"ยง0's statement is true, so ยง1 is a knight.\n"
""
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `(P โ Q) โง (Q โ P)`
#. ยง2: $
#. \\begin{array}{|c c|c c|c|}
#. \\hline
#. P & Q & P โ Q & Q โ P & P โ Q โง Q โ P\\
#. \\hline
#. T & T & T & T & T \\
#. \\hline
#. T & F & F & T & F \\
#. \\hline
#. F & T & T & F & F \\
#. \\hline
#. F & F & T & T & T \\
#. \\hline
#. \\end{array}
#. $
#. ยง3: `P โ Q`
#. ยง4: `P,Q`
#. ยง5: `P,Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `P`
#. ยง9: `Q`
#. ยง10: `P`
#. ยง11: `Q`
#. ยง12: `PsameQ : P โ Q`
#. ยง13: `P`
#. ยง14: `Q`
#. ยง15: `hP : P`
#. ยง16: `P`
#. ยง17: `Q`
#. ยง18: `h : P โ Q`
#. ยง19: `h.mp : P โ Q`
#. ยง20: `hP : P`
#. ยง21: `Q`
#. ยง22: `h.mpr : Q โ P`
#. ยง23: `PsameQ`
#. ยง24: `P`
#. ยง25: `Q`
#. ยง26: `โ`
#. ยง27: `=`
#. ยง28: `rw`
#. ยง29: `hP : P`
#. ยง30: `hP : Q`
#: Game.Levels.Logic.L07_LogicalEquivalence
msgid "ยง0  is defined as ยง1.\n"
"\n"
"Its truth table looks like the folowing:\n"
"ยง2\n"
"\n"
"So, ยง3 is true when ยง4 are true or ยง5 are false, i.e. when ยง6 and ยง7 have the same truth value. Therefore, ยง8 and ยง9 are equivalent from a truth value perspective regardless what the statement of ยง10 and of ยง11 is.\n"
"\n"
"In this level we have ยง12 (ยง13, ยง14 have the same truth value) and ยง15 (ยง16 is true) and so ยง17 is true as well.\n"
"\n"
"There are a number of ways to prove this level:\n"
"- You can extract the forward direction of ยง18 which is ยง19 and use ยง20 to prove ยง21 (ยง22 is the backward direction).\n"
"- Since ยง23 means that ยง24 and ยง25 have the same truth value, you can pretend ยง26 is instead ยง27 and use ยง28 at ยง29 to obtain ยง30 and then close the goal."
msgstr ""

#. ยง0: `knight_to_knave`
#: Game.Levels.DSL_Knights_Knaves.L12_31
msgid "\n"
"Convert from ยง0.\n"
""
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "Notice that 'level completed! ๐' on the bottom. We say that the goal is closed/proven."
msgstr ""
