msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Thu Aug 29 12:34:59 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Doc.doc
msgid "Unfoldable:\n"
"unfold Not at ...\n"
"¬¨P is P ‚Üí False"
msgstr ""

#: Game.Doc.doc
msgid "`rfl` is short for reflexivity, which is the property that for any number `a`, `a = a`.\n"
"\n"
"The `rfl` tactic will close all goals of the form `X=X`, regardless of what `X` is.\n"
"\n"
"In fact, `rfl` is not a tactic but syntactic sugar for `exact rfl`. `rfl` is of type `a = a` for any `a`.\n"
"## examples\n"
"```\n"
"x - 7 = x - 7\n"
"```\n"
"`rfl` will close this goal."
msgstr ""

#: Game.Doc.doc
msgid "testing stuff, does importing work?!?!?!?!"
msgstr ""

#: Game.Doc.doc
msgid "[[mathlib_doc]]"
msgstr ""

#: Game.Doc.doc
msgid "## Overview\n"
"Having h : P and P as your goal, exact h will close the goal. exact h asserts that h is exactly whats needed to prove the goal which makes sense because h is a proof of P.(It doesn't matter what P is)"
msgstr ""

#: Game.Doc.doc
msgid "Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `‚Åª¬π` `^` and `%`\n"
"over numerical types such as `‚Ñï`, `‚Ñ§`, `‚Ñö`, `‚Ñù`, `‚ÑÇ`."
msgstr ""

#: Game.Doc.doc
msgid "# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects.\n"
"The following truth table illustrates this for the previously discussed `‚àß` connective.\n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & F \\\\\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that `P ‚àß Q` is true when both `P` is true and `Q` is true, being false otherwise."
msgstr ""

#: Game.Levels.EquationalReasoning.L01_Intro
msgid "A Number Equals Itself"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_Intro
msgid "In this exercise, we will prove `2 = 2`\n"
"\n"
"`rfl` will do the job.\n"
"\n"
"`rfl` is short for reflexivity, which is the property that for any number `a`, `a = a`\n"
"\n"
"`rfl` also applies more generally, `rfl` will close any goal of the form `A=B` where `A`,`B` are identical.\n"
" \n"
"Moreover, `rfl` can unfold things into their definitions and check if they are equal. In other words, `rfl` can prove the equality of two things that are 'equal by definition'."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_Introduction
msgid "Introd"
msgstr ""

#: Game.Levels.EquationalReasoning.L02_Introduction
msgid "In this level, we have `Objects`, `Assumptions`, and the `Goal`.\n"
"\n"
"# Objects\n"
"For this world, objects will always be unknown numbers, or variables we are working with. Anything after the `:` denotes the type of whats before the `:`. \n"
"\n"
"Here, `x`  denotes a number but we don't know which number it is. The `: ‚Ñï` in `x : ‚Ñï` means that `x` is a variable of type natural number(positive numbers like `1`,`2`,`3`, and so on...). \n"
"\n"
"# Assumptions\n"
"As for the assumptions, we have `h: x=2` which means that `h` is an object of type `x=2`. This essentially means that `h` is an object asserting that the statement `x=2` is true or in other words, is a proof of `x=2`.\n"
"\n"
"# Goal\n"
"Our goal is to prove that `x = 2`. To do this, we should let Lean know that we have a term that 'exactly' matches that goal. Notice that we do, that term is `h`!\n"
"\n"
"Using `exact h` will do."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_Introduction
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoning.L02_Introduction
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoning.L03_lvl2
msgid "Substituting Variables By Their Values"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_lvl2
msgid "We will learn how to substitute a variable with its value, for example how to substitiute `x` by `2` if we know that `x=2`.\n"
"\n"
"This can be done using the tactic `rw` (short for rewrite).\n"
"\n"
"`rw` takes a term of type `A=B` and replaces all the `A`s in the goal with `B`s.\n"
"So `rw [h]` where `h : x=3` will replace all the `x`s of the goal with `3`.\n"
"\n"
"By default, rw uses an equation in the forward direction, matching the left-hand side of the equation with an occurrence of that in the goal, and replaces it with the right-hand side. \n"
"\n"
"# mention reverse direction??\n"
"The notation ‚Üêt can be used to instruct the tactic to use the equality t in the reverse direction."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_lvl2
msgid "Do `rw [¬´{h}¬ª]` or `rw [¬´{g}¬ª]` and observe what happens."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_lvl2
msgid "You should use `¬´{h}¬ª` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_lvl2
msgid "`rw [h]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_lvl2
msgid "You should use `¬´{g}¬ª` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_lvl2
msgid "`rw [g]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_lvl2
msgid "Our goal is now `3 + 3 = 6` which Lean knows to be true because it's a direct consequence of the definition of the natural numbers. So, there's nothing left to do. Providing a bit more detail, this is what is called 'definitional equality', i.e two things are equal due to the way they are defined (these types of goals can be closed using `rfl`). But you didn't have to use `rfl` here. `rw` actually tries `rfl` after the substitution, because its a common pattern. Another version `rewrite` doesn't, but it is not made available in this game and is mentioned for your information.\n"
"\n"
"Notice we didn't use the fact `i: z=10` which is that `z=10`. This will not be the case for the majority of exercises, you will need to use all the assumptions you have (explicitly or implicity).\n"
"\n"
"Another solution:\n"
"```\n"
"rw [h,g]\n"
"```\n"
"instead of \n"
"```\n"
"rw [h]\n"
"rw [g]\n"
"```"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_Normalize
msgid "Normalize Equations"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_Normalize
msgid "In this level, we will learn about normalizing equations using the `norm_num` tactic.\n"
"\n"
"`norm_num` is short for normalize numerical expressions like carrying out calculations and simplifying the expression.\n"
"\n"
"We will also learn how to apply a tactic to an assumption instead of the goal.\n"
"\n"
"We want to use `norm_num` on `h`, so simply write `norm_num at h`."
msgstr ""

#: Game.Levels.EquationalReasoning.L04_Normalize
msgid "This should look familiar to a previous exercise. Now `h` looks exactly like the goal. Let Lean know!!"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_Normalize
msgid "Remember the `exact` tactic, try `exact h`."
msgstr ""

#: Game.Levels.EquationalReasoning.L04_Normalize
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid "some title"
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid "Here, we introduce a multiplication cancellation tactic.\n"
"\n"
"To be able to achieve this, we need to rewrite `16` in `h` as `4 * 4` to be able to cancel the `4` on both sides of the equation , proving `y=4`. \n"
"\n"
"But first, we need to construct an object of type `16 = 4 * 4` (a proof) and add it to our assumptions.\n"
"\n"
"This is exactly what `have` does\n"
"\n"
"The syntax is \n"
"`have name-of-object : type := by ...` where `...` is the proof.\n"
"\n"
"The type here is `16 = 4 * 4`, you can pick anything as `name-of-object` like `helper`. For the proof, we need to carry out the calculation of `4 * 4` and as in the previous level, the tactic for that is `norm_num`. Typing that as the proof will work. (change this, dont mention norm_num, say like previous level, add show more help if user wrong).\n"
"\n"
"There is an alternative syntax for `have` which you can view in the right side pane. In any case, it will be introduced later on when its more convenient to use.\n"
"`have name := ........`"
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid "Try `have helper : 16=4*4 := by norm_num`"
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid "Now we want to replace the `16` in `h` with `4 * 4`. In other words, we want to do `rw [¬´{helper}¬ª]` and have it be applied on h."
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid "`rw [¬´{helper}¬ª] at h`"
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid "Now that we have `4` on both sides, we want to cancel this `4`\n"
"\n"
"This is possible using the theorem `mul_left_cancel‚ÇÄ` which has the following type :\n"
"```\n"
"mul_left_cancel‚ÇÄ(ha : a ‚â† 0) (h : a * b = a * c) : b = c\n"
"```\n"
"`mul_left_cancel‚ÇÄ` takes two arguments which is:\n"
"- a proof that what you want to cancel is not equal to zero (in this case `a`).\n"
"- the equation you are working with.\n"
"The theorem then cancels `a` from both sides giving a proof of `b=c`. This is exactly what we want to prove the goal.\n"
"\n"
"To write the subscript in `mul_left_cancel‚ÇÄ`, do backslash zero.\n"
"\n"
"You should have noticed that a proof of `4‚â†0` was not mentioned previously, and you will not have to prove this. You can use the term `four_ne_zero : 4‚â†0`."
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid "Notice that `mul_left_cancel‚ÇÄ four_ne_zero h` has type `y = 4`. So, `exact mul_left_cancel‚ÇÄ four_ne_zero h` will do it."
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid "[[mathlib_doc]]"
msgstr ""

#: Game.Levels.EquationalReasoning.L05_Lvl3
msgid "### **Logic Constants & Operators**\n"
"### **Equational Reasoning**\n"
"| $Name~~~$ | $Ascii~~~$ | $Unicode$ | $Unicode Cmd$ |\n"
"| --- | :---: | :---: | --- |\n"
"|     |       |       | `mul_left_cancel\\0`|\n"
"| True | `True` |  |  |\n"
"| False | `False` |  |  |\n"
"| Not | `Not` | ¬¨ | `\\n` `\\not` `\\neg` `\\lnot` |\n"
"| And | `/\\` | ‚àß | `\\and` `\\an` `\\wedge` |\n"
"| Or | `\\/` | ‚à® | `\\v` `\\or` `\\vee` |\n"
"| Implies | `->` | ‚Üí | `\\r` `\\imp` `\\->` `\\to` `\\r-` `\\rightarrow` |\n"
"| Iff | `<->` | ‚Üî | `\\iff` `\\lr-` `\\lr` `\\<->` `\\leftrightarrow` |\n"
"| For All | `foral` | ‚àÄ | `\\all` `\\forall` |\n"
"| Exists | `exists` | ‚àÉ | `\\ex` `\\exists` |\n"
"\n"
"### **Other Unicode**\n"
"| $Name$ | $Unicode~~~$ | $Unicode Cmd$ |\n"
"| --- | :---: | --- |\n"
"| Angle brackets | ‚ü® ‚ü© | `\\<` `\\>` `\\langle` `\\rangle` |\n"
"| Subscript Numbers | ‚ÇÅ ‚ÇÇ ‚ÇÉ ... | `\\1` `\\2` `\\3` ... |\n"
"| Left Arrow | ‚Üê | `\\l` `\\leftarrow` `\\gets` `\\<-` |\n"
"| Turnstyle | ‚ä¢ | `\\‚îÇ-` `\\entails` `\\vdash` `\\goal` |\n"
"\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"Unicode & Text \\\\\n"
"\\hline\n"
"\\text{mul\\_left\\_cancel‚ÇÄ} & `mul\\_left\\_cancel\\0` \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"mul_left_cancel‚ÇÄ written as mul_left_cancel\\0"
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid "Final"
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid "A similar problem to the previous one."
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid "First start by substitute the value of `y` in `h`"
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid "Now simplify `h`"
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid "We need to isolate `3*x` on the left side of the equation. You can do this using the `eq_add_of_add_neg_eq` theorem which is of type:\n"
"```\n"
"eq_add_of_add_neg_eq (h : a + -c = b) : a = b + c\n"
"```\n"
"We can use this theorem with the `have` tactic to construct a term of type `3 * x = 12 + 6`"
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid "Simplify `¬´{helper}¬ª`"
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid "Now, like the previous exercise, you need to construct a term of type `(18:‚Ñ§)=3*6`"
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid "Replace the `18` with 3*6"
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid "Cancel `3` from both sides and your done\n"
"\n"
"Remember `mul_left_cancel‚ÇÄ`"
msgstr ""

#: Game.Levels.EquationalReasoning.L06_Final
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "Equational Reasoning"
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "In this world, you will learn how to solve equations."
msgstr ""

#: Game.Levels.EquationalReasoningAutomation.L01_Trivial
msgid "trivial"
msgstr ""

#: Game.Levels.EquationalReasoningAutomation.L01_Trivial
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoningAutomation.L01_Trivial
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoningAutomation
msgid "Equational Reasoning Automations"
msgstr ""

#: Game.Levels.EquationalReasoningAutomation
msgid "to do"
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L01_rw
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L01_rw
msgid "addition associative to the left...\n"
"This world is just:\n"
"'\n"
"In Lean, an algebraic rearrangement is indicated by the tactic ring, and a substitution by the tactic rw (stands for ‚Äúrewrite‚Äù). When making a substitution, you must indicate by name the hypotheses which you are substituting.\n"
"'\n"
"'create a term to deal with ...'\n"
"\n"
"Notice that a proof completely made by rewrites can be done exactly the same way with and without `calc`.\n"
"Remember level 3 in equational reasoning.\n"
"\n"
"# `calc`\n"
"`calc` is a tactic that supports forward reasoning. In other words, if the goal is of the form `x = y` then you start from `x` and you reason 'forward' until you reach `y` applying substitutions(rewrites) and manipulations of the expresison you have.\n"
"\n"
"An example would definitely be enlightening, given the following problem:\n"
"```\n"
"example (a b : ‚Ñ§) (h : a - b = 0) : a = b := by\n"
"```\n"
"\n"
"```\n"
"a b : ‚Ñ§\n"
"h : a - b = 0\n"
"‚ä¢ a = b\n"
"```\n"
"Note: ‚Ñ§ is the set of integers, ‚Ñ§ = {...,-3,-2,-1,0,1,2,3,...}\n"
"This is what the solution would look like:\n"
"```\n"
"calc\n"
"  a = (a - b) + b := by ring\n"
"  _ = 0 + b := by rw [h]\n"
"  _ = b := by ring \n"
"```\n"
"Notice that every step of the calculation is shown on each line and justified at the end of that line.\n"
"Lets go through this proof line by line.\n"
"First, we prove that `a = (a - b) + b` using the `ring` tactic.\n"
"Then, we prove that `(a - b) + b = 0 + b`, the `_` there is to avoid having to write `(a - b) + b` again, Lean would just deduce that. Since we know that `(a - b) = 0`, this step is justified by a rewrite.\n"
"Finally, we prove that `0 + b = b` using the ring tactic.\n"
"Now, what calc does is the following: \n"
"since `a = (a - b) + b` and `(a - b) + b = 0 + b` then `a = 0 + b` and since `0 + b = b` then `a = b` which is the goal. This is whats known as the transitivity property of `=`:\n"
"If `a = b` and `b = c` then `a = c`.\n"
"This is obvious because you can substitue `b` for `a` in `b = c`.\n"
"\n"
"You can think of `ring` like a more capable `norm_num`, which is capable of dealing with numbers and more able of manipulating expressions with variables. Moreover, `ring` is for closing goals and cannot be applied to hypothesis which is an advantage `norm_num` has. For this way of proving things, each line is a goal so using `ring` is appropriate.\n"
"\n"
"If you want details, a 'ring' is an algebraic structure with an addition and multiplication operation satisfying some common sense properties. Alot of things like ... are rings. For more details, ...\n"
"\n"
"The syntax of `calc` is as follows:\n"
"```\n"
"calc \n"
"```\n"
"\n"
"# `sorry`?\n"
"You are sorry you don't know the proof and Lean accepts that and closes the goal. Note: this is very dangerous because you might have Lean admit something that is false, which is not a good idea. Also, allowing `sorry` in this game would not let you solve every level by just typing `sorry`.\n"
"\n"
"Replace every occurrence of `sorry` with a legitimate proof."
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L01_rw
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L02_l
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L02_l
msgid "Good luck!"
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L02_l
msgid "hint here, works fine"
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L02_l
msgid "Notice that the pattern for this `calc` is rearrange variables, rewrite, rewrite. The next problem will have the same pattern in addition to requiring a calculation at the end."
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L03_e
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L03_e
msgid "This is new but similar to the previous level."
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L03_e
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L04_whatever
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L04_whatever
msgid "This is the last level you have seen before, the rest will be new."
msgstr ""

#: Game.Levels.EquationalReasoningCalc.L04_whatever
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoningCalc
msgid "This world is a variant world of equational reasoning, where you have to solve some problems from that world using the `calc` tactic.\n"
"\n"
"`calc` is a multiline tactic, so you will be dropped into editor mode in each level in this world."
msgstr ""

#: Game.Levels.LogicTruthValue_.L01_Propositions
msgid ""
msgstr ""

#: Game.Levels.LogicTruthValue_.L01_Propositions
msgid "<img src=\"https://pixabay.com/vectors/cat-kitty-child-animal-cute-baby-8943928\"/>\n"
"\n"
"'The Lean theorem prover had a 4.70 release' is a true statement. After denoting this statement with `P`, we can say that `P` is `True` or `P = True`.\n"
"\n"
"'World War 2 ended in 1950' is a false statement. It ended in 1945. After denoting this statement with `Q`, we can say that `Q` is `False` or `Q = False`.\n"
"\n"
"# examples of propositions\n"
"You have seen propositions in 'Equational Reasoning'. Things like `x = 2`, `y = 6` are propositions i.e of type `Prop`. \n"
"\n"
"These are called atomic propositions. Atomic propositions are ones which contain no logical connectives (like the previously discussed `‚àß`). You will also learn how to make compound propositions from atomic propositions using logical connectives.\n"
"\n"
"# experiment using editor mode\n"
"Editor mode is a vscode like environment. The main thing we want to emphasize this level is that you can hover over things to get more information.\n"
"Use `#check` and hover your mouse to see what it says.\n"
"Try:\n"
"```\n"
"#check 2=2\n"
"#check x=2\n"
"#check P=True \n"
"...\n"
"```\n"
"In Lean, proving `P` or `P = True` is the same thing.\n"
"In other words, for `h : P` , `eq_true h : P = True`. Conversly, for `h : P = True` , `of_eq_true h : P = True`. This world will alternate between both perspectives. The first is primarily focused on valid manipulation of expression and the second is a more 'calculus' approach focused on substituting truth values and calculating...(need better explanation)\n"
"`#check` gives the type of the expression that's after it.\n"
"Notice that `P=True` is of type Prop which means that it is an assertion that is either `True` or `False`. It is true i.e `(P=True)=True` when we find a proof `h : (P = True)`. When faced with any expression of the form: someProp = True, this means that someProp is true. So here, `P=True` is a true statement which implies that `P` can be replaced by `True` wherever it occurs.\n"
"`((P = True) = True) = True` \n"
"Note that a proof of `x = 2` was an `h : x = 2` and not `h : (x = 2) = True`. Here however, a proof of an arbitrary proposition `P` is `h : P = True` and not `h : P`. The latter would work as well, and you can go between the two using an appropriate theorem. The first perspective is emphasized in this world, and the second is emphasized in the world that follows.\n"
"The truth table perspective will make this less confusing.\n"
"Whenever you are done, replace `sorry` with `rfl` to close the goal and move on."
msgstr ""

#: Game.Levels.LogicTruthValue_.L01_Propositions
msgid "works here too?"
msgstr ""

#: Game.Levels.LogicTruthValue_.L01_Propositions
msgid "<img src=\"https://www.spyne.ai/image-enhancer\"/>"
msgstr ""

#: Game.Levels.LogicTruthValue_.L01_Propositions
msgid "<img src=\"https://pixabay.com/vectors/cat-kitty-child-animal-cute-baby-8943928/\">\n"
"\n"
"\n"
"<img src=\"data/g/JadAbouHawili/testing-leangame/Truth-Table-And.png\"/>"
msgstr ""

#: Game.Levels.LogicTruthValue_.L02_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.LogicTruthValue_.L02_Intro
msgid "Notice that the objects of interest are now of type `Prop` (i.e proposition). A proposition is a statement/assertion that can take only one of two values, either true or false. Having `hP : P = true` means that we have a proof that `P` is true, and therefore you can think about this as `P` being true.\n"
"Moreover, having `hnP : P = false` means that we have a proof that `P` is false\n"
"\n"
"`hP` 'exactly' matches the goal. `hP` is 'exactly' what you need to close the goal. This is to emphasize that for the tactic `exact h`, the type of h doesn't matter.\n"
"\n"
"\n"
"<img src=\"data/g/JadAbouHawili/testing-leangame/Truth-Table-And.png\"/>\n"
"\n"
"$\\displaystyle {\\frac {P\\lor Q,\\neg P}{\\therefore Q}}$\n"
"\n"
"\n"
"\n"
"\n"
"$\\iff$"
msgstr ""

#: Game.Levels.LogicTruthValue_.L02_Intro
msgid "Type `exact hP`!"
msgstr ""

#: Game.Levels.LogicTruthValue_.L02_Intro
msgid "Notice that `hQ` and `hR` were not used. We couldn't use them in any case because `Q` and `R` are not related to `P`. In the next levels, we will discuss how to construct new propositions from old ones, where information about these building blocks would help us reason about the newly constructed propositions."
msgstr ""

#: Game.Levels.LogicTruthValue_.L03_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.LogicTruthValue_.L03_Intro
msgid "Explicitly indicate that this is an analogue of the previous world.\n"
"\n"
"Notice that the objects of interest are still of type `Prop` (i.e proposition) but a proof of `P` is indicated as `hP : P`.(make a level before this one where user is in editor mode and eq_true is used to transitition to the previous level, maybe combine both worlds????) A proposition is a statement/assertion that can take only one of two values, either true or false. Having `hP : P` means that we have a proof of `P`, and therefore you can think about this as `P` being true.\n"
"\n"
"`hP` 'exactly' matches the goal. `hP` is 'exactly' what you need to close the goal. This is to emphasize that for the tactic `exact h`, the type of h doesn't matter.\n"
"\n"
"\n"
"<img src=\"data/g/JadAbouHawili/testing-leangame/Truth-Table-And.png\"/>\n"
"\n"
"$\\displaystyle {\\frac {P\\lor Q,\\neg P}{\\therefore Q}}$\n"
"\n"
"$\\iff$"
msgstr ""

#: Game.Levels.LogicTruthValue_.L03_Intro
msgid "Type `exact hP`!"
msgstr ""

#: Game.Levels.LogicTruthValue_.L03_Intro
msgid "Notice that `hQ` and `hR` were not used. We couldn't use them in any case because `Q` and `R` are not related to `P`. In the next levels, we will discuss how to construct new propositions from old ones which would in a sense depend on the old ones."
msgstr ""

#: Game.Levels.LogicTruthValue_.L03_Intro
msgid "You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time).\n"
"\n"
"For an object of type P where P is of type Prop, i.e `h : P` where `P : Prop`, `h` would be a proof or a witness that `P` is true. Equivalently, from `h` we can construct a term `h' := eq_true h of type `h' : P = True` which would be a proof that P is true as well. Both perspectives are interchangeable and equivalent."
msgstr ""

#: Game.Levels.LogicTruthValue_.L04_And
msgid "And"
msgstr ""

#: Game.Levels.LogicTruthValue_.L04_And
msgid "In this level, we will learn about the `‚àß` logical connective, known as 'And'.\n"
"In logic, for `P,Q` propositions, `P ‚àß Q` is true when both `P` is true and `Q` is true, being false otherwise.\n"
"\n"
"# Logical Connectives\n"
"It is important to note that connecting two proposition via a logic connective results in a proposition as well. This proposition, like any other proposition, has a truth value. This truth value depends on the truth value of the propositions it was built out of and the rules of the logical connective. This is clearly illustrated in a truth table. \n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects.\n"
"The following truth table illustrates this for the previously discussed `‚àß` connective.\n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & F \\\\\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that `P ‚àß Q` is true when both `P` is true and `Q` is true, being false otherwise.\n"
"\n"
"## example\n"
"\n"
"Let `p` denote the proposition 'The official language of France is french'(which is true).\n"
"Let `q` denote the prposition 'The official language of Germany is german'(which is true as well).\n"
"Combining these two prpositions together gives us the proposition `p ‚àß q` which translated to English: 'The official language of France is french `And` the official language of Germany is german'. Because the two propositions connected by the `And` are true, then the entire statement is true as well. It's not hard to see that one of or both `p` or `q` being false would make `p ‚àß q` false. In other words, `p ‚àß q` is true when `p` is true and `q` is true. It is false otherwise."
msgstr ""

#: Game.Levels.LogicTruthValue_.L04_And
msgid "testing wow"
msgstr ""

#: Game.Levels.LogicTruthValue_.L04_And
msgid "The constructor tactic transformed the goal `P ‚àß Q` into two subgoals the first being `P` and the second being `Q`. This way of doing things matches the meaning of the `‚àß` connective."
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "And"
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "In this level, we will learn about the `‚àß` logical connective, known as 'And' without directly reasoning with truth values.\n"
"In logic, for `P,Q` propositions, `P and Q` is true when both `P` is true and `Q` is true, being false otherwise.\n"
"\n"
"# Two ways of dealing with ‚àß in the goal(Try both!)\n"
"In Lean, to prove `P ‚àß Q`, you need a proof of `P` and a proof of `Q`.\n"
"## `And` introduction rule\n"
"Using the `And` introduction rule, we can introduce `‚àß` in a newly constructed expression. \n"
"The `And` introduction rule will enable us to prove statements involving `‚àß`.\n"
"For example, given the following proof state:\n"
"```\n"
"hP : P\n"
"hQ : Q\n"
"‚ä¢ P ‚àß Q\n"
"```\n"
"We can close the goal by:\n"
"```\n"
"exact And.intro hP hQ\n"
"```\n"
"\n"
"Here's the type of `And.intro`:\n"
"```\n"
"  And.intro  (left : P) (right : Q) : P ‚àß Q\n"
"```\n"
"`And.intro` takes a proof of `P`, a proof of `Q`, and transforms/evaulates them to a proof of `P ‚àß Q` where `P Q : Prop`.\n"
"Giving these two proofs to the And introduction rule will construct a proof of `P ‚àß Q`.\n"
"\n"
"## `constructor` tactic\n"
"Using the `constructor` tactic will split a goal of the form `P ‚àß Q` into two subgoals `P`,`Q` where you can deal with each one separately\n"
"\n"
"### Example: `And` , `‚àß`\n"
"And.intro\n"
"And.left h\n"
"And.right h\n"
"\n"
"The atomic propositions in the compound proposition `p ‚àß q` are : `p`, `q`. Of course, `p ‚àß q` can be used to construct more complicated propositions.\n"
"\n"
"# truth table \n"
"Refer to the documentation in the right side pane."
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "Try `exact And.intro hP hQ` or `constructor`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "The constructor tactic transformed the goal `P ‚àß Q` into two subgoals the first being `P` and the second being `Q`. This way of doing things matches the meaning of the `‚àß` connective."
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "Notice that the goal is now `P`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "After closing the goal `P`, you now have to close the goal `Q`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid ""
msgstr ""

#: Game.Levels.LogicTruthValue_.L06_Or
msgid "Or, `‚à®`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L06_Or
msgid "There are two `‚à®` introduction rules: \n"
" \n"
"```\n"
"Or.intro_left (b : Prop) (h : a) : a ‚à® b\n"
"```\n"
"- `Or.intro_right`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L06_Or
msgid "Notice that in the type of `Or.intro_left`, you need to explicitly give the type that will be used to the right of the `‚à®` but you don't need to do this for the type to the left of `‚à®`. How does Lean what to do? Well, the type of `Or.intro_left` is in fact:\n"
"```\n"
"Or.intro_left {a : Prop} (b : Prop) (h : a) : a ‚à® b\n"
"```\n"
"The only difference is the curly braces. This means that `a` is an implicit argument. In other words, you don't need to give it explicitly, Lean will deduce it from the type of `h`. For example, if `h:P` where `P:Prop` then Lean will know that `a` is `P` and will put `P` to the left of `‚à®`.\n"
"\n"
"You can avoid entering both `a` or `b` explicitly and instead use: \n"
"```\n"
"Or.inl {a b : Prop} (h : a) : a ‚à® b\n"
"```\n"
"Here, Lean will infer what the propositions are automatically."
msgstr ""

#: Game.Levels.LogicTruthValue_.L07_Or
msgid "Or, `‚à®`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L07_Or
msgid "left, apply Or.inl are the same thing.\n"
"There are two `‚à®` introduction rules: \n"
" \n"
"```\n"
"Or.intro_left (b : Prop) (h : a) : a ‚à® b\n"
"```\n"
"- `Or.intro_right`\n"
"```\n"
"Or.intro_right (a : Prop) (h : b) : a ‚à® b\n"
"```"
msgstr ""

#: Game.Levels.LogicTruthValue_.L07_Or
msgid "Notice that in the type of `Or.intro_left`, you need to explicitly give the type that will be used to the right of the `‚à®` but you don't need to do this for the type to the left of `‚à®`. How does Lean what to do? Well, the type of `Or.intro_left` is in fact:\n"
"```\n"
"Or.intro_left {a : Prop} (b : Prop) (h : a) : a ‚à® b\n"
"```\n"
"The only difference is the curly braces. This means that `a` is an implicit argument. In other words, you don't need to give it explicitly, Lean will deduce it from the type of `h`. For example, if `h:P` where `P:Prop` then Lean will know that `a` is `P` and will put `P` to the left of `‚à®`.\n"
"\n"
"A similar explanation applies to `Or.intro_right` which has the type:\n"
"```\n"
"Or.intro_right {b : Prop} (a : Prop) (h : b) : a ‚à® b\n"
"```\n"
"\n"
"You can avoid entering both `a` or `b` explicitly and instead use: \n"
"```\n"
"Or.inl {a b : Prop} (h : a) : a ‚à® b\n"
"Or.inr {a b : Prop} (h : b) : a ‚à® b\n"
"```"
msgstr ""

#: Game.Levels.LogicTruthValue_.L08_Implication
msgid "Implication, ‚Üí"
msgstr ""

#: Game.Levels.LogicTruthValue_.L08_Implication
msgid "Logical implication `P ‚Üí Q` is made up of two components:\n"
"- The premise, which in this case is `P`\n"
"- The conclusion, which in this case is `Q`\n"
"\n"
"What logical implication does is that it takes evidence or proof for `P` and transforms it returning a proof of `Q`.\n"
"# truth table\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & T \\\\\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"A statement `P ‚Üí Q` is false when `P` is true and `Q` false, it's true otherwise. Since the statement expresses that if `P` is true then `Q` is true, then should make intuitive sense. This utterance is not violated in other cases so the statement is true in those cases.\n"
"\n"
"Representing this rule symbolically:\n"
"$\\displaystyle {\\frac {P\\rightarrow Q, P}{\\therefore Q}}$\n"
"\n"
"This is what this format means in general:\n"
"$\\displaystyle {\\frac {Premises}{Conclusion}}$\n"
"\n"
"We know `P` (i.e `P = True`) , and we know `P ‚Üí Q` (i.e `P = True ‚Üí Q = True`). We can now conclude `Q` (i.e `Q = True`)."
msgstr ""

#: Game.Levels.LogicTruthValue_.L08_Implication
msgid ""
msgstr ""

#: Game.Levels.LogicTruthValue_.L08_Implication
msgid "no lean docstring avaialble\n"
"\n"
"# truth table\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\\\\\n"
"F & T & T \\\\\\\\\n"
"F & F & T \\\\\\\\\n"
"\\hline\n"
"\\end{array}\n"
"$"
msgstr ""

#: Game.Levels.LogicTruthValue_.L09_Implication
msgid "Implication, ‚Üí"
msgstr ""

#: Game.Levels.LogicTruthValue_.L09_Implication
msgid "Logical implication `P ‚Üí Q` is made up of two components:\n"
"- The premise, which in this case is `P`\n"
"- The conclusion, which in this case is `Q`\n"
"\n"
"What logical implication does is that it takes evidence or proof for `P` and transforms it returning a proof of `Q`.\n"
"# truth table\n"
"```\n"
"| P | Q | P ‚Üí Q  |\n"
"|---|---|--------|\n"
"| T | T |   T    |\n"
"| T | F |   F    |\n"
"| F | T |   T    |\n"
"| F | F |   T    |\n"
"```\n"
"\n"
"A statement `P ‚Üí Q` is false when `P` is true and `Q` false, it's true otherwise."
msgstr ""

#: Game.Levels.LogicTruthValue_.L09_Implication
msgid "This is what is called an inference rule. It has two assumptions, `p : P` , `ptoq : P ‚Üí Q` and the conclusion `Q`. It is an inference rule because we 'infer' a certain conclusion from assumptions or already established theorems.\n"
"Usually presented in this format:"
msgstr ""

#: Game.Levels.LogicTruthValue_.L09_Implication
msgid "no lean docstring avaialble"
msgstr ""

#: Game.Levels.LogicTruthValue_.L10_False
msgid ""
msgstr ""

#: Game.Levels.LogicTruthValue_.L10_False
msgid "In this level, we will prove a statement that is always false i.e `= False`. To do this, we take all possible values of the propositional variable involved and show that the expression always evaluates to `False`.\n"
"\n"
"This is a proof by cases. By taking all possible cases and showing a certain statement in each case, we have proven this statement is true. Even more, we have shown its true regardless of the assumptions in the proof state.\n"
"\n"
"--- \n"
"two ways of showing that `P` and `¬¨P` is a contradiction, this is the first but a second way if introducing law of excluded middle and saying which is done ehre as well."
msgstr ""

#: Game.Levels.LogicTruthValue_.L10_False
msgid "Note that we have not obtained a term of type `False` in our proof. We have only proved the above equality. To obtain `False` in our proof state, we would need to have a term of type `p ‚àß ¬¨p` and then use the above theorem rewriting the previous expression to `False`. What happens if we have `False` in our proof state.(now explain stuff about `False` no introduction rule and so on)."
msgstr ""

#: Game.Levels.LogicTruthValue_.L11_Not
msgid "Not Connective, ¬¨"
msgstr ""

#: Game.Levels.LogicTruthValue_.L11_Not
msgid "Another way to say that `P = False` is by saying `¬¨P = True`. These two statements say the same thing. This is how we will define `¬¨`.\n"
"`¬¨` is defined to satisfy the following properties:\n"
"`(P = True) ‚Üí (¬¨P = False)`\n"
"`(P = False) ‚Üí (¬¨P = True)`\n"
"If `P` is True, then `¬¨P` is False.\n"
"If `P` is False, then `¬¨P` is True.\n"
"\n"
"If `¬¨P` is False, then `P` is True.\n"
"If `¬¨P` is False, then `P` is True.\n"
"\n"
"Two nots give a true. Double negatives. Two negatives make/resolve into a positive.\n"
"\n"
"Intuitvely, this fits how negation or 'not' works in language.\n"
"\n"
"Notice that this is the first logical connective that applies on one proposition only and not two.\n"
"\n"
"If `P` then `False`.\n"
"\n"
"\n"
"\n"
"------\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"a & b & F \\\\\n"
"\\hline\n"
"0 & 0 & 0 \\\\\n"
"0 & 1 & 0 \\\\\n"
"1 & 0 & 0 \\\\\n"
"1 & 1 & 1 \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"`¬¨P` in Lean is defined as `P ‚Üí False`. What this means is that we obtain `¬¨P` by assuming `P` and deriving a contradiction i.e constructing an object of type `False`. \n"
"\n"
"`False` is the empty proposition, thus it has no introduction rule. It represents a contradiction.\n"
"What is a contradiction? Well, it is a propostional statement that is false for all possible values of its variables. The standard example of a contradiction is the following: \n"
"\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & ¬¨P & P ‚àß ¬¨P\\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"F & T & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Another meaning for the term contradiction to refer to the assertion or proof of a propositional statement that is false for all possible values of its variables. We will use both interchangeably. So, deriving a contradiction means constructing such a proof.\n"
"\n"
"# What is `False` exactly? \n"
"\n"
"## How to prove `False` and what are the consequences? -- this has been introduced in the previous level...\n"
"This is what you did in the previous level. This section is just reiterating that point. \n"
"\n"
"Well, when was the first time you saw `False`?\n"
"\n"
"Here:\n"
"'\n"
"Negation of a proposition `P`, denoted `¬¨P`, is defined as `P ‚Üí False`. \n"
"'\n"
"It should be clear that to get to false, you would need to prove `¬¨P`, and `P`. Then given such a proof state:\n"
"```\n"
"hnP : ¬¨P\n"
"hP : P\n"
"```\n"
"we can obtain false by `hnP hP`.\n"
"Proving a proposition and its negation is a special case of 'deriving a contradiction' because we have proven `p ‚àß ¬¨p` which is always false. A logical system that has this quality is called an inconsistent system.\n"
"\n"
"## Principle of explosion\n"
"Moreover, `False` has no introduction rule , so the reasoning described above is the only way to obtain an object of type `False`. If you were able to find `h:False` i.e prove `False` then our system is worthless because we can prove anything. To reiterate, such a system would be called an inconsistent system because of a contradiction.\n"
"\n"
"-- rules of inference like modus ponens need to be emphasized to make this understsanble. Also we can make the user prove the principle of explosion using modus ponens.\n"
"will be discussed in previous, but the basic idea is that if you have in your proof state an `h` such that `h:False` then you can prove any proposition you want. In other words, within this proof state, all propositions are true. This is obviously absurd because it would mean for every proposition `p`, `p` is true and also `¬¨p` is true.\n"
"\n"
"So this is pretty good because now you can effortlessly prove anything you want!!!!! But this is also pretty bad because you can't really trust any of the results you obtain within an inconsistent system, can you?"
msgstr ""

#: Game.Levels.LogicTruthValue_.L11_Not
msgid ""
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "asdf"
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "Our goal is to prove `False`. This looks problematic from the get go, and we will go into the details of that in this level. But, let's first go discuss what `False` is as a type.\n"
"\n"
"\n"
"`False` is an 'empty' type that has no introduction rule. Then how can we prove `False`? Now explain negation and stuff.... We know that `False ‚â† True` and its proof in Lean is:\n"
"```\n"
"false_ne_true : False ‚â† True\n"
"```\n"
"i.e ¬¨(False = True) which is read as: 'it is not the case that `False = True`'.\n"
"In this proof state, we can prove that `False = True`. Replace the `p` in `hp` by `False` using `hnp`.\n"
"\n"
"\n"
"`False` is the empty proposition. Thus, it has no introduction rules.\n"
"It represents a contradiction. `False` elimination rule, `False.rec`,\n"
"expresses the fact that anything follows from a contradiction.\n"
"This rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\n"
"or the principle of explosion.\n"
"For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"
"\n"
"Proving `False` means deriving a contradiction. So, to prove `¬¨p` , you must assume `p` and derive a contradiction. We will explain in more detail what is meant by 'contradiction'.\n"
"----------------------------\n"
"# Truth Table\n"
"We want an operator which flips the value of a proposition `P`. Lets call this operator `Not` represented as `¬¨`. In other words, if `P` were true then `¬¨P` would be false and vice versa. \n"
"Note that `¬¨P` is also a proposition, so `¬¨ (¬¨P)` is a valid expression. Moreover, `¬¨ (¬¨P)` is a proposition so `¬¨ (¬¨ (¬¨P))` or `¬¨¬¨¬¨P` is a valid expression (and so on).\n"
"\n"
"\n"
"This is what the truth table would look like.\n"
"$$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & ¬¨P \\\\\n"
"\\hline\n"
"T & F  \\\\\n"
"F & T  \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$$\n"
"\n"
"But we don't need to introduce a new symbol, it can be defined in terms of what we already know.\n"
"Defining `¬¨P` as `P ‚Üí False` would accomplish this. \n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & P ‚Üí False \\\\\n"
"\\hline\n"
"T & F  \\\\\n"
"F & T  \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that this definition is an implication which you have learned to deal with in the previous level and that the truth table with `¬¨P` and the truth table with `P ‚Üí False` are identical which means that the implication definition captures what we want `¬¨` to mean.\n"
"\n"
"# Natural Language Example\n"
"Let `P` denote the assertion 'Today is Monday'. `¬¨P` would then denote the assertion 'Today is not Monday'. You could also say that `¬¨P` denotes 'Today is Tuesday or Wednsday or Thursday or Friday or Saturday or Sunday'. Both assertions express the same thing (assuming there are 7 days of the week and these are their names) so either one is acceptable.\n"
"\n"
"# Contradictions\n"
"Now we can construct propositional statements that are always false regardless of the values of their propositional variables. Having such a statement in your proof state would allow you to construct a term of type `False`. \n"
"\n"
"Such a statement is called a contradiction and is equal to `False` regardless of the proof state. Moreover, it is not something we assume to be true but something that is always true.\n"
"--------------------------------\n"
"# Defining `¬¨`\n"
"\n"
"## But what is `False` exactly?(now we know what `False` is from the truth value perspective so this would need a rewrite in logic world, no it doesn't because we were dealing with `= False` but now we are dealing with `‚Üí False`).\n"
"For now, just know that `False` is a type that has no introduction rule and that proving `False` means deriving a contradiction. So, to prove `¬¨p` , you must assume `p` and derive a contradiction. We will explain in more detail what is meant by 'contradiction'.\n"
"\n"
"To emphasize the fact that negation is an implication, you have to go through this simple level."
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "If you feel like seeing the implication definition of ¬¨ in the proof state would provide more clarity and make it easier to solve upcoming problems, you can always unfold ¬¨ to its implication form. Try `unfold Not at hnp`."
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "Now, this is just like the previous level"
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "In the next level, we will explore what it means to have proven `False`(pretty bad, or pretty good depending on how you look at it)."
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid ""
msgstr ""

#: Game.Levels.LogicTruthValue_
msgid "Logic Truth Value_"
msgstr ""

#: Game.Levels.LogicTruthValue_
msgid "This world will heavily rely on the truth table perspective of propositions and the various logical connective to provide an intuitive foundation for explaining the validity of various rules in propositional logic. 'Propositions' will be explained here, and the rest will be hinted at here but fully explained throught the levels.\n"
"\n"
"In this world, we will be dealing with `Objects` of type `Prop` i.e propositions. You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time).\n"
"\n"
"Moreover, these statements are denoted by a symbol like `P`,`Q`,`R`.\n"
"For example, the proposition 'World War 2 ended in 1950' is false. It ended in 1945. After denoting this statement with `Q`, we can say that `Q` is `False`\n"
"\n"
"# Building New Propositions From Previous Ones\n"
"In this world, you will also learn how to construct new propositions by connecting other propositions with logical connectives. \n"
"\n"
"Just as a quick example: \n"
"Let `P` be the proposition 'It is cloudy' and let `Q` be the proposition 'It is raining'. Out of these two atomic propositions, we can form the compound proposition 'It is cloudy `and` it is rainy' denoted `P ‚àß Q` where `‚àß` in the propostional world means `and`. This is translation from english to propositional notation, we will not be concerned directly with the details of this process but will use it to intuitively convey how propositional logic works.\n"
"\n"
"## Connecting Propositions With A Logical Connective\n"
"It is important to note that connecting two proposition via a logic connective results in a proposition as well. If this wasn't the case, then how could we talk about the truth value of `P ‚àß Q` if `P ‚àß Q` were not a proposition! This proposition constructed using a logical connective and other propositions, like any other proposition, has a truth value. This truth value depends on the truth value of the propositions it was built out of and the rules of the logical connective. This is clearly illustrated in a truth table. \n"
"Here's an example:\n"
"\n"
"# quick overview\n"
"\n"
"## proving statements involving logical connectives\n"
"This will involve using inference rules that are intuitively true from the truth table perspective. \n"
"\n"
"## unpacking information from a complicated propositional statement\n"
"N/A\n"
"\n"
"# shifting between the two perspectives"
msgstr ""

#: Game.Levels.LogicAlternative.L01_assumption
msgid "`assumption` tactic"
msgstr ""

#: Game.Levels.LogicAlternative.L01_assumption
msgid "Let's introduce the first 'automation' tactic. \n"
"The point behind such tactics is that there are tedious patterns of reasoning and automation tactics alleviate the burden of having to spell them out into Lean every time. \n"
"\n"
"Automations will sacrifice ... for brevity which is less tedious but might be more obfuscated.\n"
"\n"
"One pattern of reasoning you will almost always encounter is having an assumption of a type that 'exactly' matches the goal. The `exact` tactic suggests itself here, but you could just write `assumption`. The `assumption` tactic will use the assumptions in the proof state to prove the goal.\n"
"\n"
"Try it out!"
msgstr ""

#: Game.Levels.LogicAlternative.L01_assumption
msgid "Informally, the `assumption` tactic looks through the assumptions in the proof state and tries to find one which has a type that matches the goal through the assumptions in the proof state and tries to find one that which has a type that matches the goal. In this case, that would be `hP` and the type would be `P`.\n"
"\n"
"The `assumption` tactic is capable of alot more, but it will not be used in this game. You can read more about these capabilities in the right side pane documentation\n"
"\n"
"The advantage of the `assumption` tactic over exact is that you don't have to spell out the assumption to Lean. However, it might be clearer to explicity do so. This is the tradeoff between brevity and ..."
msgstr ""

#: Game.Levels.LogicAlternative.L02_constructorNotation
msgid "The `‚ü®‚ü©` notation"
msgstr ""

#: Game.Levels.LogicAlternative.L02_constructorNotation
msgid "`‚ü®‚ü©` is another way to introduce `‚àß`.\n"
"Consider the following proof state:\n"
"```\n"
"h1 : P\n"
"h2 : Q\n"
"```\n"
"If your and introduction looks like the following:\n"
"```\n"
"And.intro h1 h2\n"
"```\n"
"then the equivalent `‚ü®‚ü©` syntax is:\n"
"```\n"
"‚ü®h1,h2‚ü© \n"
"```\n"
"Both notations produce/construct an object of type `P ‚àß Q`"
msgstr ""

#: Game.Levels.LogicAlternative.L02_constructorNotation
msgid ""
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "Or"
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "In this level, you will learn about the `Or` logical connective.\n"
"\n"
"# truth table\n"
"```\n"
"| P | Q | P ‚à® Q  |\n"
"|---|---|--------|\n"
"| T | T |   T    |\n"
"| T | F |   T    |\n"
"| F | T |   T    |\n"
"| F | F |   F    |\n"
"```\n"
"\n"
"From the truth table, we can see that if one of `P`,`Q` is true then `P ‚à® Q` is true. \n"
"Therefore, if we have `P ‚à® Q` as our goal, it is enough to prove `P` or to prove `Q`.\n"
"This is exactly what the `left` and `right` tactic does. \n"
"The `left` tactic transforms our goal from `P ‚à® Q` to `P` and similarily for the `right` tactic. This is because Lean understands that if `P` is true, then `P ‚à® Q` is true."
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "Use either `left` or `right`"
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "`p` is exactly the goal"
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "`q` is exactly the goal"
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid ""
msgstr ""

#: Game.Levels.LogicAlternative.L04_apply
msgid "`apply` tactic"
msgstr ""

#: Game.Levels.LogicAlternative.L04_apply
msgid "The `apply` tactic takes an implication as its argument where the conclusion of the implication matches the goal.\n"
"Here is how `apply` 'thinks', and how it transforms the proof state:\n"
"Since we can conclude the conclusion of the implication which is also our goal from its premise, our new goal becomes the premise. In a sense, the `apply` tactic sets up modus ponens for you and the missing piece is proving the premise of the implication\n"
"\n"
"remember the X Y problem"
msgstr ""

#: Game.Levels.LogicAlternative.L04_apply
msgid ""
msgstr ""

#: Game.Levels.LogicAlternative.L04_apply
msgid "The apply tactic takes a proof of a general statement or implication, tries to match the conclusion with the current goal,\n"
"and leaves the hypotheses, if any, as new goals. If the given proof matches the goal exactly (modulo definitional equality),\n"
"you can use the exact tactic instead of apply. So, all of these work:"
msgstr ""

#: Game.Levels.LogicAlternative
msgid "This world will have the same exercises as the previous `Logic` world, but the difference will be the tactics used to solve them, which will change the reasoning process."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "We can think of the set of knights and the set of knaves, denoted `Knights`, `Knaves` respectively. A set is a collection of 'entities' with a specified property. The set `Knight` would be the set of inhabitants of the island that are knights i.e satisfying the property of always telling the truth, the set `Knave` being the set of inhabitatns of the island that are knives i.e the ones that always lie. \n"
"\n"
"Note that in Lean, `Set K` means the set of objects of type `K`( this can be changed to something clearer?? think of clarity benefits of a change). Note that in each level, we will be considering two or three inhabitants of the island and will not be reasoning about the sets themselves but about these fixed inhabitants named `A`, `B`, `C`.\n"
"\n"
"---------------------------------\n"
"Here we introduce Xor'. \n"
"Many definitions capture the meaning we want: there is iff definition, and ‚àß ‚à® definition. \n"
"\n"
"We don't need these and can opt for a simpler assumption,"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "Note that the forward direction is always true, and our assumption `h` wasn't used, but the backward direction is not always( We used `h` for that). This offers a simplification and decluttering of the proof state and will be followed from now on. The downside is an apparent loss of information, but the coming levels will show that this is not the case.\n"
"\n"
"(follow up to show that there was no loss of information)"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_Knight_NotKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_Knight_NotKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_Knight_NotKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knave_NotKnight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knave_NotKnight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knave_NotKnight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_NotKnave_Knight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_NotKnave_Knight
msgid "Before starting the riddles, some new concepts have to be clarified.\n"
"Xor...\n"
"it is obvious that no one can be a knight and a knave at the same time. If some is not a knave then they are a knight."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_NotKnave_Knight
msgid "asdf"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_NotKnave_Knight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_NotKnave_Knight
msgid "def Xor' (a b : Prop) := (a ‚àß ¬¨ b) ‚à® (b ‚àß ¬¨ a)\n"
"\n"
"# Exclusive Or \n"
"\n"
"## Rewriting Xor'\n"
"`Xor' p q` can be rewritten as:\n"
"```\n"
"(p ‚àß ¬¨q) ‚à® (¬¨p ‚àß q)\n"
"```\n"
"To rewrite `Xor'` in the goal:\n"
"```\n"
"rw [Xor']\n"
"```\n"
"\n"
"To rewrite `Xor'` in hypothesis `h`:\n"
"```\n"
"rw [Xor'] at h\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_NotKnight_Knave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_NotKnight_Knave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_NotKnight_Knave
msgid "Let's recap what we have proven in the last four levels.\n"
"\n"
"Given the following proof state:\n"
"```\n"
"(Knight : Set K ) (Knave : Set K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h'' : ‚àÄ (x: K), x ‚àà Knight ‚à® x ‚àà Knave)\n"
"```\n"
"\n"
"\n"
"We can conclude the following implications:\n"
"A ‚àà Knight ‚Üí A ‚àâ Knave  \n"
"A ‚àâ Knave ‚Üí A ‚àà Knight\n"
"which can be combined into: A ‚àà Knight ‚Üî A ‚àâ Knave\n"
"Similarly for the other two levels, we can conclude A ‚àâ Knight ‚Üî A ‚àà Knave\n"
"\n"
"These two theorems will be very useful in the following world.\n"
"\n"
"------------------------\n"
"\n"
"We have proven:\n"
"```\n"
"(Knight : Set K) (Knave : Set K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h' : A ‚àà Knight)\n"
"  : A ‚àâ Knave \n"
"\n"
"\n"
"\n"
"(Knight : Set K ) (Knave : Set K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h' : ¬¨ (B ‚àà Knave))\n"
"(h'' : ‚àÄ (x: K), x ‚àà Knight ‚à® x ‚àà Knave)\n"
"  :  B ‚àà Knight := by\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas
msgid "Knights and Knaves, lemmas"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas
msgid "This level will introduce the knights and knaves puzzle, detail the process of formalizing and representing it in Lean, and prove basic but important lemmas that will be used to solve puzzles in the next world.\n"
"\n"
"The setting is an island in which its inhabitatnts satisfy the following properties:\n"
"- Every inhabitant of the island is either a knight or a knave. \n"
"- 'Knights' always tell the truth and 'Knaves' always lie. \n"
"The objective is to conclude who is a knight and who is a knave, based on the statements of several inhabitants. This will be done using logical reasoning. Every inhabitant will make at most one statement.\n"
"\n"
"How should this be translated into Logic? Well, this is what the upcoming levels will focus on before transitioning to proving some important properties. \n"
"\n"
"\n"
"Note that you can't be a Knight and a Knave at the same time, you can only be one or the other and not both. \n"
"1. We can capture this in logic by saying that the two sets `Knight` and `Knave` are disjoint i.e there is no inhabitant that belongs to both at the same time. The notation for that is `Knight ‚à© Knave = ‚àÖ` where `‚àÖ` is a set with no elements.\n"
"2. We can capture this in logic by saying that for any inhabitant say `A`, (`A` is a knight and is not a knave) or (`A` is a knave and is not a knight).\n"
"3. inductive type interpretation?  \n"
"variable (Inhabitant : Type)\n"
"#check (Sum Inhabitant Inhabitant\n"
"variable (A : Sum Knight Knave)\n"
"variable (B : Knight)\n"
"example : 2=2 := by sorry\n"
"\n"
"Then, for any inhabitant of the island they are either a knight or a knave but not both. In other words, if they are a knight then they can't be a knave and if they are a knave they can't be a knight. This can be translated to : (x is a knight and x is not a knave) or (x is a knave and is not a knight). This can be simplified to just saying that: (x is a knight) or (x is a knave) conveying the same information. In the first case (x being a knight), we know the two sets are disjoint so x can't be a knave. Similarly for the second case. This simpler statement conveys the same information as the former which is more complicated, so it should ie be used instead.\n"
"\n"
"-- don't show any formalism, just lay it out here then copy paste it to every level and formalise there.\n"
"\n"
"The statement `x ‚àà Knight` should be understand as 'x IS Knight' i.e 'x' always tells the truth. \n"
"Similarly, the statement `x ‚àâ Knight` should be understand as 'x IS-NOT Knight'. What is `x` then? `x` has to be a knave.\n"
"\n"
"The same reasoning applies to `x ‚àà Knave`, `x ‚àâ Knave`.\n"
"Every mentioned here will be thoroughly formalized and explained in this world, and the paragraph in question in that level will be directly referenced. Every idea is left to be elaborated and formalised in the levels of this world."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_Introduction
msgid "Intro"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_Introduction
msgid "# Xor\n"
"To introduce Xor, introduce as the negation of if and only if. Xor is inequivalence, Xor is such that exactly one of the propositions is truei.e exclusive or. \n"
"\n"
"# How the proof will work(cases tactic)\n"
"Take all possible cases for `x` and `y`. These cases are:\n"
"```\n"
"x ‚àà Knight, y ‚àà Knight\n"
"x ‚àà Knight, y ‚àà Knave\n"
"x ‚àà Knave, y ‚àà Knight\n"
"x ‚àà Knave, y ‚àà Knave\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_Introduction
msgid "This last message appears if the level is solved."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L02_Anoter
msgid "lev 2"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L02_Anoter
msgid "Hi"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L02_Anoter
msgid "."
msgstr ""

#: Game.Levels.KnightsAndKnaves
msgid "Knights And Knaves"
msgstr ""

#: Game.Levels.KnightsAndKnaves
msgid "It is recommended to solve the problems in this world while in editor mode, though you have the choice not to."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas2.L01_NotKnave_Knight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas2.L01_NotKnave_Knight
msgid "Before starting the riddles, some new concepts have to be clarified.\n"
"Xor...\n"
"it is obvious that no one can be a knight and a knave at the same time. If some is not a knave then they are a knight."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas2.L01_NotKnave_Knight
msgid "asdf"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas2.L01_NotKnave_Knight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas2.L02_inter_empty
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas2.L02_inter_empty
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas2.L02_inter_empty
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas2
msgid "Knights and Knaves, lemmas 2"
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "Knights and Knaves, second approach"
msgstr ""

#: Game
msgid "Reasoning"
msgstr ""

#: Game
msgid "This is a gamification of mathematical proofs. Every level has a `Goal`, which is what you are trying to prove. Closing the `Goal` means you have proved the theorem and there is nothing else to do.\n"
"\n"
"You will use the Lean theorem prover, and its mathematical library mathlib.\n"
"\n"
"# Right Side Pane\n"
"Let's explain what's going on in the right side pane.\n"
"\n"
"Anything you click on will display an overview and some examples. This will be available to you at all times when working on the levels. Refer back to it whenever you need to.\n"
"\n"
"## Tactics\n"
"In this puzzle game, you will use tactics to manipulate the `Goal` and close it, essentially proving the `Goal`. Tactics will be incrementally introduced, and tactics that haven't been introduced yet will have a lock icon which means you can't use them yet. \n"
"\n"
"## Definitions\n"
"The point of this game is not just to showcase ***Lean***, but also to learn some mathematics. Relevant definitions will be displayed here\n"
"\n"
"## Theorems\n"
"Here is listed theorems to use throughout the levels. Some you would have proved in previous levels and others are presented for you to use but without proof.\n"
"\n"
"# Level Structure\n"
"Within every level, the `Objects`, `Assumptions`, and `Goal` for the current level. This is called the initial proof state. There will also be a text input to execute tactics accordingly.\n"
"***Lean*** tracks the proof state as you execute tactics. \n"
"You will execute tactics one by one until Lean tells you that have closed the goal.\n"
"\n"
"# More info\n"
"You can click the hamburger menu in the top right then 'Game Info' for more information.\n"
"\n"
"# Terminlogy"
msgstr ""

#: Game
msgid "Here you can put additional information about the game. It is accessible\n"
"from the starting through the drop-down menu.\n"
"\n"
"For example: Game version, Credits, Link to Github and Zulip, etc.\n"
"\n"
"Many technical details have been skipped for the sake of not getting bogged down with Lean and its mathematical library mathlib, but focus on the aspects of reasoning and proof. You can visit https://leanprover-community.github.io/mathlib4_docs/ for more information about any tactic used by searching `Mathlib.Tactic.tacticname`, and theorems.\n"
"\n"
"Zulip chat for lean has been a very useful resource to resolve issues when formalizing the exercises, you can visit it and ask questions in the '#new members' stream. You can also view messages without signing up. There are other streams dedicated to various topics you can check out as well. \n"
"\n"
"# Editor Mode \n"
"## copy and paste your solutions somewhere else\n"
"Some levels will force you to use editor mode. Editor mode is necessary for multiline tactics. Moreover, you should get used to it because it mimics a vscode Lean environment which is the most common way Lean is run.\n"
"\n"
"To access editor mode, click on the icon to the left of the hamburger menu in the top right.\n"
"You can copy and paste your solutions if you have Lean setup, or you can use the lean web editor: https://live.lean-lang.org/ if you want to experiment with your solutions outside the lean game.\n"
"Make sure to have `import Mathlib.Tactic` at the top and then to copy whats above the editor area which is the problem statement. Each problem statement is of the form `example ... :=  by` and after that is where your solution should go.\n"
"\n"
"## vscode like environment\n"
"Hovering over things will give you useful information.\n"
"# Links \n"
"https://leanprover-community.github.io/\n"
"https://lean-lang.org/\n"
"https://lean-lang.org/documentation/\n"
"\n"
"https://github.com/leanprover-community/mathlib4\n"
"\n"
"https://leanprover.zulipchat.com/\n"
"https://zulip.com/case-studies/lean/\n"
"\n"
"# how to navigate documentation\n"
"You can use https://leanprover-community.github.io/mathlib4_docs/ for Lean and mathlib related documentation. You can see 'Lean', 'Mathlib' in the left side pane, clicking on either will expand them. A more effective way of finding what you want is using the search feature of this page , using 'Go To Definition' if you have vscode setup for Lean and mathlib, or hovering over things to get more information\n"
"\n"
"# Rules\n"
"You can relax the rules.\n"
"\n"
"This is not recommended for people who have never heard about Lean before. Moreover, relaxing the rules would ruin the coherence and structured/guided experience you would have when playing the game normally. If that is what you are looking for, then don't relax the rules."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
