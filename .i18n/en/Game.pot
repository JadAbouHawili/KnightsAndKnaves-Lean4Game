msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Sat Nov 16 12:03:19 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Doc.doc
msgid "Unfoldable:\n"
"unfold Not at ...\n"
"¬¨P is P ‚Üí False\n"
"\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & ¬¨P \\\\\n"
"\\hline\n"
"T & F \\\\\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that this definition is an implication and that the truth table with `¬¨P` and the truth table with `P ‚Üí False` are identical.\n"
"\n"
"What this means is that to prove `¬¨P`, we assume `P` and derive a contradiction i.e constructing an object of type `False`. \n"
"In other words, having `¬¨P` as a goal, you have to start the proof with `intro` because you are proving an implication.\n"
"\n"
"\n"
"\n"
"It represents a contradiction. `False` elimination rule, `False.rec`,\n"
"expresses the fact that anything follows from a contradiction.\n"
"This rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\n"
"or the principle of explosion.\n"
"For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"
"\n"
"`False` is an 'empty' type that has no introduction rule. \n"
"\n"
"`False` is the empty proposition. Thus, it has no introduction rules.\n"
"\n"
"Proving `False` means deriving a contradiction. So, to prove `¬¨p` , you must assume `p` and derive a contradiction."
msgstr ""

#: Game.Doc.doc
msgid "You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time).\n"
"\n"
"For an object of type P where P is of type Prop, i.e `h : P` where `P : Prop`, `h` would be a proof or a witness that `P` is true. Equivalently, from `h` we can construct a term `h' := eq_true h of type `h' : P = True` which would be a proof that P is true as well. Both perspectives are interchangeable and equivalent.\n"
"\n"
"# Constructing new propositions from old ones\n"
"The atomic propositions in the compound proposition `p ‚àß q` are : `p`, `q`. Of course, `p ‚àß q` can be used to construct more complicated propositions.\n"
"\n"
"\n"
"\n"
"## Connecting Propositions With A Logical Connective\n"
"It is important to note that connecting two proposition via a logic connective results in a proposition as well. If this wasn't the case, then how could we talk about the truth value of `P ‚àß Q` if `P ‚àß Q` were not a proposition! This proposition constructed using a logical connective and other propositions, like any other proposition, has a truth value. This truth value depends on the truth value of the propositions it was built out of and the rules of the logical connective. This is clearly illustrated in a truth table. \n"
"\n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects."
msgstr ""

#: Game.Doc.doc
msgid "# truth table\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\\\\\n"
"\\hline\n"
"F & T & T \\\\\\\\\n"
"\\hline\n"
"F & F & T \\\\\\\\\n"
"\\hline\n"
"\\end{array}\n"
"$"
msgstr ""

#: Game.Doc.doc
msgid "`And.intro` takes a proof of `P`, a proof of `Q`, and transforms/evaulates them to a proof of `P ‚àß Q` where `P Q : Prop`.\n"
"\n"
"Truth table:\n"
"\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$"
msgstr ""

#: Game.Doc.doc
msgid "`‚à©` is an operator on sets.\n"
"\n"
"Applying it to two sets `A`,`B`:\n"
"```\n"
"A ‚à© B\n"
"```\n"
"\n"
"`A ‚à© B` is itself another set, containing elements that are in both `A` and `B`."
msgstr ""

#: Game.Doc.doc
msgid "`rfl` is short for reflexivity. In the context of numbers, it is the property that for any number `a`, `a = a`.\n"
"\n"
"More generally, the `rfl` tactic will close all goals of the form `X=X`, regardless of what `X` is, `X=Y` where `X` and `Y` are identical. rfl can also prove the equality of two things that are 'equal by definition'.\n"
"\n"
"In fact, `rfl` is not a tactic but syntactic sugar for `exact rfl`. `rfl` is of type `a = a` for any `a`.\n"
"\n"
"\n"
"\n"
"`rfl` also applies more generally, `rfl` will close any goal of the form `A=B` where `A`,`B` are identical. If needed, `rfl` will unfold both sides into their definitions and then check if they are equal. In other words, `rfl` can prove the equality of two things that are 'equal by definition'.\n"
"## examples\n"
"```\n"
"x - 7 = x - 7\n"
"```\n"
"`rfl` will close this goal."
msgstr ""

#: Game.Doc.doc
msgid "testing stuff, does importing work?!?!?!?!"
msgstr ""

#: Game.Doc.doc
msgid "[[mathlib_doc]]\n"
"There is an alternative syntax for `have` which you can view in the right side pane. In any case, it will be introduced later on when its more convenient to use.\n"
"`have name := ........`"
msgstr ""

#: Game.Doc.doc
msgid "## Overview\n"
"Having h : P and P as your goal, exact h will close the goal. exact h asserts that h is exactly whats needed to prove the goal which makes sense because h is a proof of P.(It doesn't matter what P is)"
msgstr ""

#: Game.Doc.doc
msgid "Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `‚Åª¬π` `^` and `%`\n"
"over numerical types such as `‚Ñï`, `‚Ñ§`, `‚Ñö`, `‚Ñù`, `‚ÑÇ`."
msgstr ""

#: Game.Doc.doc
msgid "```\n"
"`have name-of-object : type := by ...` \n"
"```\n"
"where `...` is the proof.\n"
"`name-of-object` can be whatever you want, leaving it empty would  give the theorem a name automatically. The `type` in this case is the statement we want to prove."
msgstr ""

#: Game.Doc.doc
msgid "The `contradiction` tactic works for the following proofs states:\n"
"```\n"
"h : False\n"
"```\n"
"\n"
"```\n"
"hP : P\n"
"hnP : ¬¨P\n"
"```\n"
"\n"
"and\n"
"```\n"
"hP : P\n"
"```\n"
"where Lean knows that `¬¨P` is true."
msgstr ""

#: Game.Doc.doc
msgid "# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects.\n"
"The following truth table illustrates this for the previously discussed `‚àß` connective.\n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & F \\\\\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that `P ‚àß Q` is true when both `P` is true and `Q` is true, being false otherwise."
msgstr ""

#: Game.Doc.doc
msgid "A summary of all the terminology presented throughout the game, in order of appearance.\n"
"\n"
"-"
msgstr ""

#: Game.Doc.doc
msgid "A set is a collection of 'entities' with a specified property. The set `Knight` would be the set of inhabitants of the island that are knights i.e satisfying the property of always telling the truth, the set `Knave` being the set of inhabitatns of the island that are knives i.e the ones that always lie. \n"
"\n"
"Note that in Lean, `Set K` means the set of objects of type `K`( this can be changed to something clearer?? think of clarity benefits of a change). Note that in each level, we will be considering two or three inhabitants of the island and will not be reasoning about the sets themselves but about these fixed inhabitants named `A`, `B`, `C`."
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "A Number Equals Itself"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "In this exercise, we will prove `2 = 2`\n"
"\n"
"`rfl` will do the job.\n"
"\n"
"`rfl` is short for reflexivity, which is the property that for any number `a`, `a = a`"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "Notice that 'level completed! üéâ' on the bottom. We say that the goal is closed/proven."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "Introd"
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "In this level, we have `Objects`, `Assumptions`, and the `Goal`.\n"
"\n"
"# Objects\n"
"Objects will always be variables(letter symbols) we are working with. What these variables denote is specified after the `:`, what is after the `:` is called the type of the object.  \n"
"\n"
"Here, `x`  denotes a number but we don't know which number it is. The `: ‚Ñï` in `x : ‚Ñï` means that `x` is a variable of type natural number(positive numbers like `1`,`2`,`3`, and so on...). \n"
"\n"
"# Assumptions\n"
"As for the assumptions, we have `h : x=2` which means that `h` is an object of type `x=2`. This essentially means that `h` is an object asserting that the proposition(or statement) `x=2` is true. In other words, we know that `x=2` and `h` is a proof of that. \n"
"\n"
"# Goal\n"
"Our goal is to prove that `x = 2`.\n"
"Always look at the assumptions which represent everything you know. Well, we already have that `h` is a proof of the goal. \n"
"We should let Lean know. Using `exact h` accomplishes this."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "The `exact` in `exact h` tells Lean that `h`'s type EXACTLY matches the goal. Lean verifies this and reports that there are no more goals to prove. We are done."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Substituting Variables By Their Values"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "We will learn how to substitute a variable with its value, for example how to substitiute `x` by `2` if we know that `x=2`.\n"
"\n"
"This can be done using the tactic `rw` (short for rewrite).\n"
"\n"
"`rw` takes a term of type `A=B` and replaces all the `A`s in the goal with `B`s.\n"
"So `rw [h]` where `h : x=3` will replace all the `x`s of the goal with `3`."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Do `rw [¬´{h}¬ª]` or `rw [¬´{g}¬ª]` and observe what happens."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "You should use `¬´{h}¬ª` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "`rw [h]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "You should use `¬´{g}¬ª` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "`rw [g]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Our goal is now `3 + 3 = 6`. The `rw` tactic implicitly executes `rfl` after doing the rewrite which unfolds the numbers `3` and `6` to what they are defined as, and it turns out both sides are identical. I would recommend the natural number game if you want to learn more.\n"
"\n"
"Another solution:\n"
"```\n"
"rw [h,g]\n"
"```\n"
"instead of \n"
"```\n"
"rw [h]\n"
"rw [g]\n"
"```"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_Normalize
msgid "Normalize Equations"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_Normalize
msgid "In this level, we will learn about normalizing equations using the `norm_num` tactic.\n"
"\n"
"`norm_num` is short for normalize numerical expressions like carrying out calculations and simplifying the expression.\n"
"\n"
"We will also learn how to apply a tactic to an assumption instead of the goal.\n"
"\n"
"We want to carry out the operation `4*4` in `h` and simplify the expression. `norm_num` does the job. `norm_num` would apply to the goal but want it to apply on `h`. Doing `norm_num at h` will do it."
msgstr ""

#: Game.Levels.EquationalReasoning.L04_Normalize
msgid "EXACTLY like the goal"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_Normalize
msgid ""
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "some title"
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "Here we introduce the `have` tactic which allows us to add theorems to the context(which you would have to prove, of course). \n"
"\n"
"We will add the theorem `16=4*4` to the proof state, and use it to prove the goal.\n"
"\n"
"Heres an example:\n"
"`have twoEqualstwo : 2=2 := by rfl` will add an object named `twoEqualstwo` of type `2=2` to the proof state which would look as follows:\n"
"```\n"
"Assumptions:\n"
"twoEqualstwo : 2=2\n"
"```\n"
"\n"
"You can choose any name after `have` and any type after `:`.\n"
"\n"
"For this problem, we want `16=4*4` instead of `2=2`.\n"
"Adapt this example to `16 = 4*4` and include after `by` its proof."
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "For the proof, we need to carry out the calculation of `4 * 4` and as in the previous level, the tactic for that is `norm_num`. Typing that as the proof will work."
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "Now, using `rw`, we want to replace the `16` in `h` with `4 * 4`."
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "`rw [¬´{helper}¬ª] at h`"
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "Using `mul_left_cancel‚ÇÄ`, cancel the `4` on both sides of `h` obtaining `y=4` which is the goal.\n"
"\n"
"For example, given the following proof state:\n"
"```\n"
"equation : 2*x = 2*3\n"
"```\n"
"`mul_left_cancel‚ÇÄ` is of the form:\n"
"```\n"
"mul_left_cancel‚ÇÄ firstArgument secondArgument\n"
"```\n"
"\n"
"The following expression cancels `3` from both sides of `equation`:\n"
"```\n"
"(mul_left_cancel‚ÇÄ two_ne_zero equation) : x =3 \n"
"```\n"
"\n"
"Note that:\n"
"```\n"
"two_ne_zero : 2 ‚â† 0\n"
"```\n"
"where 'ne' stands for not equal.\n"
"\n"
"Arguments are given without paranthesis\n"
"is the first argument given to `mul_left_cancel‚ÇÄ` and `equation` is the second.\n"
"\n"
"Adapt this to the current problem."
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "Notice that `mul_left_cancel‚ÇÄ four_ne_zero h` has type `y = 4`. So, `exact mul_left_cancel‚ÇÄ four_ne_zero h` will do it."
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "Here is the type signature of mul_left_cancel\\0:\n"
"  ```\n"
"  mul_left_cancel\\0 (ha : a ‚â† 0) (h : a * b = a * c) : b = c\n"
"  ```\n"
"  `mul_left_cancel‚ÇÄ` takes two arguments which are:\n"
"   - `ha`, a proof that some number `a` is not equal to zero. \n"
"   - `h`, the equation which has `a` on both sides of the equation multiplied on the left.\n"
"\n"
"  The result is canceling `a` from both sides of the equation."
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "[[mathlib_doc]]"
msgstr ""

#: Game.Levels.EquationalReasoning.L05_mul_left_cancel
msgid "### **Logic Constants & Operators**\n"
"### **Equational Reasoning**\n"
"| $Name~~~$ | $Ascii~~~$ | $Unicode$ | $Unicode Cmd$ |\n"
"| --- | :---: | :---: | --- |\n"
"|     |       |       | `mul_left_cancel\\0`|\n"
"| True | `True` |  |  |\n"
"| False | `False` |  |  |\n"
"| Not | `Not` | ¬¨ | `\\n` `\\not` `\\neg` `\\lnot` |\n"
"| And | `/\\` | ‚àß | `\\and` `\\an` `\\wedge` |\n"
"| Or | `\\/` | ‚à® | `\\v` `\\or` `\\vee` |\n"
"| Implies | `->` | ‚Üí | `\\r` `\\imp` `\\->` `\\to` `\\r-` `\\rightarrow` |\n"
"| Iff | `<->` | ‚Üî | `\\iff` `\\lr-` `\\lr` `\\<->` `\\leftrightarrow` |\n"
"| For All | `foral` | ‚àÄ | `\\all` `\\forall` |\n"
"| Exists | `exists` | ‚àÉ | `\\ex` `\\exists` |\n"
"\n"
"### **Other Unicode**\n"
"| $Name$ | $Unicode~~~$ | $Unicode Cmd$ |\n"
"| --- | :---: | --- |\n"
"| Angle brackets | ‚ü® ‚ü© | `\\<` `\\>` `\\langle` `\\rangle` |\n"
"| Subscript Numbers | ‚ÇÅ ‚ÇÇ ‚ÇÉ ... | `\\1` `\\2` `\\3` ... |\n"
"| Left Arrow | ‚Üê | `\\l` `\\leftarrow` `\\gets` `\\<-` |\n"
"| Turnstyle | ‚ä¢ | `\\‚îÇ-` `\\entails` `\\vdash` `\\goal` |\n"
"\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"Unicode & Text \\\\\n"
"\\hline\n"
"\\text{mul\\_left\\_cancel‚ÇÄ} & `mul\\_left\\_cancel\\0` \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"mul_left_cancel‚ÇÄ written as mul_left_cancel\\0"
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "Equational Reasoning"
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "In this world, you will learn how to solve equations."
msgstr ""

#: Game.Levels.LogicTruthValue_.L03_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.LogicTruthValue_.L03_Intro
msgid "This should look familiar.\n"
"\n"
"If it doesn't, then replace `P` by `x=2`.\n"
"\n"
"`hP` is of type `P` and `P` is of type `Prop`. So, `hP` is a proof of `P`. Our goal is to prove `P`. We already have such a proof which is `hP`, `hP` is EXACTLY what we need to prove the goal. The type of `hP` EXACTLY matches the goal."
msgstr ""

#: Game.Levels.LogicTruthValue_.L03_Intro
msgid "Type `exact hP`!"
msgstr ""

#: Game.Levels.LogicTruthValue_.L03_Intro
msgid "In the next levels, we will discuss how to construct new propositions from old ones whose meaning and truth value would depend on those old ones."
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "And"
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "In this level, we introduce the `‚àß` logical connective (read as 'and'). You can think of `‚àß` as taking to input proposition and outputting a new proposition.\n"
"\n"
"Remember the example given at the beginning of the world? We restate it here:\n"
"Given the two propositions `x=2`(`P`), `y=6`(`Q`) , we can construct a new propositon `x=2 ‚àß y=6`(`P ‚àß Q`) which is read as `x=2 and y=6`(`P and Q`).\n"
"\n"
"What is the truth value of this new proposition `x=2 ‚àß y=6`(`P ‚àß Q`)? \n"
"Well, it would depend on truth value of the two component propositions `x=2`(`P`) ,`y=6`(`Q`).\n"
"\n"
"What possibilities are there for each's truth value? `x=2` (`P`) can either be true or false and similarly for `y=6`(`Q`). Here is a truth table that goes through all these possibilities: \n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"x=2 & y=6 & x=2 ‚àß y=6 \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"\n"
"The proposition `x=2 ‚àß y=6`(`P ‚àß Q`) is true when `x=2`(`P`) is true AND `y=6`(`Q`) is true.\n"
"In other words, if `P` is true AND `Q` is true. This is how things work regarless of what `P` is, what `Q` is. The only thing that matters is their truth value.\n"
"Therefore, the more general truth table is the same:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"\n"
"Notice that `P ‚àß Q` is true when both `P` is true and `Q` is true, being false otherwise.\n"
"\n"
"\n"
"\n"
"From this, we conclude that we can introduce `‚àß` if we have a proof of `P` and a proof of `Q`. The `‚àß` introduction rule takes these two proofs giving us `P ‚àß Q`:\n"
"```\n"
"  And.intro  (left : P) (right : Q) : P ‚àß Q\n"
"```\n"
"\n"
"In this level, we have a proof of `P`(i.e `P` is true), and a proof of `Q` (i.e `Q` is true). We want to construct a proof of `P ‚àß Q`. \n"
"\n"
"The `‚àß` introduction rule is perfect for the job. We can use it to obtain an object that EXACTLY matches the goal."
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "Try `exact And.intro hP hQ` or `constructor`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "The constructor tactic transformed the goal `P ‚àß Q` into two subgoals the first being `P` and the second being `Q`. This way of doing things matches the meaning of the `‚àß` connective."
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "Notice that the goal is now `P`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid "After closing the goal `P`, you now have to close the goal `Q`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_And
msgid ""
msgstr ""

#: Game.Levels.LogicTruthValue_.L07_Or
msgid "Or, `‚à®`"
msgstr ""

#: Game.Levels.LogicTruthValue_.L07_Or
msgid "In this level, we introduce the `‚à®` logical connective read as 'or'.\n"
"\n"
"Its truth table is as follows:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚à® Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & T \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"From this truthtable, we conclude that we must be able to prove `P ‚à® Q`  if `P` is true or `Q` is true or both.\n"
"\n"
"You can tell Lean which side of `‚à®` you want to prove by simply executing 'left' or 'right'.\n"
"\n"
"------------\n"
"The `‚à®` introduction rule works as described above:\n"
"\n"
"The goal involves `‚à®`, and so (similar to `‚àß`) we need to use an introduction rule. Specifically, the `Or` introduction rule.\n"
"There are two `‚à®` introduction rules: \n"
"Or.intro_left {a : Prop} (b : Prop) (h : a) : a ‚à® b\n"
"\n"
"Curly braces are for implicit arguments that you don't have to enter, paranthesis are for explicit ones you have to enter. What this theorem means is that you enter the proposition you want to the right of `‚à®` and a proof of the proposition you want on the left. In other words, proving a proposition gives you `that prop ‚à® anything you want`......\n"
"\n"
"```\n"
"Or.intro_left (b : Prop) (h : a) : a ‚à® b\n"
"```\n"
"- `Or.intro_right`\n"
"```\n"
"Or.intro_right (a : Prop) (h : b) : a ‚à® b\n"
"```\n"
"\n"
"Pick the appropriate one."
msgstr ""

#: Game.Levels.LogicTruthValue_.L07_Or
msgid "Notice that in the type of `Or.intro_left`, you need to explicitly give the type that will be used to the right of the `‚à®` but you don't need to do this for the type to the left of `‚à®`. How does Lean what to do? Well, the type of `Or.intro_left` is in fact:\n"
"```\n"
"Or.intro_left {a : Prop} (b : Prop) (h : a) : a ‚à® b\n"
"```\n"
"The only difference is the curly braces. This means that `a` is an implicit argument. In other words, you don't need to give it explicitly, Lean will deduce it from the type of `h`. For example, if `h:P` where `P:Prop` then Lean will know that `a` is `P` and will put `P` to the left of `‚à®`.\n"
"\n"
"A similar explanation applies to `Or.intro_right` which has the type:\n"
"```\n"
"Or.intro_right {b : Prop} (a : Prop) (h : b) : a ‚à® b\n"
"```\n"
"\n"
"You can avoid entering both `a` or `b` explicitly and instead use: \n"
"```\n"
"Or.inl {a b : Prop} (h : a) : a ‚à® b\n"
"Or.inr {a b : Prop} (h : b) : a ‚à® b\n"
"```"
msgstr ""

#: Game.Levels.LogicTruthValue_.L09_Implication
msgid "Implication, ‚Üí"
msgstr ""

#: Game.Levels.LogicTruthValue_.L09_Implication
msgid "In this level, we introduce the logical implication `‚Üí` connective.\n"
"Logical implication `P ‚Üí Q` is made up of two components:\n"
"- The premise, which in this case is `P`\n"
"- The conclusion, which in this case is `Q`\n"
"\n"
"What logical implication does is that it takes evidence or proof for `P` and transforms it returning a proof of `Q`.\n"
"The truth of `P` IMPLIES the truth of `Q`. A proof of `P` IMPLIES a proof of `Q`.\n"
"\n"
"# truth table\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & T \\\\\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"A statement `P ‚Üí Q` is false when `P` is true and `Q` false, it's true otherwise."
msgstr ""

#: Game.Levels.LogicTruthValue_.L09_Implication
msgid "This is what is called an inference rule. It has two assumptions, `p : P` , `ptoq : P ‚Üí Q` and the conclusion `Q`. It is an inference rule because we 'infer' a certain conclusion from assumptions or already established theorems.\n"
"Usually presented in this format:"
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_ImpGoal
msgid ""
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_ImpGoal
msgid "The goal, translated to normal english is: 'If P is true, then P is true'.\n"
"\n"
"To prove such a goal, we need to assume that `P` is true. Then, we have to prove that `P` is true.\n"
"\n"
"To do this, we need to assume the premise i.e introduce it to our assumptions. We can do this using `intro`.\n"
"\n"
"After that , we have to prove the consequent."
msgstr ""

#: Game.Levels.LogicTruthValue_.L05_ImpGoal
msgid ""
msgstr ""

#: Game.Levels.LogicTruthValue_.L11_Not
msgid "Not Connective, ¬¨"
msgstr ""

#: Game.Levels.LogicTruthValue_.L11_Not
msgid "In this level we introduce the negation, the `¬¨` connective (read as 'not').\n"
"\n"
"Notice that this is the first logical connective that applies on one proposition only and not two.\n"
"\n"
"The job of this connective(as the name implies), is to negate a proposition meaning that:\n"
"- For `P` true, `¬¨P` is false.\n"
"- For `P` false, `¬¨P` is true.\n"
"\n"
"In truth table form:\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & ¬¨P \\\\\n"
"\\hline\n"
"T & F \\\\\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"But we don't need to introduce a new symbol, it can be defined in terms of what we already know.\n"
"\n"
"Consider the following truth table: \n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & P ‚Üí False \\\\\n"
"\\hline\n"
"T & F  \\\\\n"
"F & T  \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that regardless of the truth value of `P`, the two propositions `¬¨P` and `P ‚Üí False` have the same truth table. Therefore, they can be used interchangeably.(we say that these two expressions are logically equivalent, but let's leave this to a future level)\n"
"\n"
"In fact, this is how `¬¨P` is defined in Lean.\n"
"\n"
"`¬¨P` being true tells us that a proof of `P` gives us a proof of `False`. We have a proof of `P`. Therefore we can obtain a proof of `False` which is the goal."
msgstr ""

#: Game.Levels.LogicTruthValue_.L11_Not
msgid "In the next level, we will explore what it means to have proven `False`."
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "asdf"
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "We proved `False`, what does this mean? What can we conclude? What does `False` IMPLY?\n"
"\n"
"Let's check the `‚Üí` truth table:\n"
"$$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$$\n"
"\n"
"Let's focus on part of the truth table where `P` is `False`, because we want to see what `False` implies.\n"
"$$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"Q & False ‚Üí Q \\\\\n"
"\\hline\n"
"T & T \\\\\n"
"\\hline\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$$\n"
"\n"
"We have that the implication `False ‚Üí Q` is true regardless what `Q` represents and regardless whether `Q` is true or is false. \n"
"So `False` implies any proposition. This principle is known as: From contradiction anything follows.\n"
"\n"
"The tactic to achieve this is `contradiction`.\n"
"Having a proof of `False`, the `contradiction` tactic will always close the goal."
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "If you feel like seeing the implication definition of ¬¨ in the proof state would provide more clarity and make it easier to solve upcoming problems, you can always unfold ¬¨ to its implication form. Try `unfold Not at hnp`."
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "Now, this is just like the previous level"
msgstr ""

#: Game.Levels.LogicTruthValue_.L12_False
msgid "Such a system having `False` or a contradiction is called an inconsistent system.\n"
"The consequence of having `False` is the following. \n"
"\n"
"Any proposition is true and studying the current system becomes worthless."
msgstr ""

#: Game.Levels.LogicTruthValue_
msgid "Logic Truth Value_"
msgstr ""

#: Game.Levels.LogicTruthValue_
msgid "In this world, we will be dealing with `Objects` of type `Prop` i.e propositions. You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time). You have seen propositions before like `x=2`, `y=6` etc..\n"
"\n"
"When you have `h : P` where `P : Prop` , then we say `h` is a proof of the statement `P`(imagine `x=2` instead of `P` if you wish). \n"
"\n"
"In a proof state, this would look like the following:\n"
"```\n"
"Objects\n"
"P : Prop\n"
"Assumptions\n"
"h : P\n"
"```\n"
"\n"
"Moreover, we will discuss constructing new propositions from old ones.\n"
"\n"
"Here's an example in natural language, given the two propositions 'The sun is shining' , 'It is Monday', you can construct 'The sun is shining and it is monday'. \n"
"\n"
"Another example would be, having the following:\n"
"```\n"
"h : `x=2`\n"
"h' : `y=6`\n"
"```\n"
"where `P` is `x=2` and `Q` is `y=6`, we can construct a new proposition `P ‚àß Q` which is read as `x=2 and y=6`. Here we know what `P`,`Q` stand for. But, the proposition `P ‚àß Q` can still be constructed and reasoned about regardless. Think of reasoning about unknown numbers like `x`,`y` etc..."
msgstr ""

#: Game.Levels.LogicAlternative.L01_assumption
msgid "`assumption` tactic"
msgstr ""

#: Game.Levels.LogicAlternative.L01_assumption
msgid "Let's introduce the first 'automation' tactic. \n"
"The point behind such tactics is that there are tedious patterns of reasoning and automation tactics alleviate the burden of having to spell them out into Lean every time. \n"
"\n"
"Automations will sacrifice ... for brevity which is less tedious but might be more obfuscated.\n"
"\n"
"One pattern of reasoning you will almost always encounter is having an assumption of a type that 'exactly' matches the goal. The `exact` tactic suggests itself here, but you could just write `assumption`. The `assumption` tactic will use the assumptions in the proof state to prove the goal.\n"
"\n"
"Try it out!"
msgstr ""

#: Game.Levels.LogicAlternative.L01_assumption
msgid "Informally, the `assumption` tactic looks through the assumptions in the proof state and tries to find one which has a type that matches the goal through the assumptions in the proof state and tries to find one that which has a type that matches the goal. In this case, that would be `hP` and the type would be `P`.\n"
"\n"
"The `assumption` tactic is capable of alot more, but it will not be used in this game. You can read more about these capabilities in the right side pane documentation\n"
"\n"
"The advantage of the `assumption` tactic over exact is that you don't have to spell out the assumption to Lean. However, it might be clearer to explicity do so. This is the tradeoff between brevity and ..."
msgstr ""

#: Game.Levels.LogicAlternative.L02_constructorNotation
msgid "The `‚ü®‚ü©` notation"
msgstr ""

#: Game.Levels.LogicAlternative.L02_constructorNotation
msgid "`‚ü®‚ü©` is another way to introduce `‚àß`.\n"
"Consider the following proof state:\n"
"```\n"
"h1 : P\n"
"h2 : Q\n"
"```\n"
"If your and introduction looks like the following:\n"
"```\n"
"And.intro h1 h2\n"
"```\n"
"then the equivalent `‚ü®‚ü©` syntax is:\n"
"```\n"
"‚ü®h1,h2‚ü© \n"
"```\n"
"Both notations produce/construct an object of type `P ‚àß Q`"
msgstr ""

#: Game.Levels.LogicAlternative.L02_constructorNotation
msgid ""
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "Or"
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "In this level, you will learn about the `Or` logical connective.\n"
"\n"
"# truth table\n"
"```\n"
"| P | Q | P ‚à® Q  |\n"
"|---|---|--------|\n"
"| T | T |   T    |\n"
"| T | F |   T    |\n"
"| F | T |   T    |\n"
"| F | F |   F    |\n"
"```\n"
"\n"
"From the truth table, we can see that if one of `P`,`Q` is true then `P ‚à® Q` is true. \n"
"Therefore, if we have `P ‚à® Q` as our goal, it is enough to prove `P` or to prove `Q`.\n"
"This is exactly what the `left` and `right` tactic does. \n"
"The `left` tactic transforms our goal from `P ‚à® Q` to `P` and similarily for the `right` tactic. This is because Lean understands that if `P` is true, then `P ‚à® Q` is true."
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "Use either `left` or `right`"
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "`p` is exactly the goal"
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid "`q` is exactly the goal"
msgstr ""

#: Game.Levels.LogicAlternative.L03_Or
msgid ""
msgstr ""

#: Game.Levels.LogicAlternative.L04_apply
msgid "`apply` tactic"
msgstr ""

#: Game.Levels.LogicAlternative.L04_apply
msgid "The `apply` tactic takes an implication as its argument where the conclusion of the implication matches the goal.\n"
"Here is how `apply` 'thinks', and how it transforms the proof state:\n"
"Since we can conclude the conclusion of the implication which is also our goal from its premise, our new goal becomes the premise. In a sense, the `apply` tactic sets up modus ponens for you and the missing piece is proving the premise of the implication\n"
"\n"
"remember the X Y problem"
msgstr ""

#: Game.Levels.LogicAlternative.L04_apply
msgid ""
msgstr ""

#: Game.Levels.LogicAlternative.L04_apply
msgid "The apply tactic takes a proof of a general statement or implication, tries to match the conclusion with the current goal,\n"
"and leaves the hypotheses, if any, as new goals. If the given proof matches the goal exactly (modulo definitional equality),\n"
"you can use the exact tactic instead of apply. So, all of these work:"
msgstr ""

#: Game.Levels.LogicAlternative
msgid "This world will have the same exercises as the previous `Logic` world, but the difference will be the tactics used to solve them, which will change the reasoning process."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "Before diving into an actual knights and knaves puzzle, lets explore basic results implied by the assumptions of this puzzle.\n"
"\n"
"We will first look at the assumption that no one can be a knight and a knave at the same time.\n"
"It is represented as:\n"
"```\n"
"h : left ‚à© right = ‚àÖ \n"
"```\n"
"\n"
"In our problem, we have:\n"
"```\n"
"Aleft: A ‚àà left\n"
"Aright: A ‚àà right\n"
"```\n"
"This means that `A` belongs to both `left` and `right` i.e `A ‚àà left ‚à© right`. This would contradict `h` giving us `False` which is the goal.\n"
"\n"
"To show `A ‚àà left ‚à© right`, use the following\n"
"```\n"
"Finset.mem_inter : a ‚àà s‚ÇÅ ‚à© s‚ÇÇ ‚Üî a ‚àà s‚ÇÅ ‚àß a ‚àà s‚ÇÇ\n"
"```\n"
"Use `have` so it would be added to the assumptions.\n"
"\n"
"use hint to do rw\n"
"\n"
"--------------------\n"
"You need to show that having two sets being disjoint (i.e sharing no common element) and having a common element is a contradiction.\n"
"-- more general setting\n"
" This is not an obvious contradiction( like p , ¬¨p) for the `contradiction` tactic to work. Some work needs to be done to get to that point.\n"
"\n"
"Hint: the goal is to get something that contradicts not_mem_empty. Since x belong to Knight and Knave then it belongs to their intersection which is equal to the empty set contradiction not_mem_empty. Let's do this step by step. (Make it feel like the player discovered this:\n"
"Notice that the only information we can derive is that x is in the intersection. Do we have information about the intersection? Well yes. its empty set so x ‚àà empty set. Execute the finishing blow."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "dis22"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "We know that `left ‚à© right = ‚àÖ`, so replace it with `‚àÖ` using `rw` getting `A ‚àà ‚àÖ`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "Remember that the empty is the set with no elements by definition. But we have found one, namely `A`. This directly contradicts the definition of `‚àÖ` so `contradiction` will work here."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "This works for any two disjoint sets, specifically the two sets `Knight`,`Knave`.\n"
"\n"
"Even if we didn't have `A_not_in_empty` in the assumptions, `contradiction` would have worked here because Lean knows the following theorem: \n"
"```\n"
"Finset.not_mem_empty.{u_1} {Œ± : Type u_1} (a : Œ±) : a ‚àâ ‚àÖ\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "We will use this to prove several helpful lemmas in the context of the knights and knaves puzzle. Note that these lemmas apply to any two sets.\n"
"\n"
"The reasoning goes as follows:\n"
"Assume `A ‚àà right`.\n"
"Then `A ‚àà left ‚à© right` \n"
"But `left ‚à© right = ‚àÖ `, so `A ‚àà ‚àÖ`. \n"
"This is a contradiction"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "Assume `A ‚àà right` using `intro`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "Look familiar?"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_Knight_NotKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_Knight_NotKnave
msgid "Note that this level is identical to the previous one except the fact that the set `left` is now called `Knight` and the set `right` is now called `Knave`. This level is to emphasize this pattern of reasoning that you will need to solve knights and knaves puzzles.\n"
"\n"
"If you are a knight, then you are definitely not a knave. Recall that knights always tell the truth and knaves always lie."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_Knight_NotKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_inright
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_inright
msgid "This has a very similar reasoning to inleft.\n"
"\n"
"The reasoning goes as follows:\n"
"Assume `A ‚àà left`.\n"
"Then `A ‚àà left ‚à© right` \n"
"But `left ‚à© right = ‚àÖ `, so `A ‚àà ‚àÖ`. \n"
"This is a contradiction"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_inright
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knave_NotKnight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knave_NotKnight
msgid "Note that this is just like the previous level."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knave_NotKnight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_notinright
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_notinright
msgid "Remember notright_left from logic world. You can go back if you wish before proceeding with this level: link to prev level."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_notinright
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_NotKnave_Knight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_NotKnave_Knight
msgid "Before starting the riddles, some new concepts have to be clarified.\n"
"It is obvious that no one can be a knight and a knave at the same time. If some is not a knave then they are a knight.\n"
"\n"
"You need to show that having two sets being disjoint (i.e sharing no common element) and having a common element is a contradiction.\n"
"\n"
"For the contradiction \n"
"This is not an obvious contradiction (like p , ¬¨p) for the `contradiction` tactic to work. \n"
"Some work needs to be done to get to that point.\n"
"We can get that `A ‚àà ‚àÖ` and we know that\n"
"```\n"
"Set.not_mem_empty.{u} {Œ± : Type u} (x : Œ±) : x ‚àâ ‚àÖ\n"
"```\n"
"\n"
"Hint: the goal is to get something that contradicts not_mem_empty. Since x belong to Knight and Knave then it belongs to their intersection which is equal to the empty set contradiction not_mem_empty. Let's do this step by step. (Make it feel like the player discovered this:\n"
"Notice that the only information we can derive is that x is in the intersection. Do we have information about the intersection? Well yes. its empty set so x ‚àà empty set. Execute the finishing blow."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_NotKnave_Knight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.notinleft
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.notinleft
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.notinleft
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_NotKnight_Knave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_NotKnight_Knave
msgid "Similar to the previous level"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_NotKnight_Knave
msgid "Let's recap what we have proven in the last four levels.\n"
"\n"
"Given the following proof state:\n"
"```\n"
"(Knight : Set K ) (Knave : Set K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h'' : ‚àÄ (x: K), x ‚àà Knight ‚à® x ‚àà Knave)\n"
"```\n"
"\n"
"\n"
"We can conclude the following implications:\n"
"A ‚àà Knight ‚Üí A ‚àâ Knave  \n"
"A ‚àâ Knave ‚Üí A ‚àà Knight\n"
"which can be combined into: A ‚àà Knight ‚Üî A ‚àâ Knave (let the user actually do one of them)\n"
"Similarly for the other two levels, we can conclude A ‚àâ Knight ‚Üî A ‚àà Knave\n"
"\n"
"These two theorems will be very useful in the following world.\n"
"\n"
"------------------------\n"
"\n"
"We have proven:\n"
"```\n"
"(Knight : Set K) (Knave : Set K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h' : A ‚àà Knight)\n"
"  : A ‚àâ Knave \n"
"\n"
"\n"
"\n"
"(Knight : Set K ) (Knave : Set K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h' : ¬¨ (B ‚àà Knave))\n"
"(h'' : ‚àÄ (x: K), x ‚àà Knight ‚à® x ‚àà Knave)\n"
"  :  B ‚àà Knight := by\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas
msgid "Knights and Knaves, lemmas"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas
msgid "We will introduce the knights and knaves puzzle here. In this world, you will have to prove basic but important lemmas which will be used in the world after this one to solve actual knights and knaves puzzles.\n"
"\n"
"The setting is an island  in which certain inhabitants called 'knights' always tell the truth, and others called 'knaves' always lie.\n"
"\n"
"Every inhabitant is either a knight or a knave, there is no third option. Formally:\n"
"```\n"
"A ‚àà Knight ‚à® A ‚àà Knave.\n"
"```\n"
"\n"
"Let `Knight` be the set of inhabitants that are knights, i.e always tell the truth.\n"
"Let `Knave` be the set of inhabitants that are knaves, i.e always lies.\n"
"In a proof state, this would look like:\n"
"```\n"
"Objects\n"
"Knight Knave : Finset Inhabitant\n"
"```\n"
"`Knight` is a finite set where its elements are of type `Inhabitant` and these elements satisfy the propery of always telling the truth.\n"
"`Knave` is a finite set where its elements are of type `Inhabitant` and these elements satisfy the property of always lying.\n"
"\n"
"Since knights always tell the truth and knaves always lie, no inhabitant can be both a knight and a knave. So the intersection of the two sets is empty i.e `Knight ‚à© Knave = ‚àÖ`. We say the two sets Knight Knave are disjoint.\n"
"\n"
"The statement `A ‚àà Knight` is read as: `A` belongs to the finite set `Knight`(`A in Knight`), and it should be understood as 'A IS Knight' i.e 'A' always tells the truth.\n"
"Similarly, the statement `A ‚àâ Knight` is read as: `A` doesn't belong to the finite set `Knight`(`A not in Knight`), and it should be understood as 'A ISNOT Knight'.\n"
"The same reasoning applies to `x ‚àà Knave`, `x ‚àâ Knave`.\n"
"\n"
"The objective is to conclude who is a knight and who is a knave, based on the statements of several inhabitants. This will be done using logical reasoning. Every inhabitant will make at most one statement.\n"
"\n"
"get a taste:\n"
"Logic Puzzles: Knights and Knaves - YouTube\n"
"https://www.youtube.com/watch?v=jY6dvQUHIOs"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "Let's solve the previously mentioned 'I am a knave' puzzle.\n"
"\n"
"Suppose we have an inhabitant A which says: \n"
"A : 'I am a knave.'\n"
"\n"
"Merely uttering this statement is a contradiction. This is equivalent to the liars paradox(https://en.wikipedia.org/wiki/Liar_paradox). A saying 'I am a knave' is like A saying 'I am a liar' or 'I am lying'. \n"
"\n"
"If `A` were telling the truth(i.e a knight), then `A` would be lying which is a contradiction. \n"
"\n"
"Similarly if `A` were lying(i.e a knave) then A would be telling the truth. \n"
"\n"
"Regardless of what A is, we fall into contradiction. The proof will take all cases for A, which are either the fact of always telling the truth(Knight) or always lying(Knave) and will show this contradiction.\n"
"\n"
"Remember that `A` is either a knight or a knave, represented by `h1` , and our reasoning was taking every case and showing that we reach the same conclusion in both(which is a contradiction i.e `False`). This is known as a proof by cases.\n"
"\n"
"For this, we need the `cases` tactic. Try `cases h1` and see what happens"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "Notice that `h1` is now replaced by `h_1`, and we have two goals to prove instead of one. \n"
"The difference between each is that in the first, A is a knight(`h_1 : A ‚àà Knight`) and in the second A is a knave(`h_1 : A ‚àà Knave`).  \n"
"\n"
"Combine the statement of `A` and the fact `A` is a knight to conclude the truth of `A`'s statement."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "So now we have that A is a knave, in addition to what we already knew (A being a knight). \n"
"\n"
"But this contradicts the fact that these two sets are disjoint."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "Three of the inhabitants A, B, and C were standing together in a garden. \n"
"A stranger passed by and asked A, 'Are you a knight or a knave?' A answered, but rather indistinctly, so the stranger could not make out what he said. The stranger than asked B, 'What did A say?' B replied, 'A said that he is a knave.' At this point the third man, C, said, 'Don't believe B; he is lying!' \n"
"The question is, what are B and C?\n"
"\n"
"First of all, lets simplify the statements. C's statement can be simplified to 'B is a knave.'\n"
"\n"
"The formalization is given. Note that for the statement of B, if B where telling the truth then A indeed made such a statement which is the statement 'I am a Knave' and the formalization of that is 'A ‚àà Knight ‚Üî A ‚àà Knave'. Use IamKnave."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "We know that `A` saying 'I am a knave' leads to contradiction. So assuming that 'B' is a knight would lead to contradiction. So `B` is not a knight. To arrive at this conclusion formally, first you can prove the right hand side of stBn which would then give you B ‚àà Knave.\n"
"\n"
"Most of the work here has already been done, we have the following theorem from the previous level(ignoring implicit arguments): \n"
"IamKnave : Knight ‚à© Knave = ‚àÖ ‚Üí A ‚àà Knight ‚à® A ‚àà Knave ‚Üí (A ‚àà Knight ‚Üî A ‚àà Knave) ‚Üí False\n"
"\n"
"notice that ..."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "A says I am a knave or B is a knave. Notice stAn, which represents the fact that A's statement is false when A is a knave ( and viceversa of course). So the statement 'A is a knave or B is a knave' is false. What does it mean for an or expression to be false. It means that both sides are false.\n"
"\n"
"\n"
"--------------------- put these in hints\n"
"If A is a knave, then the statement 'A is a knave or B is a knave' is false which means that A is not a knave and B is not knave. A is not a knave but we previously assumed that A is a knave. Assuming A is a knave gives us a contradiction which means that A is not a knave.\n"
"\n"
"This is the first part of the proof.\n"
"\n"
"Now that we know that A is not a knave, then A is a knight. So we can conclude A is a knave or B is a knave. Since A is not a knave, we are left with one option which is B being a knave.\n"
"\n"
"This concludes the proof."
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "Suppose A says, 'I am a knave, but B is not.' \n"
"What are A and B?"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob28
msgid "lev 2"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob28
msgid "In this problem, there are only two people, A and B, each of \n"
"whom is either a knight or a knave. A makes the following \n"
"statement: 'At least one of us is a knave.' \n"
"What are A and B?"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob28
msgid "."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob31
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob31
msgid "Again we have three people, A, B, C, each of whom is either \n"
"a knight or a knave. A and B make the following statements: \n"
"A: All of us are knaves. \n"
"B: Exactly one of us is a knight. \n"
"What are A, B, C?"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob31
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob32
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob32
msgid "Suppose instead, A and B say the following: \n"
"A: All of us are knaves. \n"
"B: Exactly one of us is a knave. \n"
"Can it be determined what B is? Can it be determined what C is?"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob32
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves
msgid "Knights And Knaves"
msgstr ""

#: Game.Levels.KnightsAndKnaves
msgid "It is recommended to solve the problems in this world while in editor mode, though you have the choice not to. Levels with longer solutions will force editor mode.\n"
"\n"
"Suppose the island has an inhabitant `A` which says the following statement,\n"
"A : 'I am a knave'\n"
"Remember that if `A` were a knight, then `A`'s statement is true. this can be translated to an implication: `A ‚àà Knight ‚Üí A ‚àà Knave`\n"
"If `A`'s statement were true, then `A` is telling the truth so `A` must be a knight. `A ‚àà Knave ‚Üí A ‚àà Knight`\n"
"The two can be combined as `A ‚àà Knight ‚Üî A ‚àà Knave`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Intro"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "A: B is a knight and C is a knight.\n"
"\n"
"B: C is a knight and A is a knave.\n"
"\n"
"The reasoning that gives us `¬¨A` is as follows:\n"
"Assuming `A` is true:\n"
"- `B ‚àß C` from `stA` using `A`\n"
"- `C ‚àß ¬¨A` from `stB` using `B`\n"
"- `False` from `A`,`¬¨A`.\n"
"\n"
"The reasoning that gives us `¬¨C` is as follows:\n"
"Assuming `C` is true:\n"
"- `B` from `stB` using `C ‚àß ¬¨A`\n"
"- `A` from `stA` using `B ‚àß C`\n"
"- `False` from `A`,`¬¨A`\n"
"\n"
"Using `¬¨C`, we get `¬¨C ‚à® A` which gives `¬¨B` using `stBn`.\n"
"\n"
"You have the freedom of doing whatever(or maybe impose something using Template).\n"
"\n"
"use template"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid "A: C is a knight or B is a knight.\n"
"B: A is a knight, if and only if C is a knight.\n"
"\n"
"Assuming ¬¨A,\n"
"¬¨C ‚àß ¬¨B from stAn\n"
"¬¨(A ‚Üî C) from stBn\n"
"(A ‚Üî C) from ¬¨A, ¬¨C\n"
"False from ¬¨(A ‚Üî C) , (A ‚Üî C)\n"
"\n"
"Notice that ¬¨A means ¬¨C, ¬¨B where ¬¨B gives that A and C dont have the same type. This is a contradiction of course so the proposition ¬¨A is not true which means that A is true.  \n"
"\n"
"Now we know A, which gives C ‚à® B\n"
"¬¨B means C, and it also means ¬¨(A ‚Üî C). But we know A ‚Üî C from A,C so we get a contradiction.\n"
"\n"
"lets take cases for C ‚à® B. Having C gives us (A ‚Üî C) which gives us B. So we get as a final answer, A ‚àß B ‚àß C. \n"
"Having B, we get that (A ‚Üî C) which gives us C. The final answer is A ‚àß B ‚àß C.\n"
"\n"
"Now we know A,B. From B we get that A ‚Üî C, which means C.\n"
"\n"
"Now we know A,B,C."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "similar explanation to lvl 2"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "A: B is a knight or C is a knight.\n"
"B: C is a knave, if and only if A is a knave"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "Knights and Knaves, second approach"
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "In this world, we deal with the knights and knaves puzzle but the difference is how we translate and represent the problem in Lean.(an arguably cleaner representation/translation)\n"
"\n"
"The setup is as follows:\n"
"We exploit the binary nature of an inhabitant. An inhabitant can be either/or. There are two options and no third, either a knight or a knave. So, we declare as variables a proposition for every inhabitant. Say we have three inhabitants A,B,C , we declare the following propositions:\n"
"```\n"
"variable {A B C : Prop}\n"
"```\n"
"Now we intrepret having a proof of `A` as `A` being a knight, and having a proof of `¬¨A` as `A` being a knave.\n"
"\n"
"The translation of statements made by each inhabitant into a propositional formula remains the same, using `‚Üî` but of course instead of `A ‚àà Knight` we just have `A` and instead of `A ‚àà Knave` we just have `¬¨A`.\n"
"\n"
"-- correspondence\n"
"Notice that there are no explicit assumptions in this representation, but that doesn't mean that this representation is less faithful. We know that any proposition is either true or false, in our context this would translate to every inhabitant is either a knight or a knave. Moreoever, we know that p ‚àß ¬¨p is false, which would translate to the fact that no inhabitant can be both a knight or a knave(which within the previous representation of finite sets, would mean that the set knight and the set knave are disjoint). \n"
"we can also do 1's and zero's stuff, more related to smt solvers. if your interestedyou can check this really short video that would present the idea.\n"
"include these videos:\n"
"knights and knaves prolog - Invidious\n"
"https://yewtu.be/search?q=knights+and+knaves+prolog\n"
"\n"
"\n"
"Knights and Knaves in Prolog - YouTube\n"
"https://www.youtube.com/watch?v=oEAa2pQKqQU\n"
"\n"
"\n"
"All puzzles were generated(and possibly modified) from https://www.wolframcloud.com/objects/demonstrations/KnightsAndKnavesPuzzleGenerator-source.nb."
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.IamKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.IamKnave
msgid "A : I am  knave"
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.IamKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.prob39
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.prob39
msgid "We are given three people, A,B,C, one of whom is a knight, one a knave, and one normal (but not necessarily in that order). \n"
"They make the following statements: \n"
"A: I am normal. \n"
"B: That is true. \n"
"C: I am not normal."
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.prob39
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.prob40
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.prob40
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.prob40
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.prob41
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.prob41
msgid "A: B is a knight. \n"
"B: A is a knave,"
msgstr ""

#: Game.Levels.KnightsAndKnaves.KnightsKnavesNormals.prob41
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesAndNormals
msgid "Knights And Knaves"
msgstr ""

#: Game.Levels.KnightsAndKnavesAndNormals
msgid ""
msgstr ""

#: Game
msgid "Reasoning"
msgstr ""

#: Game
msgid "This is a gamification of mathematical proofs. Every level has a `Goal`, which is what you are trying to prove. Closing the `Goal` means you have proved the theorem and there is nothing else to do.\n"
"\n"
"You will use the `Lean` theorem prover, and its mathematical library `mathlib`.\n"
"\n"
"# Right Side Pane\n"
"Let's explain what's going on in the right side pane.\n"
"\n"
"This is where you can find the tactics, definitions, and theorems at your disposal which were introduced in previous levels.\n"
"\n"
"Clicking on one will display an overview and some examples. This will be available to you at all times when working on the levels. Refer back to it whenever you need to.\n"
"\n"
"Any new tactic, theorem, or definition introduced in a level will be highlighted in a yellow color.\n"
"\n"
"We know discuss each section in the right side pane.\n"
"## Tactics\n"
"In this puzzle game, you will use tactics to manipulate the `Goal` and close it, essentially proving the `Goal`. Tactics will be incrementally introduced, and tactics that haven't been introduced yet will have a lock icon which means you can't use them yet. \n"
"\n"
"## Definitions\n"
"The point of this game is not just to showcase ***Lean***, but also to learn some mathematics. Relevant definitions will be displayed here.\n"
"\n"
"## Theorems\n"
"Here is listed theorems to use throughout the levels. Some you would have proved in previous levels and others are presented for you to use but without having proved them. An intuitive definition of why the theorem makes sense will be presented as well when it is introduced.\n"
"\n"
"# Level Structure\n"
"Within every level, you have the `Objects`(if any), `Assumptions`(if any), and `Goal` for the current level. This is called the initial proof state. \n"
"\n"
"There will also be a text input to execute tactics accordingly.\n"
"\n"
"***Lean*** tracks the proof state as you execute tactics and makes sure you made no mistakes.\n"
"You will execute tactics one by one until Lean tells you that you have closed the goal.\n"
"\n"
"# More info\n"
"You can click the hamburger menu in the top right then 'Game Info' for more information."
msgstr ""

#: Game
msgid "For example: Game version, Credits, Link to Github and Zulip, etc.\n"
"\n"
"Many technical details have been skipped for the sake of not getting bogged down with Lean and its mathematical library mathlib, but focus on the aspects of reasoning and proof. You can visit https://leanprover-community.github.io/mathlib4_docs/ for more information about any tactic used by searching `Mathlib.Tactic.tacticname`, and theorems.\n"
"\n"
"Zulip chat for lean has been a very useful resource to resolve issues when formalizing the exercises, you can visit it and ask questions in the '#new members' stream. You can also view messages without signing up. There are other streams dedicated to various topics you can check out as well. \n"
"\n"
"# Editor Mode \n"
"## copy and paste your solutions somewhere else\n"
"Some levels will force you to use editor mode. Editor mode is necessary for multiline tactics. Moreover, you should get used to it because it mimics a vscode Lean environment which is the most common way Lean is run.\n"
"\n"
"To access editor mode, click on the icon to the left of the hamburger menu in the top right.\n"
"You can copy and paste your solutions if you have Lean setup, or you can use the lean web editor: https://live.lean-lang.org/ if you want to experiment with your solutions outside the lean game.\n"
"Make sure to have `import Mathlib.Tactic` at the top and then to copy whats above the editor area which is the problem statement. Each problem statement is of the form `example ... :=  by` and after that is where your solution should go.\n"
"\n"
"## vscode like environment\n"
"Hovering over things will give you useful information.\n"
"# Links \n"
"https://leanprover-community.github.io/\n"
"https://lean-lang.org/\n"
"https://lean-lang.org/documentation/\n"
"\n"
"https://github.com/leanprover-community/mathlib4\n"
"\n"
"https://leanprover.zulipchat.com/\n"
"https://zulip.com/case-studies/lean/\n"
"\n"
"# how to navigate documentation\n"
"You can use https://leanprover-community.github.io/mathlib4_docs/ for Lean and mathlib related documentation. You can see 'Lean', 'Mathlib' in the left side pane, clicking on either will expand them. A more effective way of finding what you want is using the search feature of this page , using 'Go To Definition' if you have vscode setup for Lean and mathlib, or hovering over things to get more information\n"
"\n"
"-- consider removing # Rules\n"
"# Rules\n"
"You can relax the rules.\n"
"\n"
"This is not recommended for people who have never heard about Lean before. Moreover, relaxing the rules would ruin the coherence and structured/guided experience you would have when playing the game normally. If that is what you are looking for, then don't relax the rules."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
