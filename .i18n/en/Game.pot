msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Tue Apr 15 11:48:38 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Doc.doc
msgid "## Implication defintion\n"
"`¬P` is equivalent to `P → False`\n"
"\n"
"Given\n"
"```\n"
"hnP : ¬P\n"
"```\n"
"unfold Not at hnP will result in:\n"
"```\n"
"hnP : P → False\n"
"```\n"
"\n"
"## truth table\n"
"$\n"
"\\begin{array}{|c c|} \n"
"\\hline\n"
"P & ¬P \\\\\n"
"\\hline\n"
"T & F \\\\\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that this definition is an implication and that the truth table with `¬P` and the truth table with `P → False` are identical.\n"
"\n"
"What this means is that to prove `¬P`, we assume `P` and derive a contradiction i.e constructing an object of type `False`. \n"
"In other words, having `¬P` as a goal, you have to start the proof with `intro` because you are proving an implication."
msgstr ""

#: Game.Doc.doc
msgid "Proving `False` means deriving a contradiction.\n"
"\n"
"A contradiction is when `P` and `¬P` are both true. We say that `P` and `¬P` contradict each other.\n"
"\n"
"# Principle of explosion, from `False` anything follows.\n"
"This principle asserts that if you have contradictory assumptions then you can prove anything.\n"
"```\n"
"hP: P\n"
"hnP: ¬P\n"
"```\n"
"Since `hnP : ¬P` is `P → False` , we can obtain `hnP hP : False`.\n"
"\n"
"Moreover, we know that `hFQ : False → Q` for any `Q : Prop` and so `hFQ (hnP hP) : Q`. (using `contradiction` after having proven `False` will close any goal as well)"
msgstr ""

#: Game.Doc.doc
msgid "You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time).\n"
"\n"
"Moreover, these statements are denoted by a symbol like `P`,`Q`,`R`.\n"
"\n"
"For an object of type `P` where `P` is of type Prop, i.e `h : P` where `P : Prop`, `h` would be a proof or a witness that `P` is true.\n"
"\n"
"# Constructing new propositions from old ones\n"
"The atomic propositions in the compound proposition `p ∧ q` are : `p`, `q`. Of course, `p ∧ q` can be used to construct more complicated propositions.\n"
"\n"
"## Connecting Propositions With A Logical Connective\n"
"This truth value depends on the truth value of the propositions it was built out of and the rules of the logical connective. This is clearly illustrated in a truth table. \n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects."
msgstr ""

#: Game.Doc.doc
msgid "Logical implication `P → Q` is made up of two components:\n"
"- The premise, which in this case is `P`\n"
"- The conclusion, which in this case is `Q`\n"
"\n"
"P → Q is read as 'If P is true, then Q is true.\n"
"\n"
"# truth table\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P → Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\\\\\n"
"\\hline\n"
"F & T & T \\\\\\\\\n"
"\\hline\n"
"F & F & T \\\\\\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"A statement `P → Q` is false when `P` is true and `Q` false, it's true otherwise.\n"
"\n"
"# Implication as a function\n"
"What logical implication does is that it takes evidence or proof for `P` and transforms it returning a proof of `Q`.\n"
"The truth of `P` IMPLIES the truth of `Q`. A proof of `P` IMPLIES a proof of `Q`.\n"
"\n"
"In other words, it acts like a function. If you give `P → Q` a proof of `P`, you get a proof of `Q`."
msgstr ""

#: Game.Doc.doc
msgid "`∧`\n"
"Truth table:\n"
"\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P and Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects.\n"
"The following truth table illustrates this for the previously discussed `∧` connective.\n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P and Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & F \\\\\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that `P and Q` is true when both `P` is true and `Q` is true, being false otherwise."
msgstr ""

#: Game.Doc.doc
msgid "`∨`\n"
"\n"
"# Truth Table\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P or Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & T \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"From the truth table, we can see that if one of `P`,`Q` is true then `P ∨ Q` is true. \n"
"\n"
"Therefore, if we have `P or Q` as our goal, it is enough to prove `P` or to prove `Q`.\n"
"\n"
"Having `P or Q` as the goal, you can tell Lean that you want to prove the left side by simply typing `left` or the right side by simply typing `right`."
msgstr ""

#: Game.Doc.doc
msgid "`∩` is an operator on sets.\n"
"\n"
"Applying it to two sets `A`,`B`:\n"
"```\n"
"A ∩ B\n"
"```\n"
"\n"
"`A ∩ B` is itself another set, containing elements that are in both `A` and `B`.\n"
"In other words, `x ∈ A ∩ B ↔ x ∈ A ∧ x ∈ B`.\n"
"\n"
"`A ∩ B = ∅` means that `A` and `B` have no common element i.e no element of `A` belongs to both and no element of `B` belongs to both.\n"
"In other words, `x ∈ A → x ∉ B` , `x ∈ B → x ∉ A` which are `inleft_notinright` and `inright_notinleft` respectively."
msgstr ""

#: Game.Doc.doc
msgid "The theorem `And.intro` takes a proof of `P`, a proof of `Q`, and gives a proof of `P ∧ Q` where `P Q : Prop`.\n"
"\n"
"Given,\n"
"```\n"
"hP : P\n"
"hQ : Q\n"
"```\n"
"we have `And.intro hP hQ : P ∧ Q`"
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid "Another way to express this is that you have two possibilities one of which(or both) is supposed to be true, and you know its definitely not the second option. All is left is the first option. \n"
"\n"
"Given the statement, its either 'this' or 'that'. If we know its not 'that' then its definitely 'this'."
msgstr ""

#: Game.Doc.doc
msgid "```\n"
"theorem inleft_notinright\n"
"(h : left ∩ right = ∅ )\n"
"(Aleft : A ∈ left)\n"
": A ∉ right\n"
"```\n"
"\n"
"Given the following proof state:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"left right : Finset Inhabitant\n"
"\n"
"Assumptions\n"
"h : left ∩ right = ∅\n"
"Aleft : A ∈ left\n"
"\n"
"Goal\n"
"A ∉ right\n"
"```\n"
"\n"
"exact `inleft_notinright h Aleft` will close the goal."
msgstr ""

#: Game.Doc.doc
msgid "```\n"
"theorem disjoint\n"
"(h : left ∩ right = ∅ )\n"
"(Aleft : A ∈ left)\n"
"(Aright : A ∈ right)\n"
": False\n"
"```\n"
"\n"
"Given the following proof state:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"left right : Finset Inhabitant\n"
"\n"
"Assumptions\n"
"h : left ∩ right = ∅ \n"
"Aleft : A ∈ left\n"
"Aright : A ∈ right\n"
"\n"
"Goal\n"
"False\n"
"```\n"
"\n"
"`exact disjoint h Aleft Aright` will close the goal"
msgstr ""

#: Game.Doc.doc
msgid "A summary of all the terminology presented throughout the game, in order of appearance.\n"
"\n"
"Theorems represent an implication say:\n"
"```\n"
"thm : P → Q\n"
"```\n"
"\n"
"They work for `P`,`Q` of any type. What `thm` means is the following, give me an object of type `P` and i will return an object of type `Q`. \n"
"\n"
"Therefore, theorems expect arguments given in a specific order after which the obtained expression is an object which has the conclusion as its type.\n"
"\n"
"For\n"
"```\n"
"thm : P → Q\n"
"hP : P\n"
"```\n"
"`(thm hP) : Q`\n"
"\n"
"For the special case where `P : Prop`, `Q : Prop` ,the interpretation of `thm` is what implication in logic means.\n"
"\n"
"What `thm` means is the following, give me an object of type `P` which in this case is a proof of `P` and i will return an object of type `Q` which in this case is a proof of `Q`.\n"
"\n"
"In other words, `thm` means 'If P is true, then Q is true'."
msgstr ""

#: Game.Doc.doc
msgid "## Definition\n"
"A set is a collection of 'entities' or 'objects' that satisfy a certain property. The objects in a set are called 'elements' of the set.\n"
"\n"
"A finite set is a set with finitely many elements.\n"
"\n"
"## Examples\n"
"The set `Knight` would be the set of inhabitants of the island that are knights i.e satisfying the property of always telling the truth, the set `Knave` being the set of inhabitants of the island that are knaves i.e the ones that always lie.\n"
"\n"
"## In Lean\n"
"\n"
"```\n"
"Set K\n"
"Set Inhabitant\n"
"```\n"
"\n"
"```\n"
"Finset K\n"
"Finset Inhabitant\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid "Given the following proof state:\n"
"```\n"
"left : Finset K\n"
"```\n"
"\n"
"`A ∈ left` read as 'A in left'.\n"
"\n"
"`A ∉ left` read as 'A not in left' means `¬(A ∈ left)` , `A ∈ left → False`."
msgstr ""

#: Game.Doc.doc
msgid "## Objects\n"
"\n"
"The objects involved are:\n"
"- of type inhabitant indicated by a capital letter\n"
"- the two finite sets `Knight` , `Knaves`.\n"
"\n"
"As a proof state:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"B : Inhabitant \n"
"C : Inhabitant\n"
"Knight : Finset Inhabitant\n"
"Knave : Finset Inhabitant\n"
"```\n"
"There will be at most three inhabitants in the puzzles for simplicity, but you can ofcourse have more.\n"
"\n"
"## Assumptions\n"
"Knights tell the true and knaves lie. So no one can be both at the same time i.e `Knight ∩ Knave = ∅`\n"
"\n"
"Moreover, every inhabitant is either a knight or a knave i.e `A ∈ Knight ∨ A ∈ Knave` for any `A : Inhabitant`.\n"
"\n"
"As a proof state:\n"
"```\n"
"Assumptions:\n"
"h : Knight ∩ Knave = ∅ \n"
"Or : A ∈ Knight ∨ A ∈ Knave\n"
"```\n"
"\n"
"## Summary\n"
"Putting every together:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"B : Inhabitant \n"
"C : Inhabitant\n"
"Knight : Finset Inhabitant\n"
"Knave : Finset Inhabitant\n"
"\n"
"Assumptions\n"
"h : Knight ∩ Knave = ∅ \n"
"Or : A ∈ Knight ∨ A ∈ Knave\n"
"```\n"
"\n"
"## Translating statements to formal notation\n"
"Given an inhabitant `A`,\n"
"\n"
"The translation we use is based on the following:\n"
"- If `A` is a knight, then `A`'s statement is true.\n"
"- If `A`'s statement is true, then `A` is telling the truth i.e is a knight.\n"
"\n"
"Formally:\n"
"```\n"
"A ∈ Knight → statement-of-A\n"
"statement-of-A → A ∈ Knight\n"
"```\n"
"where `statement-of-A : Prop` represents `A`'s statement.\n"
"\n"
"Combining them we get,\n"
"```\n"
"stA : A ∈ Knight ↔ statement-of-A\n"
"```\n"
"\n"
"### Quick Example\n"
"If,\n"
"```\n"
"A says B is a knave\n"
"```\n"
"\n"
"then,\n"
"```\n"
"A ∈ Knight → B ∈ Knave\n"
"B ∈ Knave → A ∈ Knight\n"
"```\n"
"\n"
"Combining them using `↔`:\n"
"```\n"
"stA : A ∈ Knight ↔ B ∈ Knave\n"
"```\n"
"\n"
"### equivalent translations, using knaves\n"
"Given inhabitant `A`,\n"
"\n"
"The translation we use is based on the following:\n"
"- If `A` is a knave, then `A`'s statement is false, i.e its negation is true.\n"
"- If `A`'s statement is false, then `A` is lying i.e is a knave.\n"
"\n"
"Formally:\n"
"```\n"
"A ∈ Knave → ¬statement-of-A\n"
"¬statement-of-A → A ∈ Knave\n"
"```\n"
"where `statement-of-A : Prop` represents `A`'s statement.\n"
"\n"
"Combining them we get,\n"
"```\n"
"stAn : A ∈ Knave ↔ ¬statement-of-A\n"
"```\n"
"\n"
"### Quick Example\n"
"If,\n"
"```\n"
"A says B is a knave\n"
"```\n"
"\n"
"then,\n"
"```\n"
"A ∈ Knave → ¬(B ∈ Knave)\n"
"¬(B ∈ Knave) → A ∈ Knave\n"
"```\n"
"\n"
"Combining them using `↔`:\n"
"```\n"
"stAn : A ∈ Knave ↔ ¬(B ∈ Knave)\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid "We will introduce the knights and knaves puzzle here.\n"
"\n"
"The setting is an island. \n"
"Every islander will make a statement. There are two types of islanders, 'knights' that always tell the truth, and 'knaves' that always lie.\n"
"\n"
"We give english statements and their corresponding translation to lean.\n"
"\n"
"Given an islander `A`\n"
"\n"
"`A` is a knight\n"
"```\n"
"A.isKnight\n"
"```\n"
"\n"
"`A` is a knave\n"
"```\n"
"A.isKnave\n"
"```\n"
"\n"
"`A` is either a knight or a knave\n"
"```\n"
"isKnight_or_isKnave (A : Islander) : A.isKnight or A.isKnave\n"
"```\n"
"\n"
"Knights always tell the truth.\n"
"```\n"
"knight_said : (A said P) → A.isKnight → P\n"
"said_knight : (A said P) →  P → A.isKnight \n"
"```\n"
"\n"
"Knaves always lie.\n"
"```\n"
"knave_said  : (A said P) →  A.isKnave → ¬P\n"
"said_knave  : (A said P) →  ¬P → A.isKnave\n"
"```\n"
"\n"
"Since knights always tell the truth and knaves always lie, no islander can be both a knight and a knave. `A` is not a knight and a knave at the same time. This is represented as:\n"
"```\n"
"not_isKnight_and_isKnave (A : Islander) : ¬ (A.isKnight ∧ A.isKnave)\n"
"```\n"
"\n"
"The objective is to conclude who is a knight and who is a knave, based on the statements of several inhabitants. This will be done using logical reasoning."
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid "### **Logic Constants & Operators**\n"
"| $Name~~~$ | $Ascii~~~$ | $Unicode$ | $Unicode Cmd$ |\n"
"| --- | :---: | :---: | --- |\n"
"| True | `True` |  |  |\n"
"| False | `False` |  |  |\n"
"| Not | `Not` | ¬ |  `\\not` `\\neg`  |\n"
"| And | `/\\` | ∧ | `\\and`  |\n"
"| Or | `\\/` | ∨ |  `\\or`  |\n"
"| Implies | `->` | → |  `\\imp` |\n"
"| Iff | `<->` | ↔ | `\\iff` |\n"
"\n"
"### **Other Unicode**\n"
"| $Name$ | $Unicode~~~$ | $Unicode Cmd$ |\n"
"| --- | :---: | --- |\n"
"| Angle brackets | ⟨⟩ | `\\<>` |\n"
"| Left Arrow | ← | `\\l` `\\leftarrow` `\\gets` `\\<-` |"
msgstr ""

#: Game.Doc.doc
msgid "`P ↔ Q`  is defined as `(P → Q) ∧ (Q → P)`. \n"
"\n"
"Its truth table looks like the folowing:\n"
"$\n"
"\\begin{array}{|c c|c c|c|} \n"
"\\hline\n"
"P & Q & P → Q & Q → P & P → Q ∧ Q → P\\\\\n"
"\\hline\n"
"T & T & T & T & T \\\\\n"
"\\hline\n"
"T & F & F & T & F \\\\\n"
"\\hline\n"
"F & T & T & F & F \\\\\n"
"\\hline\n"
"F & F & T & T & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"So, `P ↔ Q` is true when `P,Q` are true or `P,Q` are false, i.e when `P` and `Q` have the same truth value. Therefore, `P` and `Q` are equivalent from a truth value perspective regardless what the statement of `P` and of `Q` is.\n"
"\n"
"## Extracting Each Implication\n"
"```\n"
"h : P ↔ Q\n"
"h.mp : P → Q\n"
"h.mpr : Q → P\n"
"```\n"
"`h.mp` is the forward direction and `h.mpr` is the backward direction.\n"
"\n"
"## `P ↔ Q` is `P = Q`\n"
"Since `P`, `Q` have the same truth value , they can be used interchangeably.\n"
"You can think of `P ↔ Q` as `P = Q` and use `rw` in the same way you would if there was an actual `=` in the expression.\n"
"\n"
"For example:\n"
"```\n"
"h : P ↔ Q\n"
"hP : P\n"
"```\n"
"Doing `rw [h] at hP` results in:\n"
"```\n"
"h : P ↔ Q\n"
"hP : Q\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid "```\n"
"theorem inright_notinleft\n"
"(h : left ∩ right = ∅ )\n"
"(Aright : A ∈ right)\n"
": A ∉ left\n"
"```\n"
"\n"
"Given the following proof state:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"left right : Finset Inhabitant\n"
"\n"
"Assumptions\n"
"h : left ∩ right = ∅\n"
"Aright : A ∈ right\n"
"\n"
"Goal\n"
"A ∉ left\n"
"```\n"
"\n"
"exact `inright_notinleft h Aright` will close the goal."
msgstr ""

#: Game.Doc.doc
msgid "A is a knight, so whatever A said is true"
msgstr ""

#: Game.Doc.doc
msgid "A said something true, so A is a knight."
msgstr ""

#: Game.Doc.doc
msgid "A is a knave, so whatever A said is false"
msgstr ""

#: Game.Doc.doc
msgid "A said something that is false(i.e a lie), so A is a knave"
msgstr ""

#: Game.Doc.doc
msgid "For an Islander `A`,\n"
"```\n"
"isKnight A : Prop\n"
"```\n"
"or\n"
"```\n"
"A.isKnight : Prop\n"
"```\n"
"is the proposition that `A` is a knight."
msgstr ""

#: Game.Doc.doc
msgid "For an Islander `A`,\n"
"```\n"
"isKnave A : Prop\n"
"```\n"
"or\n"
"```\n"
"A.isKnave : Prop\n"
"```\n"
"is the proposition that `A` is a knight."
msgstr ""

#: Game.Doc.doc
msgid "You can't be a knight and a knave at the same time.\n"
"\n"
"You can't lie and tell the truth at the same time."
msgstr ""

#: Game.Doc.doc
msgid "Similar to `knave_said`."
msgstr ""

#: Game.Doc.doc
msgid "A : I am a knave\n"
"\n"
"This implies a contradiction, `False`"
msgstr ""

#: Game.Doc.tactic_doc
msgid "`by_contra h` proves `P` by contradiction, introducing a hypothesis `h : ¬P` and proving False i.e proving `¬¬P` which is equivalent to `P`.\n"
"\n"
"If `P` is a negation `¬Q`, h : `Q` will be introduced instead of `¬¬Q`."
msgstr ""

#: Game.Doc.tactic_doc
msgid "`rfl` is short for reflexivity. In the context of numbers, it is the property that for any number `a`, `a = a`.\n"
"\n"
"`rfl` also applies more generally, `rfl` will close any goal of the form `A=B` where `A`,`B` are identical. If needed, `rfl` will unfold both sides into their definitions and then check if they are equal. In other words, `rfl` can prove the equality of two things that are 'equal by definition'.\n"
"\n"
"In fact, `rfl` is not a tactic but syntactic sugar for `exact rfl`. `rfl` is of type `a = a` for any `a`.\n"
"\n"
"## examples\n"
"```\n"
"x - 7 = x - 7\n"
"```\n"
"`rfl` will close this goal."
msgstr ""

#: Game.Doc.tactic_doc
msgid "The assumption tactic searches for an assumption that matches the goal, and closes the goal if it finds one.\n"
"\n"
"Given,\n"
"```\n"
"Objects\n"
"P : Prop\n"
"\n"
"Assumptions\n"
"hP : P\n"
"\n"
"Goal\n"
"P\n"
"```\n"
"`assumption` will close the goal."
msgstr ""

#: Game.Doc.tactic_doc
msgid "Given,\n"
"```\n"
"PorQ : P ∨ Q\n"
"\n"
"Goal\n"
"some-goal\n"
"```\n"
"`cases PorQ` will first assume `P` and ask you to prove `some-goal` and then it will assume `Q` and ask you to prove `some-goal`. So in both cases, `some-goal` is true. Therefore we can conclude `some-goal`. This is called a proof by cases."
msgstr ""

#: Game.Doc.tactic_doc
msgid "`intro` tactic is used to deal with goals of the form `P → Q`.\n"
"\n"
"Having the following:\n"
"```\n"
"Goal:\n"
"P → Q\n"
"```\n"
"We want to prove that 'If `P` is true, then `Q` is true'. \n"
"\n"
"To do this, we first need to assume `P` then prove `Q`. Assuming `P` is done using `intro name` for any 'name'."
msgstr ""

#: Game.Doc.tactic_doc
msgid "The `constructor` tactic will split a goal of the form `P ∧ Q` into two subgoals `P`,`Q` where you can deal with each one separately."
msgstr ""

#: Game.Doc.tactic_doc
msgid "Contradiction is a tactic that detects if you have contradictory assumptions and if so, closes the goal.\n"
"\n"
"Having\n"
"```\n"
"h : False\n"
"```\n"
"or\n"
"```\n"
"hP : P \n"
"hnP : ¬P\n"
"```\n"
"(or other 'simple' contradictions)\n"
"`contradiction` will close any goal."
msgstr ""

#: Game.Doc.tactic_doc
msgid "Given the following:\n"
"```\n"
"Assumptions:\n"
"h : A = B\n"
"\n"
"Goal:\n"
"some expression involving A\n"
"```\n"
"\n"
"`rw [h]` would change the goal by replacing every occurrence of `A` with `B`.\n"
"\n"
"By default, rw uses an equation in the forward direction, matching the left-hand side of the equation `h` with an occurrence of `A` in the goal, and replaces it with the right-hand side i.e `B`. \n"
"\n"
"The notation `rw [←h]` can be used to instruct the tactic to use the equality `h` in the reverse direction i.e replace an occurrence of `B` with `A`.\n"
"\n"
"## Behavior with `=` and `↔`\n"
"For `rw [h]`, the behavior is exactly the same for both, whether you had `h : x=2` or `h : P ↔ Q`."
msgstr ""

#: Game.Doc.tactic_doc
msgid "Having the goal of the form:\n"
"```\n"
"P ∨ Q\n"
"```\n"
"for `P Q : Prop`, `left` transforms the goal to `P`."
msgstr ""

#: Game.Doc.tactic_doc
msgid "Having the goal of the form:\n"
"```\n"
"P ∨ Q\n"
"```\n"
"for `P Q : Prop`, `right` transforms the goal to `Q`."
msgstr ""

#: Game.Doc.tactic_doc
msgid "## Overview\n"
"For the following proof state:\n"
"```\n"
"Objects\n"
"P : Prop\n"
"\n"
"Assumptions\n"
"hP : P\n"
"\n"
"Goal:\n"
"P\n"
"```\n"
"Remember that `hP : P` where `P : Prop` means `hP` is a proof of `P`.\n"
"\n"
"Since the goal is to prove `P`, the only thing we have to do is to let Lean know that we do have such a proof. This is done by `exact h`.\n"
"\n"
"In other words, `hP` is EXACTLY whats needd to prove the goal, the type of `hP` EXACTLY matches the goal, so `exact h` will do the job."
msgstr ""

#: Game.Doc.tactic_doc
msgid "The `have` tactic allows you to add theorems to the context(which you would have to prove, of course).\n"
"\n"
"## one step\n"
"If the proof is one step, then the following:\n"
"```\n"
"have theorem-name := expression\n"
"```\n"
"will do, where `expression : P` with `P : Prop` i.e `expression` is a proof of `P`\n"
"\n"
"The result would be adding the following to the hypothesis:\n"
"```\n"
"theorem-name : P\n"
"```\n"
"\n"
"You are storing the proof of `P` `expression` in `theorem-name` so that you don't have to construct this expression everytime...\n"
"\n"
"## multiple steps\n"
"If the proof is multiple steps, then:\n"
"```\n"
"have theorem-name : theorem-prop\n"
"```\n"
"will change the current goal to `theorem-prop : Prop` which is what you want to prove.\n"
"\n"
"After being proven, the original goal is restored with `theorem-name : theorem-prop` added(which is a proof of the proposition `theorem-prop`)\n"
"\n"
"### example\n"
"```\n"
"have a : 2=2\n"
"```\n"
"will change the goal to `2=2`, which after proving would restore the original goal with the theorem `a : 2=2` added and ready to be used."
msgstr ""

#: Game.Doc.tactic_doc
msgid "The `contradiction` tactic works for the following proofs states:\n"
"```\n"
"h : False\n"
"```\n"
"\n"
"```\n"
"hP : P\n"
"hnP : ¬P\n"
"```\n"
"\n"
"and\n"
"```\n"
"hP : P\n"
"```\n"
"where Lean knows that `¬P` is true.\n"
"\n"
"Example:\n"
"-- disjoint\n"
"You need to show that having two sets being disjoint (i.e sharing no common element) and having a common element is a contradiction."
msgstr ""

#: Game.Doc.tactic_doc
msgid "Rewrites all expression asserting being a  knight into the equivalent expression of not being knave\n"
"\n"
"Changes all instances of `isKnight A` to `¬isKnave A`\n"
"\n"
"# Change the Goal\n"
"`knight_to_knave`\n"
"\n"
"# Change the Hypothesis\n"
"`knight_to_knave` at `hypothesis`\n"
"\n"
"# Change the goal and all hypothesis\n"
"`knight_to_knave` at *\n"
"\n"
"The `*` is called the 'wildcard', and it matches anything.\n"
"\n"
"# Under the hood\n"
"The tactic is simply a macro abbreviating:\n"
"```\n"
"simp [isKnight_notisKnaveIff]\n"
"```\n"
"where \n"
"```\n"
"isKnight_notisKnaveIff {A : Islander} : A.isKnight ↔ ¬A.isKnave\n"
"```\n"
"\n"
"`A.isKnight` and `¬A.isKnave` always have the same truth value regardless of what `A` is , so they can be interchanged"
msgstr ""

#: Game.Doc.tactic_doc
msgid "Rewrites all expression asserting being a  knight into the equivalent expression of not being knave\n"
"\n"
"Changes all instances of `isKnave A` to `¬isKnight A`\n"
"\n"
"# Change the Goal\n"
"`knave_to_knight`\n"
"\n"
"# Change the Hypothesis\n"
"`knave_to_knight` at `hypothesis`\n"
"\n"
"# Change the goal and all hypothesis\n"
"`knave_to_knight` at *\n"
"\n"
"The `*` is called the 'wildcard', and it matches anything.\n"
"\n"
"# Under the hood\n"
"The tactic is simply a macro abbreviating:\n"
"```\n"
"simp [isKnave_notisKnightIff]\n"
"```\n"
"where \n"
"```\n"
"isKnight_notisKnaveIff {A : Islander} : A.isKnave ↔ ¬A.isKnight\n"
"```\n"
"\n"
"`A.isKnave` and `¬A.isKnight` always have the same truth value regardless of what `A` is , so they can be interchanged"
msgstr ""

#: Game.Doc.tactic_doc
msgid "For an islander `A`,\n"
"```\n"
"knight_or_knave A\n"
"```\n"
"takes two cases, the first being `h : A.isKnight` and the second being `h:A.isKnave`\n"
"\n"
"You can choose the name of the hypothesis of each case by\n"
"```\n"
"knight_or_knave A with AKnight AKnave\n"
"```\n"
"which gives the first case `AKnight : A.isKnight` and the second case `AKnave : A.isKnave`.\n"
"\n"
"# Under the hood\n"
"`knight_or_knave A` is just a macro for \n"
"```\n"
"cases isKnight_orisKnave A\n"
"```\n"
"where `isKnight_or_isKnave A : A.isKnight or A.isKnave`"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "`rfl`, A Number Equals Itself"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "In this exercise, we will prove `2 = 2`\n"
"\n"
"`rfl` will do the job.\n"
"\n"
"`rfl` is short for reflexivity, which is the property that for any number `a`, `a = a`"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "Notice that 'level completed! 🎉' on the bottom. We say that the goal is closed/proven."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "`exact` , goal is true by assumption"
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "In this level, we have `Objects`, `Assumptions`, and the `Goal`.\n"
"\n"
"# Objects\n"
"Objects will always be variables(letter symbols) we are working with. What these variables denote is specified after the `:`, what is after the `:` is called the type of the object.  \n"
"\n"
"Here, `x`  denotes a number but we don't know which number it is. The `: ℕ` in `x : ℕ` means that `x` is a variable of type natural number(positive numbers like `1`,`2`,`3`, and so on...). \n"
"\n"
"# Assumptions\n"
"As for the assumptions, we have `h : x=2` which means that `h` is an object of type `x=2`. This essentially means that `h` is an object asserting that the proposition(or statement) `x=2` is true. In other words, we know that `x=2` and `h` is a proof of that. \n"
"\n"
"# Goal\n"
"Our goal is to prove that `x = 2`.\n"
"We must use our assumptions.\n"
"We have that `h : x=2` i.e `h` is a proof that `x=2`.\n"
"\n"
"`h` is a proof of our goal, we should let Lean know that we have a proof of the goal. Using `exact h` accomplishes this."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "The `exact` in `exact h` tells Lean that `h`'s type EXACTLY matches the goal. In other words, `h` is EXACTLY what we need to prove the goal. Lean verifies this and reports that there are no more goals to prove. We are done.\n"
"\n"
"The `assumption` tactic can also be used here which searches for an assumption that matches the goal, and closes the goal if it finds one."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Substituting Variables By Their Values"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "We will learn how to substitute a variable with its value, for example how to substitiute `x` by `2` if we know that `x=2`.\n"
"\n"
"This can be done using the tactic `rw` (short for rewrite).\n"
"\n"
"`rw` takes a term of type `A=B` and replaces all the `A`s in the goal with `B`s.\n"
"So `rw [h]` where `h : x=3` will replace all the `x`s of the goal with `3`."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Do `rw [«{h}»]` or `rw [«{g}»]` and observe what happens."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "You should use `«{h}»` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "`rw [h]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "You should use `«{g}»` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "`rw [g]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Our goal is now `3 + 3 = 6`. The `rw` tactic implicitly executes `rfl` after doing the rewrite which unfolds the numbers `3` and `6` to what they are defined as, and it turns out both sides are identical.\n"
"\n"
"Another solution:\n"
"```\n"
"rw [h,g]\n"
"```\n"
"instead of\n"
"```\n"
"rw [h]\n"
"rw [g]\n"
"```"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "`Nat.mul_left_cancel` , Divide both sides of an equation"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "We know that `4 * y = 16`. Dividing both sides by `4` gives us `y = 4` which is the goal.\n"
"\n"
"The theorem to do this is:\n"
"```\n"
"Nat.mul_left_cancel firstarg \n"
"                    secondarg\n"
"```\n"
"where the `firstarg` is a theorem that the number you are cancelling from both sides is positive, in our case this would be `four_pos`. \n"
"\n"
"The `secondarg` would be the equation you are working with, in this case `h`.\n"
"\n"
"`Nat.mul_left_cancel firstarg secondarg` would be a proof of the resulting equation after cancelling the positive number specified in `firstarg` from both sides of the equation specified in `secondarg`.\n"
"\n"
"Give this proof to Lean using `exact`."
msgstr ""

#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "Here is the type signature of Nat.mul_left_cancel:\n"
"  ```\n"
"Nat.mul_left_cancel \n"
"(np : 0 < n) \n"
"(h : n * m = n * k) \n"
": m = k\n"
"  ```\n"
"  `Nat.mul_left_cancel` takes two arguments which are:\n"
"   - `np`, a proof that some number `n` is positive.\n"
"   - `h`, the equation which has `n` on both sides of the equation multiplied on the left.\n"
"\n"
"  The result is whats after `:` , canceling `n` from both sides of the equation giving a proof `m = k`."
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "Equational Reasoning"
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "In this world, you will learn how to solve equations."
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "This should look familiar.\n"
"\n"
"If it doesn't, then replace `P` by `x=2`.\n"
"\n"
"`hP` is of type `P` and `P` is of type `Prop`. So, `hP` is a proof of `P`. Our goal is to prove `P`. We already have such a proof which is `hP`, `hP` is EXACTLY what we need to prove the goal. The type of `hP` EXACTLY matches the goal."
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Type `exact hP`!"
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "In the next levels, we will discuss how to construct new propositions from old ones whose meaning and truth value would depend on those old ones."
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "And , `∧`"
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "In this level, we introduce the `∧` logical connective (read as 'and').\n"
"\n"
"Remember the following example:\n"
"Given the two propositions `x=2`(`P`), `y=6`(`Q`) , we can construct a new propositon `x=2 ∧ y=6`(`P ∧ Q`) which is read as `x=2 and y=6`(`P and Q`).\n"
"\n"
"What is the truth value of this new proposition `x=2 ∧ y=6`(`P ∧ Q`)? \n"
"Well, it would depend on truth value of the two component propositions `x=2`(`P`) ,`y=6`(`Q`).\n"
"\n"
"What possibilities are there for each's truth value? `x=2` (`P`) can either be true or false and similarly for `y=6`(`Q`). Here is a truth table that goes through all these possibilities: \n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"x=2 & y=6 & x=2 ∧ y=6 \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & F \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"\n"
"The proposition `x=2 and y=6`(`P and Q`) is true when `x=2`(`P`) is true AND `y=6`(`Q`) is true.\n"
"In other words, if `P` is true AND `Q` is true. This is how things work regardless of what `P` is, what `Q` is. The only thing that matters is their truth value.\n"
"Therefore, the more general truth table is the same:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ∧ Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & F \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that `P and Q` is true when both `P` is true and `Q` is true, being false otherwise.\n"
"\n"
"From this, we conclude that we can introduce `∧` if we have a proof of `P` and a proof of `Q`.\n"
"```\n"
"  And.intro  (left : P) (right : Q) : P and Q\n"
"```\n"
"\n"
"You can think of `And.intro` as a function that takes two inputs: a proof of `P`, a proof of `Q` and returns a proof of `P and Q`.\n"
"\n"
"For example:\n"
"```\n"
"And.intro arg1 arg2\n"
"```\n"
"where `arg1 : P` , `arg2 : Q` , `(And.intro arg1 arg2) : P and Q`.\n"
"\n"
"Use it to construct an object of type `P and Q`, and use `exact` to close the goal."
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "You can also use the `constructor` tactic which will split the goal `P and Q` into two,\n"
"the first being to prove `P` and the second being to prove `Q`.\n"
"\n"
"Moreover, instead of `And.intro hP hQ` you can use the notation `\\<hP,hQ\\>` which means the same thing."
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "Or, `∨`"
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "In this level, we introduce the `∨` logical connective read as 'or'.\n"
"\n"
"Its truth table is as follows:\n"
"$\n"
"\\begin{array}{|c|c|c|}\n"
"\\hline\n"
"P & Q & P or Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & T \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"From this truthtable, we conclude that to prove `P or Q`,  we need either `P` being true or `Q` being true or both.\n"
"\n"
"You can tell Lean which side of `or` you want to prove by simply executing `left` or `right`.\n"
"\n"
"In our case, we know the left side of `or` is true, so use `left`."
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "We have a proof that `P` is true, and we want to prove `P`"
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid ""
msgstr ""

#: Game.Levels.Logic.L04_Implication
msgid "Implication, →"
msgstr ""

#: Game.Levels.Logic.L04_Implication
msgid "In this level, we introduce the logical implication `→` connective.\n"
"Logical implication `P → Q` is made up of two components:\n"
"- The premise, which in this case is `P`\n"
"- The conclusion, which in this case is `Q`\n"
"\n"
"`P → Q` is read as 'If `P` is true, then `Q` is true.\n"
"The truth of `P` IMPLIES the truth of `Q`. A proof of `P` IMPLIES a proof of `Q`.\n"
"\n"
"# truth table\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P → Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"A statement `P → Q` is false when `P` is true and `Q` false, it's true otherwise.\n"
"This is because this is the only case where the meaning of `P → Q` is violated i.e we have that `P` is true so `Q` is supposed to be true as well but its not.\n"
"\n"
"When `P` is false, the implication `P → Q` is always false because the implication does not tell us what should happen when `P` is false.\n"
"\n"
"In the current proof state, we know `P` (i.e `P` is true) , and we know `P → Q` (i.e `P → Q` is true). Therefore, we can conclude `Q` (i.e `Q` is true ).\n"
"\n"
"You can think of logical implication as a function with one input and one output. It takes a proof of `P` and returns a proof of `Q`."
msgstr ""

#: Game.Levels.Logic.L04_Implication
msgid "In the next level, you will learn how to deal with an implication as the goal you have to prove."
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "Proving an implication, Implication as the goal"
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "The goal, translated to english is: 'If P is true, then P is true'.\n"
"\n"
"To prove such a goal, we need to assume that `P` is true. Then, we have to prove that `P` is true.\n"
"\n"
"To do this, we need to assume the premise i.e introduce it to our assumptions. We can do this using `intro`.\n"
"\n"
"After that , we have to prove the consequent."
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "use `intro name` to give the introduced hypothesis a name\n"
"\n"
"The previous two levels showed how to use an implication and how to prove an implication."
msgstr ""

#: Game.Levels.Logic.L06_cases
msgid ""
msgstr ""

#: Game.Levels.Logic.L06_cases
msgid "In this level, we will do a 'proof by cases'. \n"
"By `h : P or Q`, we have two cases:\n"
"`P` being true or `Q` being true. If we consider each case individually and prove `R`, then we can conclude that `R` is true.\n"
"\n"
"To do this, start with `cases h`"
msgstr ""

#: Game.Levels.Logic.L06_cases
msgid ""
msgstr ""

#: Game.Levels.Logic.L07_LogicalEquivalence
msgid "Logical Equivalence, `↔`"
msgstr ""

#: Game.Levels.Logic.L07_LogicalEquivalence
msgid "`P ↔ Q`  is defined as `(P → Q) ∧ (Q → P)`.\n"
"\n"
"Its truth table looks like the folowing:\n"
"$\n"
"\\begin{array}{|c c|c c|c|} \n"
"\\hline\n"
"P & Q & P → Q & Q → P & P → Q ∧ Q → P\\\\\n"
"\\hline\n"
"T & T & T & T & T \\\\\n"
"\\hline\n"
"T & F & F & T & F \\\\\n"
"\\hline\n"
"F & T & T & F & F \\\\\n"
"\\hline\n"
"F & F & T & T & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"So, `P ↔ Q` is true when `P,Q` are true or `P,Q` are false, i.e when `P` and `Q` have the same truth value. Therefore, `P` and `Q` are equivalent from a truth value perspective regardless what the statement of `P` and of `Q` is.\n"
"\n"
"In this level we have `PsameQ : P ↔ Q`(`P`, `Q` have the same truth value) and `hP : P`(`P` is true) and so `Q` is true as well.\n"
"\n"
"There are a number of ways to prove this level:\n"
"- You can extract the forward direction of `h :P ↔ Q` which is `h.mp : P → Q` and use `hP : P` to prove `Q`(`h.mpr : Q → P` is the backward direction).\n"
"- Since `PsameQ` means that `P` and `Q` have the same truth value, you can pretend `↔` is instead `=` and use `rw` at `hP : P` to obtain `hP : Q` and then close the goal."
msgstr ""

#: Game.Levels.Logic.L07_LogicalEquivalence
msgid "This level could have been\n"
"```\n"
"PsameQ : P ↔ Q\n"
"hQ : Q\n"
"\n"
"Goal \n"
"P\n"
"```\n"
"`exact PsameQ.mpr hQ` would close the goal."
msgstr ""

#: Game.Levels.Logic.L08_Not
msgid "Not Connective, ¬"
msgstr ""

#: Game.Levels.Logic.L08_Not
msgid "In this level we introduce the negation, the `¬` connective (read as 'not').\n"
"\n"
"Notice that this is the first logical connective that applies on one proposition only and not two.\n"
"\n"
"The job of this connective(as the name implies), is to negate a proposition meaning that:\n"
"- For `P` true, `¬P` is false.\n"
"- For `P` false, `¬P` is true.\n"
"\n"
"In truth table form:\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & ¬P \\\\\n"
"\\hline\n"
"T & F \\\\\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that since `P` is true, `¬P` should be false but in this proof state it is true (by `hnP`). This is a contradiction. The goal is to prove `False` which means to prove a contradiction.\n"
"\n"
"Note that we don't need to introduce a new symbol to define negation, it can be defined in terms of what we already know.\n"
"\n"
"Consider the following truth table: \n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & P → False \\\\\n"
"\\hline\n"
"T & F  \\\\\n"
"F & T  \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that regardless of the truth value of `P`, the two propositions `¬P` and `P → False` have the same truth table. Therefore, they can be used interchangeably.(we say that these two expressions are logically equivalent, but let's leave this to a future level)\n"
"\n"
"What `¬P` means is that if `P` were true, then we can deduce a contradiction. We know that `P` is true. Therefore, we can prove a contradiction which is the goal.\n"
"\n"
"To see `¬P` in its implication form, you can do `unfold Not` to unfold the definition of `¬`. Note that this would apply to the goal, and so `unfold Not at hnP` applies at `hnP`."
msgstr ""

#: Game.Levels.Logic.L08_Not
msgid "Remember that an implication acts like a function, that takes a proof of whats on the left hand returning a proof of whats on the right hand side.\n"
"\n"
"For this level, `¬P` being true tells us that a proof of `P` gives us a proof of `False`. We have a proof of `P`. Therefore we can obtain a proof of `False` which is the goal."
msgstr ""

#: Game.Levels.Logic.L08_Not
msgid "Remember that an implication acts like a function, that takes a proof of whats on the left hand returning a proof of whats on the right hand side.\n"
"\n"
"For this level, `¬P` being true tells us that a proof of `P` gives us a proof of `False`. We have a proof of `P`. Therefore we can obtain a proof of `False` which is the goal."
msgstr ""

#: Game.Levels.Logic.L08_Not
msgid "In the next level, we will explore what it means to have proven `False`."
msgstr ""

#: Game.Levels.Logic.L09_False
msgid "From `False`, anything follows."
msgstr ""

#: Game.Levels.Logic.L09_False
msgid "We proved `False`, what does this mean? What can we conclude? What does `False` IMPLY?\n"
"\n"
"Let's check the `→` truth table:\n"
"$$\n"
"\\begin{array}{|c|c|c|}\n"
"\\hline\n"
"P & Q & P → Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$$\n"
"\n"
"Let's focus on part of the truth table where `P` is `False`, because we want to see what `False` implies.\n"
"$$\n"
"\\begin{array}{|c|c|c|}\n"
"\\hline\n"
"Q & False → Q \\\\\n"
"\\hline\n"
"T & T \\\\\n"
"\\hline\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$$\n"
"\n"
"We have that the implication `False → Q` is true regardless what `Q` represents and regardless whether `Q` is true or is false. \n"
"So `False` implies any proposition. This principle is known as: 'From `False` anything follows'.\n"
"\n"
"Use the implication `False.elim (h : False) : C` to prove `Q` where `Q` is any proposition."
msgstr ""

#: Game.Levels.Logic.L09_False
msgid "Having proven `False`, instead of going through this to prove `Q` you can use the the `contradiction` tactic. If you were able to prove `False`, then the `contradiction` tactic will prove the goal regardless what the goal is because 'from `False`, anything follows'.\n"
"\n"
"Proving `False` is what's usually called deriving a contradiction, and note that to prove `False` you would first need to have a proof `P`, and a proof of `¬P` i.e `P → False`."
msgstr ""

#: Game.Levels.Logic.L10_have
msgid "`have`"
msgstr ""

#: Game.Levels.Logic.L10_have
msgid "In this level, we introduce that `have` tactic. \n"
"You have to prove `R` but to you need `Q` first. \n"
"\n"
"Use `have hQ : Q` to change the goal to proving `Q`."
msgstr ""

#: Game.Levels.Logic.L10_have
msgid "`hPQ` takes `hP` and gives you a proof of `Q`"
msgstr ""

#: Game.Levels.Logic.L10_have
msgid "Now that you proved `Q`,\n"
"\n"
"`hQR` takes `«{hQ}»` and gives you a proof of `R` which is the goal."
msgstr ""

#: Game.Levels.Logic.L10_have
msgid ""
msgstr ""

#: Game.Levels.Logic.L11_have
msgid ""
msgstr ""

#: Game.Levels.Logic.L11_have
msgid "Coming back to `have`,\n"
"\n"
"If you can prove something in one step then \n"
"```\n"
"have theorem-name := proof\n"
"```\n"
"will do. \n"
"\n"
"For example, you can obtain a proof of `Q` in one step by \n"
"```\n"
"hPQ hP\n"
"```\n"
"then `have hQ := hPQ hP` will add `hQ : Q` to the proof state i.e you have proven `Q` and `hQ` is the proof."
msgstr ""

#: Game.Levels.Logic.L11_have
msgid ""
msgstr ""

#: Game.Levels.Logic.L12_simp
msgid "simp"
msgstr ""

#: Game.Levels.Logic.L12_simp
msgid "In the upcoming levels, we will introduce simplications of propositions.\n"
"\n"
"The simplification here concerns `or`.\n"
"\n"
"The intution behind the simplifiction can be understood from looking at the truth table which we put here for reference:\n"
"$\n"
"\\begin{array}{|c c|c|}\n"
"\\hline\n"
"P & Q & P or Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & T \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that for `Q = False`, `P or Q` is true regardless of what `P` is.\n"
"\n"
"In other words, `P or False` and `P` have the same truth value i.e `(P or False) ↔ P`. Whenver `P or False` occurs , we can replace it by `P`.\n"
"\n"
"You learned how to do this from the `↔` levels.\n"
"\n"
"The theorem for this simplication\n"
"```\n"
"or_false_iff (p : Prop) : p or False ↔ p\n"
"```\n"
"\n"
"However, `simp` would apply such a simplification without you having to reference the theorem and use `rw`.\n"
"\n"
"Apply `simp` at `h` , i.e `simp at h`."
msgstr ""

#: Game.Levels.Logic.L12_simp
msgid ""
msgstr ""

#: Game.Levels.Logic
msgid "Logic"
msgstr ""

#: Game.Levels.Logic
msgid "In this world, we will be dealing with `Objects` of type `Prop` i.e propositions. You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time). You have seen propositions before like `x=2`, `y=6` etc..\n"
"\n"
"When you have `h : P` where `P : Prop` , then we say `h` is a proof of the statement `P`(imagine `x=2` instead of `P` if you wish).\n"
"\n"
"In a proof state, this would look like the following:\n"
"```\n"
"Objects\n"
"P : Prop\n"
"Assumptions\n"
"h : P\n"
"```\n"
"\n"
"Moreover, we will discuss constructing new propositions from old ones.\n"
"\n"
"Here's an example in natural language, given the two propositions 'The sun is shining' , 'It is Monday', you can construct 'The sun is shining and it is monday'. \n"
"\n"
"Another example would be, having the following:\n"
"```\n"
"h : `x=2`\n"
"h' : `y=6`\n"
"```\n"
"where `P` is `x=2` and `Q` is `y=6`, we can construct a new proposition `P ∧ Q` which is read as `x=2 and y=6`. Here we know what `P`,`Q` stand for. But, the proposition `P ∧ Q` can still be constructed and reasoned about regardless. Think of reasoning about unknown numbers like `x`,`y` etc..."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "I am a knave, I am a liar"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "In this level, we present the 'I am a knave' puzzle.\n"
"\n"
"The given islander `A` says 'I am a knave'\n"
"```\n"
"Asaid : A said A.isKnave\n"
"```\n"
"\n"
"The goal is to prove `False`, i.e that given the rules of the game , if `A` says 'I am a knave' we have a contradiction.\n"
"\n"
"By the rules of the game, we know that `A` is either a knight or a knave. \n"
"```\n"
"isKnight_or_isKnave \n"
"(A : Islander) \n"
": A.isKnight or A.isKnave\n"
"```\n"
"\n"
"Try\n"
"```\n"
"cases isKnight_or_isKnave A\n"
"```"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "For the previous step and to avoid having you going through the hoops everytime , you can simply execute the custom tactic `knight_or_knave A with AKnight AKnave`.\n"
"Go back and try it before proceeding\n"
"\n"
"You get two cases , the first where `h : A.isKnight` and the second where `h: A.isKnave`\n"
"\n"
"We are now in the first case where `h : A.isKnight`\n"
"So, we can conclude that `A`'s statement is true."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "`knight_said`\n"
"\n"
"`A` is a knight, so whatever `A` said is true."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "We know `A` is a knight and a knave. \n"
"This is a contradiction\n"
"\n"
"Recall\n"
"```\n"
"not_isKnight_and_isKnave (AKnight : isKnight A) (AKnave : isKnave A) : False\n"
"```\n"
"\n"
"You can use this to prove `False`, or use `contradiction` which has been modified to handle when `A` is a knight and a knave."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "We are now in the second case where `h : A.isKnave`\n"
"So, we can conclude that `A`'s statement is false."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "`knave_said`\n"
"\n"
"`A` is a knave, so whatever `A` said is false."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "`A` is knave and is not a knave. \n"
"contradiction."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L01_IamKnave
msgid "We have proved the following theorem:\n"
"```\n"
"dsl_iamknave \n"
"(hAKn : A said A.isKnave) : False\n"
"```\n"
"which is given to you to use. \n"
"\n"
"You will need it in the next level."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
msgid "`A` says 'I am a knave or 2+2=5'.\n"
"\n"
"`2+2=5` is false\n"
"\n"
"`P or False` is `P`\n"
"\n"
"Use `simp` to do these simplications for you."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
msgid "This should look familiar.\n"
"\n"
"Don't repeat the proof!"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L02_2plus2
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "Three of the inhabitants A, B, and C were standing together in a garden. \n"
"\n"
"A stranger passed by and asked A, 'Are you a knight or a knave?' A answered, but rather indistinctly, so the stranger could not make out what he said. \n"
"\n"
"The stranger than asked B, 'What did A say?' B replied, 'A said that he is a knave.' \n"
"\n"
"At this point the third man, C, said, 'Don't believe B; he is lying!' \n"
"\n"
"The question is, what are B and C? \n"
"\n"
"Change the goal to `B.isKnave`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "Change the goal to `¬isKnight B`\n"
"\n"
"Having\n"
"```\n"
"h : P → Q\n"
"\n"
"Goal:\n"
"Q\n"
"```\n"
"then `apply h` will change the goal from `Q` to `P` , because proving `P` would give you `Q`.\n"
"\n"
"Here, we have\n"
"```\n"
"notisKnight_isKnave : ¬isKnight B → isKnave B \n"
"```\n"
"\n"
"We want to prove `isKnave B`, and a way to get there is through proving `¬isKnight B`."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "For the previous step and to avoid having you going through the hoops everytime , you can simply execute the custom tactic `knave_to_knight` which works as its name suggests.\n"
"Go back and try it before proceeding\n"
"(There is also a similar tactic `knight_to_knave`)\n"
"\n"
"`B` is a knight so whatever `B` said is true."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "If an islander says 'I am a knave', we get a contradiction i.e `False`."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid "Now that `B` is a knave, `C`'s statement is true then `C` is a knight.\n"
"\n"
"So would you have `B` is a knave, `C` is a knight to close the goal."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L03_prob26
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "`A` says 'I am a knave or `B` is a knave'."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "Let's start with proving that `A` is a knight. (use `have`)"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "Change the goal to ¬isKnave A"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "Assume `isKnave A`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "Let's first prove `isKnave A or isKnave B`."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "Choose which side to prove, `left` or `right`?"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "`A`'s statement is true, so `A` is a knight."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "`A` is a knight, so we can conclude `A`'s statement."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid "`orexp` can be simplified, using `simp` and the fact that `A` is a knight and that knights are not knaves.\n"
"\n"
"You could also obtain that `¬isKnave A` and use `notleft_right` to get `isKnave B`.\n"
"\n"
"After which, close the goal."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L04_IKnaveOrKnave
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L05_prob29
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "Suppose A says, 'I am a knave, but B isn't.' \n"
"What are A and B?\n"
"\n"
"Change the goal to `¬A.isKnight`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "Assume `A` is a knight."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "Conclude that `A`'s statement is true."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "Now you have that `A` is a knave , which is a contradiction\n"
"\n"
"Remeber that `«{AKnave}».left : A.isKnave`."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "Now that we know that `A` is not a knight, we know that what `A` said was a lie.\n"
"\n"
"Use\n"
"```\n"
"notknight_said\n"
"(stA : A said P) \n"
"( notKnight : ¬isKnight A) : ¬P\n"
"```"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "`h: ¬( P and Q)` means that both `P`,`Q` are not true at the same time which means one of them has to be false i.e `h : ¬P or ¬Q`.\n"
"\n"
"You can apply this using\n"
"```\n"
"push_neg at h\n"
"```\n"
"which 'pushes' the 'negation' inside and applying the appropriate rules."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid "`A` is not a knight means that `A` is a knave, so `«{st}»` could be simplified.\n"
"\n"
"Obtain `A.isKnave`, and simplify `«{st}»` obtaining `B.isKnave`.\n"
"\n"
"After that, close the goal"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L06_prob33
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L07_stiff
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L07_stiff
msgid "You have met a group of 2 islanders. Their names are Robert and Ira.\n"
"\n"
"`Robert` says: `Ira` is my type.\n"
"\n"
"`Ira` says: `Robert` is truthful.\n"
"\n"
"Let's first prove `Robert.isKnight`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L07_stiff
msgid "Change the goal from `knight_to_knave`."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L07_stiff
msgid "Assume `Robert.isKnave`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L07_stiff
msgid "Now that `Robert.isKnave` , `Ira` was lying becase `¬Robert.isKnight`. \n"
"Conclude that `Ira` is a knave using `¬Robert.isKnight`.\n"
"\n"
"After concluding `Ira.isKnave`:\n"
"\n"
"But now, `Robert` and `Ira` have the same type.\n"
"Change the goal to `Robert.isKnight ↔ Ira.isKnight` and conclude from this that `Robert.isKnight`.\n"
"\n"
"\n"
"To prove the iff statement, here are some relevant theorems:\n"
"- iff_of_true\n"
"- iff_of_false \n"
"- not_iff_not , not_iff_not.symm\n"
"and converting from `knight_to_knave` or vice versa.\n"
"\n"
"You could even use `constructor` and prove every implication."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L07_stiff
msgid "Now that `Robert.isKnight` , `Ira` is telling the truth so is a knight as well.\n"
"\n"
"We have the goal."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L07_stiff
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L08_difftype
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L08_difftype
msgid "You stumble into `A`,`B`.\n"
"\n"
"`A` says 'B is a knight'\n"
"\n"
"`B` says 'We are different types'"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L08_difftype
msgid "Let's start by proving `A.isKnave`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L08_difftype
msgid "Change this to a goal about knights,\n"
"and assume `A.isKnight`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L08_difftype
msgid "So, `B.isKnight` by `A`'s statement"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L08_difftype
msgid "So `A`,`B` are the same type , but `B` being a knight also tells us that they are not. contradiction\n"
"\n"
"Conclude `¬(A.isKnight ↔ B.isKnight)` from `B`'statement then prove that `A.isKnight ↔ B.isKnight`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L08_difftype
msgid "Now that `A` is a knave, we can conclude `A` was lying and `B` is in fact a `knave`.\n"
"\n"
"Then, close the goal."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L08_difftype
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L09_sametype
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L09_sametype
msgid "You have met a group of 2 islanders. Their names are Robert and Ira.\n"
"\n"
"Robert says: Ira is my type.\n"
"Ira says: Robert is truthful."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L09_sametype
msgid "Start by proving `¬Robert.isKnave`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L09_sametype
msgid "Assume `R.isKnave`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L09_sametype
msgid "So `Robert` is not a knight, so `Ira` was lying .\n"
"\n"
"Therefore `Ira` is a knave"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L09_sametype
msgid "`Robert` are `Ira` are the same, but we know they are not by `Robert`'s lie.\n"
"This is a contradiction.\n"
"\n"
"First, conclude that `Robert`'s statement is false i.e `¬(Robert.isKnight ↔ Ira.isKnight)` then prove `Robert.isKnight ↔ Ira.isKnight`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L09_sametype
msgid "Now that `Robert` is a knight, then `Ira` and `Robert` have the same type, and therefore `Ira` is a knight.\n"
"\n"
"Conclude `Robert`'s statement then use that to get `Ira.isKnight`.\n"
"\n"
"Close the goal."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L09_sametype
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_same
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_same
msgid "We have three inhabitants, `A`, `B`, and `C`.\n"
"\n"
"Two people are said to be of the same type if they are both knights or both knaves. \n"
"\n"
"`A` and `B` make the following statements:\n"
"`A`: `B` is a knave.\n"
"`B`: `A` and `C` are of the same type."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_same
msgid "Take cases for `A`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_same
msgid "We are in the cases where `A.isKnight`\n"
"\n"
"Conclude that `B.isKnave`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_same
msgid "Therefore, from `B`'s statement conclude that `A` and `C` are not the same i.e are different."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_same
msgid "Use `not_iff'`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_same
msgid "Conclude `¬C.isKnight` and close the goal."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_same
msgid "Now that `A` is a knave. \n"
"We can conlude `B` is a knight.\n"
"\n"
"which means that `A` and `C` have the same type, obtaining the `C` is a knave and closing the goal."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L10_same
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid "allKnights or allKnaves"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid "A says B is a knight\n"
"B says all of us are knights\n"
"C says A  is a knight or B is a knight\n"
"\n"
"Notice in the proof state,\n"
"```\n"
"allKnights\n"
"allKnaves\n"
"```\n"
"\n"
"You can `unfold` to get\n"
"```\n"
"A.isKnight ∧ B.isKnight ∧ C.isKnave \n"
"```\n"
"by\n"
"```\n"
"unfold allKnights at stB\n"
"```\n"
"(similarly for `allKnaves`)\n"
"\n"
"However, this will make the proof state look cluttered so don't `unfold`."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid "First, take cases for `B`."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid "We are at the cases where `B.isKnight`\n"
"Conclude that `B`'s statement is true"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid "`left` or `right` part of the goal?"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid "Now we have that `B.isKnave`.\n"
"Get `¬B.isKnight`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid "So, `A`'s statement is false.\n"
"\n"
"Conclude that `A` is a knave."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid "Now we have that `A.isKnave`\n"
"Get `¬A.isKnight`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid "Now, `C`'s statement is false , so conclude that `C` is a knave.\n"
"\n"
"You can do this in a number of ways:\n"
"- Use `have` to construct a proof that `¬ (A.isKnight or B.isKnight)`\n"
"- Use `simp` on `stC`, to obtain `C said False`. Conclude `C` is a knave using `said_knave`, `not_false : ¬False`.\n"
"\n"
"- etc...\n"
"\n"
"Once you have `C.isKnave` then everyone is a knave.(`right` side of the goal)\n"
"\n"
"You can `unfold` the goal if that facilitates your reasoning."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L11_allofus
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "allKnaves , exactlyOneIsKnave"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "A: All of us are knaves.\n"
"B: Exactly one of us is a knave."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "Start by proving `¬A.isKnight`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "Assume `A` is a knight, and conclude that everyone must be a knave."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "This would mean that `A` is also a knave, which is absurd.\n"
"\n"
"You can `unfold allKnaves at «{allKnave}»` and extract `A.isKnave` from that."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "`«{allKnave}».left` will do it."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "Now that `A` is not a knight, conclude that not everyone is a knave."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "Take cases for `B`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "Knowing that `B` is a knight, conclude that there is exactly one knave."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "Notice what we have at our disposal.\n"
"\n"
"We have `A` is a knave, `B` is a knight, and that there is exactly one knave. So `C` must be a knight.\n"
"\n"
"You can obtain `C` by using the fact that `A` is a knave, `B` is a knight and simplifying the expression `«{exactlyoneKnave}»`.\n"
"\n"
"`unfold` «{exactlyoneKnave}» first then use `simp`.\n"
"\n"
"If it doesn't get simplified enough, then change from `knight_to_knave` or vice versa the hypothesis involved."
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid "Now we are in the case where `B` is a knave.\n"
"\n"
"Notice what we have.\n"
"\n"
"We have that `A` is a knave, `B` is a knave, and that not everyone is a knave. \n"
"\n"
"So `C` must be a knight.\n"
"\n"
"Solving this is in the same spirit of what you previously did.\n"
"\n"
"`unfold allKnaves` then simplify it using the fact that `A,B` are knaves"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L12_prob32
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L13_31
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L13_31
msgid "Again we have three people, A, B, C, each of whom is either \n"
"a knight or a knave. A and B make the following statements: \n"
"A: All of us are knaves. \n"
"B: Exactly one of us is a knight. \n"
"What are A, B, C?\n"
"\n"
"Change the goal to `A.isKnave`"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L13_31
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L14_prob27
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L14_prob27
msgid "Suppose the stranger, instead of asking A what he is,\n"
"asked A, 'How many knights are among you?' Again A\n"
"answers indistinctly. So the stranger asks B, ;What did A\n"
"say? B replies, ;A said that there is one knight among us.;\n"
"Then C says, 'Don't believe B; he is lying!' \n"
"Now what are B and C?"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves.L14_prob27
msgid ""
msgstr ""

#: Game.Levels.DSL_Knights_Knaves
msgid "DSL Knights and Knaves"
msgstr ""

#: Game.Levels.DSL_Knights_Knaves
msgid "We will introduce the knights and knaves puzzle here explaining rules of the game and the corresponding lean representation.\n"
"\n"
"The setting is an island.\n"
"Every islander will make a statement. There are two types of islanders, 'knights' and 'knaves'.\n"
"\n"
"For a given islander `A`,\n"
"- The proposition that `A` is a knight\n"
"```\n"
"A.isKnight\n"
"```\n"
"- The proposition that `A` is a knave\n"
"```\n"
"A.isKnave\n"
"```\n"
"\n"
"Every islander is either a knight or a knave:\n"
"```\n"
"isKnight_or_isKnave (A : Islander)\n"
": A.isKnight ∨ A.isKnave\n"
"```\n"
"\n"
"Knights always tell the truth, and 'knaves' that always lie.\n"
"\n"
"`knight_said`. Whatever `knight_said` is true.\n"
"\n"
"```\n"
"-- A is a knight,\n"
"-- so whatever A said is true\n"
"knight_said\n"
"(stA : A said P)\n"
"(AKnight : A.isKnight) : P\n"
"```\n"
"\n"
"`said_knight`. If what is said is true, then knight. \n"
"\n"
"```\n"
"-- A said something true,\n"
"-- so A is a knight.\n"
"said_knight\n"
"(stA : A said P)\n"
"(hP : P) : A.isKnight\n"
"```\n"
"\n"
"`knave_said`. Whatever `knave_said` is false.\n"
"\n"
"```\n"
"-- A is a knave,\n"
"-- so whatever A said is false\n"
"knave_said \n"
"(stA : A said P) \n"
"(AKnave : A.isKnave) : ¬P\n"
"```\n"
"\n"
"`said_knave`. If what is said is false, then knave.\n"
"\n"
"```\n"
"-- A said something that is false(i.e a lie),\n"
"-- so A is a knave\n"
"said_knave\n"
"(stA : A said P)\n"
"(hnP : ¬P) : A.isKnave\n"
"```\n"
"\n"
"Since knights always tell the truth and knaves always lie, no islander can be both a knight and a knave.\n"
"```\n"
"not_isKnight_and_isKnave\n"
"(A : Islander) : ¬ (A.isKnight ∧ A.isKnave)\n"
"```\n"
"\n"
"The objective is to conclude who is a knight and who is a knave, based on the statements of several islanders. This will be done using logical reasoning."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "`A`: `B` is a knight and `C` is a knight.\n"
"\n"
"`B`: `C` is a knight and `A` is a knave."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Use `have` to set `¬A` as the new goal."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Assuming `hA : A`:\n"
"- Prove `BC : B ∧ C` from `stA` using `A`\n"
"- Prove `CnA : C ∧ ¬A` using `stB` , `BC.left : B`\n"
"- Prove `False` using `AKnight : A`,`CnA.right : ¬A`.\n"
"\n"
"Each can be done in one step, so the appropriate `have` syntax should be used."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Use `have` to set `¬C` as the new goal."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Assuming `hC : C`:\n"
"- Prove `hB : B` using `stB`, `C ∧ ¬A`\n"
"- Prove `hA : A` using `stA` , `B ∧ C`\n"
"- Prove `False` from `hA: A`,`hnA : ¬A`\n"
"\n"
"For proving `hB : B` , you would need to pass a proof of `C ∧ ¬A` to `stB.mpr`. The `\\<\\>` notation is appropriate here.(although you could just use"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Using `¬C`, we get `¬C ∨ A` which gives `¬B` using `stBn`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_
msgid "Robert says: Ira is my type.\n"
"Ira says: Robert is truthful.\n"
"\n"
"Ira is my type is translated as \n"
"```\n"
"( (Ira and Robert) or (¬Ira and ¬Robert) )\n"
"```\n"
"Notice that this is equivalent to `Ira ↔ Robert`\n"
"\n"
"Replace this expression in `stR` by `Ira ↔ Robert` using\n"
"```\n"
"iff_iff_and_or_not_and_not.symm\n"
": (a and b or ¬a and ¬b ) ↔ (a ↔ b)\n"
"```\n"
"\n"
"then use `stI` to prove `Robert` and obtain `Ira`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Generated from [here](https://philosophy.hku.hk/think/logic/knights.php)\n"
"\n"
"You have met a group of 3 islanders. Their names are `Xavier`, `Gary`, and `Alice`.\n"
"\n"
"`Gary` says: `Alice` is my type.\n"
"\n"
"`Alice` says: `Gary` never lies.\n"
"\n"
"`Gary` says: `Xavier` never lies."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Use `stA` to prove `Gary`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Use `Gary` to prove `Xavier` and `Alice` and close the goal.\n"
"\n"
"Remember the ⟨⟩ notation to close the goal."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_iff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_iff
msgid "`A`: `C` is a knight or `B` is a knight.\n"
"\n"
"`B`: `A` is a knight, if and only if `C` is a knight."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_iff
msgid "Use `have` to set `A` as the new goal.\n"
"\n"
"We want to prove `A`, to do this we will prove `¬¬A`(which is equivalent to `A`) i.e `¬A → False`. The tactic `by_contra` facilitates this, assuming `¬A` and changing the goal to `False`.\n"
"\n"
"This is called a proof by contradiction because we are assuming the negation of what we want to prove and getting a contradiction.\n"
"\n"
"Assuming `nA : ¬A`,\n"
"- Prove `nCnB : ¬C ∧ ¬B` from `stAn`\n"
"- Prove `AdiffC : ¬(A ↔ C)` from `stBn` , `nCnB.right : ¬B`\n"
"- Prove `AiffC : A ↔ C` from `iff_of_false (ha : ¬a) (hb : ¬b) : a ↔ b `, `nA:¬A` , `nCnB.left : ¬C`\n"
"- Prove `False` from `AdiffC : ¬(A ↔ C)`  `AiffC : (A ↔ C)`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_iff
msgid "Prove `CorB : C ∨ B` using `stA` , `«{hA}»`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_iff
msgid "Now consider cases for `CorB`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_iff
msgid "Prove `AiffC : A ↔ C` using `iff_of_true (ha : a) (hb : b) : a ↔ b` , `hA : A` , `h : C`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_iff
msgid "Prove `hB : B` using `stB` , `«{AiffC}»`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_iff
msgid "Prove the goal using `«{hA}»`, `«{hB}»` ,`h`.\n"
"\n"
"Use `constructor` tactic to split the goal in two, one would be proving the left side of `∧` and the other being the right side.\n"
"\n"
"The proof of the second case for `h : B` would require using `stB`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_iff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "`A`: `C` is a knave or `B` is a knight.\n"
"\n"
"`B`: `A` is a knave, if and only if `C` is a knight."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Use `have` to set `A` as the goal"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "We want to prove `A`, to do this we will prove `¬¬A` i.e `¬A → False`. The tactic `by_contra` facilitates this, assuming `¬A` and changing the goal to `False`.\n"
"\n"
"Assuming `hA : ¬A`:\n"
"- Prove `hCnB : C ∧ ¬ B` using `stAn` , `nA`.\n"
"- Prove `AsameC : ¬(¬A ↔ C)` using `stBn` , `hCnB.right : ¬B`\n"
"- Prove `nAiffC : ¬A ↔ C` using `iff_of_true` , `nA` , `hCnB.left : C`\n"
"- Prove `False` from `nAiffC` and `AsameC` therefore proving that `¬A → False` i.e `¬¬A` i.e `A`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Prove `nCorB : ¬C ∨ B` using `stA` , `«{hA}»`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Take cases for `«{nCorB}»`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Use `iff_of_true` to prove `A ↔ ¬C`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Use `iff_not_comm` to prove `C ↔ ¬A`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Prove `B` using `stB` , `CiffnA.symm : C ↔ ¬A`. (symm for symmetry)"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Given `hP : P` , `hQ : Q`, `hR : R` and the goal `P ∧ Q ∧ R` , you can close this goal using:\n"
"```\n"
"exact ⟨hP,hQ,hR⟩\n"
"```\n"
"where ⟨⟩ is typed as \\<>.(this is to avoid nesting `And.intro` inside another)"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Prove `nAiffC : ¬A ↔ C` using `stB` , `h`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Prove `AiffnC : A ↔ ¬C` using `iff_not_comm` , `nAiffC.symm : C ↔ ¬A`(symm for symmetry)."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Prove `hC : C` using `AiffnC : A ↔ ¬C` , `hA : A`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid "Split using `constructor` or use ⟨⟩ notation."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid "`A`: `B` is a knight or `C` is a knight.\n"
"`B`: `C` is a knave, if and only if `A` is a knave"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid "Use `have` to set `B` as the goal"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid "Assuming `nB : ¬B`:\n"
"- Prove `CdiffA : ¬(¬C ↔ ¬A)` using `stBn` , `nB`\n"
"- Using `simp` and `nB : ¬B` , reduce `stA` to `stA : A ↔ C`. (`B ∨ C` , `C` have the same truth value(for `C` being true or false) when `B` is false.\n"
"- Using `not_iff_not`, reduce `¬C ↔ ¬A` in `CdiffA` to `C ↔ A`.\n"
"- Prove `False` using `CdiffA` , `stA.symm : A ↔ C`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid "Prove `CsameA : C ↔ A` using `stB` , `«{hB}»`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid "Prove `BorC : B ∨ C` using `«{hB}»`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid "Prove `hA : A` using `stA` , `«{BorC}»`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid "Rewrite `CsameA` to `CsameA : C ↔ A` using `not_iff_not`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid "Prove `hC : C` using `«{CsameA}»` , `«{hA}»`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid "Use constructor"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L06_orIff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "`A`: If `C` is a knave, then `B` is a knave.\n"
"`B`: `A` is a knight, if and only if `C` is a knave."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "Use `have` to set `C` as the goal"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "Assuming `¬C` to prove `False` i.e `¬C → False` i.e `¬¬C` i.e `C`:\n"
"\n"
"- Since `¬C` is true by `nC : ¬C`, then `A ↔ ¬C` and `A` have the same truth value. \n"
"\n"
"In other words, if `A` is true then `A ↔ ¬C` is true, and if `A` is false then `A ↔ ¬C` is false.\n"
"\n"
"Use \n"
"```\n"
"iff_true_right (ha : a) : (b ↔ a) ↔ b\n"
"``` \n"
"to replace `A ↔ ¬C` with `A`.\n"
"(In our case, `b ↔ a` is `A ↔ ¬C`)\n"
"\n"
"This reduction would transform `stB` from\n"
"```\n"
"¬B ↔ ¬(A ↔ ¬C)\n"
"```\n"
"to\n"
"```\n"
"¬B ↔ ¬A \n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "- Rewrite `¬C` in `stA` with true using `eq_true`\n"
"- Rewrite `True → ¬B` in `stA` with `¬B` using `true_implies`\n"
"- Rewrite `¬B` in `stA` with `¬A` using `stBn`\n"
"- Prove `False` using `not_iff_self`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "Rewrite `¬C` in `stA` as `¬True` using `eq_true`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "Rewrite `¬True` in `stA` as `False` using `not_true`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "Rewrite `False → ¬B` in `stA` as `¬B` using `false_implies`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "Rewrite `stA` using `iff_true_iff`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "- Use simp and `hC : C` to simplify `stB`\n"
"- Rewrite `stB` using `iff_not_comm` obtaining `stB : A ↔ ¬B`\n"
"- Prove `¬B` using and conclude the goal"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L07_imp
msgid "This is it for this approach of knights and knaves.\n"
"\n"
"If you want more, you can try the other approaches."
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "Knights and Knaves, Second Approach"
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "Say we have an islander `A` who could be a knight or a knave.\n"
"\n"
"`A` is represented as\n"
"```\n"
"A : Prop\n"
"```\n"
"where having the proposition `A` being true means the islander `A` is a knight and having the proposition `A` being false means the islander `A` is a knave.\n"
"\n"
"Now, we intrepret having a proof of `A` as `A` being a knight, and having a proof of `¬A` as `A` being a knave.\n"
"\n"
"From this, every islander being a knight or a knave is represented as follows:\n"
"```\n"
"A or ¬A\n"
"```\n"
"\n"
"Knights always tell the truth, so if `A` makes some statement `P` we have that `A` being a knight implies that the statement `P` is true\n"
"```\n"
"A → P\n"
"```\n"
"Moreover, the statement `P` being true means that `A` is telling the truth i.e is a knight\n"
"```\n"
"P → A\n"
"```\n"
"which can be combined as\n"
"```\n"
"A ↔ P\n"
"```\n"
"\n"
"Similarly for `A` being a knave which implies that the statement `P` is false\n"
"```\n"
"¬A → ¬P\n"
"```\n"
"Moreover, the statement `P` being false means that `A` is lying i.e is a knave\n"
"```\n"
"¬P → ¬A\n"
"```\n"
"which are combined as \n"
"```\n"
"¬A ↔ ¬P\n"
"```\n"
"\n"
"No islander can be a knight and a knave at the same time because\n"
"```\n"
"A ∧ ¬A\n"
"```\n"
"is false.\n"
"\n"
"This representation captures the rules of the knights and knaves puzzle which are:\n"
"- Every islander is either a knight or a knave\n"
"- No islander is both a knight and a knave at the same time\n"
"- Knights always tell the truth, knaves always lie.\n"
"\n"
"All puzzles in this world were generated(and possibly modified) from [wolfram cloud demonstration](https://www.wolframcloud.com/objects/demonstrations/KnightsAndKnavesPuzzleGenerator-source.nb)\n"
"\n"
"Note that you could also take a more explicit truth table approach, where you list all the cases in a truth table and eliminate the cases which contradict the rules of the game(e.g `A` being a knight but `A`'s statement being false). If you are left with one possibility then the puzzle has a unique solution, otherwise it has multiple solutions.\n"
"This can be done in [prolog](https://www.youtube.com/watch?v=oEAa2pQKqQU) and [other provers](https://summerofgodel.blogspot.com/2019/04/part-6-propositional-logic-approach-to.html)"
msgstr ""

#: Game
msgid "Knights And Knaves Game"
msgstr ""

#: Game
msgid "This is a gamification of mathematical proofs. Every level has a `Goal`, which is what you are trying to prove. Closing the `Goal` means you have proved the theorem and there is nothing else to do.\n"
"\n"
"You will use the `Lean` theorem prover, and its mathematical library `mathlib`.\n"
"\n"
"# Right Side Pane\n"
"Let's explain what's going on in the right side pane.\n"
"\n"
"This is where you can find the tactics, definitions, and theorems at your disposal which were introduced in previous levels.\n"
"\n"
"Clicking on one will display an overview and some examples. This will be available to you at all times when working on the levels. Refer back to it whenever you need to.\n"
"\n"
"Any new tactic, theorem, or definition introduced in a level will be highlighted in a yellow color.\n"
"\n"
"We now discuss each section in the right side pane.\n"
"(note that you can view the official documentation of tactics or theorems by hovering over a term when you are in editor mode, you can enter editor mode by clicking the icon next to the hamburger menu that is in the top right hand corner)\n"
"## Tactics\n"
"In this puzzle game, you will use tactics to manipulate the `Goal` and close it, essentially proving the `Goal`. Tactics will be incrementally introduced, and tactics that haven't been introduced yet will have a lock icon which means you can't use them yet. \n"
"\n"
"## Definitions\n"
"The point of this game is not just to showcase ***Lean***, but also to learn some mathematics. Relevant definitions will be displayed here.\n"
"\n"
"## Theorems\n"
"Here is listed theorems to use throughout the levels. Some you would have proved in previous levels and others are presented for you to use but without having proved them. An intuitive definition of why the theorem makes sense will be presented as well when it is introduced.\n"
"\n"
"# Level Structure\n"
"Within every level, you have the `Objects`(if any), `Assumptions`(if any), and `Goal` for the current level. This is called the initial proof state. \n"
"\n"
"There will also be a text input to execute tactics accordingly.\n"
"\n"
"***Lean*** tracks the proof state as you execute tactics and makes sure you made no mistakes.\n"
"You will execute tactics one by one until Lean tells you that you have closed the goal.\n"
"\n"
"# More info\n"
"You can click the hamburger menu in the top right then 'Game Info' for more information."
msgstr ""

#: Game
msgid "Many technical details have been skipped for the sake of not getting bogged down with `Lean` and its mathematical library `mathlib`, but focus on the aspects of reasoning and proof. You can search https://leanprover-community.github.io/mathlib4_docs/ for more information about any tactic or theorem used.\n"
"\n"
"# Editor Mode \n"
"Some levels will force you to use editor mode. Editor mode is necessary for multiline tactics like `have`. Moreover, you should get used to it because it mimics a vscode `Lean` environment which is the most common way `Lean` is run.\n"
"\n"
"To access editor mode, click on the icon next to the hamburger menu in the top right.\n"
"\n"
"## vscode like environment\n"
"Hovering over things will give you the official documentation of things.\n"
"\n"
"# Links\n"
"## documentation\n"
"https://leanprover-community.github.io/\n"
"\n"
"https://lean-lang.org/\n"
"\n"
"https://lean-lang.org/documentation/\n"
"\n"
"https://github.com/leanprover-community/mathlib4\n"
"\n"
"## zulip, ask questions\n"
"Zulip chat for lean has been a very useful resource to resolve issues when formalizing the exercises, you can visit it and ask questions in the '#new members' stream. You can also view messages without signing up. There are other streams dedicated to various topics you can check out as well.\n"
"\n"
"https://leanprover.zulipchat.com/\n"
"\n"
"https://zulip.com/case-studies/lean/\n"
"\n"
"## Knights and Knaves\n"
"Sources for the puzzles:\n"
"- Puzzle Generator(some of which were taken as is, and others were modified):\n"
"https://www.wolframcloud.com/objects/demonstrations/KnightsAndKnavesPuzzleGenerator-source.nb\n"
"- Raymond smullyan's book called 'What is the name of this book'\n"
"\n"
"Insightful:\n"
"- Knights and Knaves in a logic programming language(prolog):\n"
"https://www.youtube.com/watch?v=oEAa2pQKqQU\n"
"\n"
"- Blog post series, includes introduction ,representation and formalization, automated solutions using other provers, and creating your own puzzles.\n"
"https://summerofgodel.blogspot.com/2019/04/table-of-contents-for-series-of-posts.html?\n"
"\n"
"# Rules\n"
"You can relax the rules and skip levels.\n"
"\n"
"This is not recommended for people who have never heard about Lean before. Moreover, relaxing the rules would ruin the coherence and structured/guided experience you would have when playing the game normally. If that is what you are looking for, then don't relax the rules.\n"
"\n"
"# Github\n"
"The game's repository is [here](https://github.com/JadAbouHawili/KnightsAndKnaves-Lean4Game)\n"
"\n"
"You can view the code for every level there.(and the solution if you are really stuck)\n"
"\n"
"# Shoutouts, other educational games\n"
"Knights and Knaves education game:(games on other topics are available as well)\n"
"https://en.oiler.education/bul\n"
"\n"
"Generate and solve:\n"
"https://christopherphelps.trinket.io/sites/knight_knave_puzzler"
msgstr ""

#: Game
msgid "From the basics to Knights And Knaves"
msgstr ""

#: Game
msgid "A guided experience that teaches you everything you need to know to understand and solve knights and knaves logic puzzles, including the basics of lean and basic logic.\n"
"\n"
"Based on statements made, you will deductively conclude who is a knight(truthful) and who is a knave(liar)."
msgstr ""
