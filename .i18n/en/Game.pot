msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Wed Dec 11 22:30:21 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Doc.doc
msgid "Unfoldable:\n"
"unfold Not at ...\n"
"¬¨P is P ‚Üí False\n"
"\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & ¬¨P \\\\\n"
"\\hline\n"
"T & F \\\\\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that this definition is an implication and that the truth table with `¬¨P` and the truth table with `P ‚Üí False` are identical.\n"
"\n"
"What this means is that to prove `¬¨P`, we assume `P` and derive a contradiction i.e constructing an object of type `False`. \n"
"In other words, having `¬¨P` as a goal, you have to start the proof with `intro` because you are proving an implication.\n"
"\n"
"It represents a contradiction. `False` elimination rule, `False.rec`,\n"
"expresses the fact that anything follows from a contradiction.\n"
"This rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\n"
"or the principle of explosion.\n"
"For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"
"\n"
"`False` is an 'empty' type that has no introduction rule. \n"
"\n"
"`False` is the empty proposition. Thus, it has no introduction rules.\n"
"\n"
"Proving `False` means deriving a contradiction. So, to prove `¬¨p` , you must assume `p` and derive a contradiction."
msgstr ""

#: Game.Doc.doc
msgid "Such a system having `False` or a contradiction is called an inconsistent system.\n"
"\n"
"Any proposition is true and studying the current system becomes worthless."
msgstr ""

#: Game.Doc.doc
msgid "You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time).\n"
"\n"
"Moreover, these statements are denoted by a symbol like `P`,`Q`,`R`.\n"
"\n"
"For an object of type P where P is of type Prop, i.e `h : P` where `P : Prop`, `h` would be a proof or a witness that `P` is true. Equivalently, from `h` we can construct a term `h' := eq_true h of type `h' : P = True` which would be a proof that P is true as well. Both perspectives are interchangeable and equivalent.\n"
"\n"
"# Constructing new propositions from old ones\n"
"The atomic propositions in the compound proposition `p ‚àß q` are : `p`, `q`. Of course, `p ‚àß q` can be used to construct more complicated propositions.\n"
"\n"
"## Connecting Propositions With A Logical Connective\n"
"It is important to note that connecting two proposition via a logic connective results in a proposition as well. If this wasn't the case, then how could we talk about the truth value of `P ‚àß Q` if `P ‚àß Q` were not a proposition! This proposition constructed using a logical connective and other propositions, like any other proposition, has a truth value. This truth value depends on the truth value of the propositions it was built out of and the rules of the logical connective. This is clearly illustrated in a truth table. \n"
"\n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects."
msgstr ""

#: Game.Doc.doc
msgid "# truth table\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\\\\\n"
"\\hline\n"
"F & T & T \\\\\\\\\n"
"\\hline\n"
"F & F & T \\\\\\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Logical implication `P ‚Üí Q` is made up of two components:\n"
"- The premise, which in this case is `P`\n"
"- The conclusion, which in this case is `Q`\n"
"\n"
"A statement `P ‚Üí Q` is false when `P` is true and `Q` false, it's true otherwise.\n"
"\n"
"What logical implication does is that it takes evidence or proof for `P` and transforms it returning a proof of `Q`.\n"
"The truth of `P` IMPLIES the truth of `Q`. A proof of `P` IMPLIES a proof of `Q`.\n"
"\n"
"In other words, it acts like a function. If you give `P ‚Üí Q` a proof of `P`, you get a proof of `Q`."
msgstr ""

#: Game.Doc.doc
msgid "`And.intro` takes a proof of `P`, a proof of `Q`, and transforms/evaulates them to a proof of `P ‚àß Q` where `P Q : Prop`.\n"
"\n"
"Truth table:\n"
"\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects.\n"
"The following truth table illustrates this for the previously discussed `‚àß` connective.\n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & F \\\\\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that `P ‚àß Q` is true when both `P` is true and `Q` is true, being false otherwise."
msgstr ""

#: Game.Doc.doc
msgid "# Truth Table\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚à® Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & T \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"From the truth table, we can see that if one of `P`,`Q` is true then `P ‚à® Q` is true. \n"
"\n"
"Therefore, if we have `P ‚à® Q` as our goal, it is enough to prove `P` or to prove `Q`.\n"
"\n"
"Having `P ‚à® Q` as the goal, you can tell Lean that you want the left side by simply typing `left` or the right side by simply typing `right`."
msgstr ""

#: Game.Doc.doc
msgid "`‚à©` is an operator on sets.\n"
"\n"
"Applying it to two sets `A`,`B`:\n"
"```\n"
"A ‚à© B\n"
"```\n"
"\n"
"`A ‚à© B` is itself another set, containing elements that are in both `A` and `B`.\n"
"\n"
"`A ‚à© B = ‚àÖ` means that `A` and `B` have no common element i.e no element of `A` belongs to both and no element of `B` belongs to both."
msgstr ""

#: Game.Doc.doc
msgid "`rfl` is short for reflexivity. In the context of numbers, it is the property that for any number `a`, `a = a`.\n"
"\n"
"More generally, the `rfl` tactic will close all goals of the form `X=X`, regardless of what `X` is, `X=Y` where `X` and `Y` are identical. rfl can also prove the equality of two things that are 'equal by definition'.\n"
"\n"
"In fact, `rfl` is not a tactic but syntactic sugar for `exact rfl`. `rfl` is of type `a = a` for any `a`.\n"
"\n"
"\n"
"\n"
"`rfl` also applies more generally, `rfl` will close any goal of the form `A=B` where `A`,`B` are identical. If needed, `rfl` will unfold both sides into their definitions and then check if they are equal. In other words, `rfl` can prove the equality of two things that are 'equal by definition'.\n"
"## examples\n"
"```\n"
"x - 7 = x - 7\n"
"```\n"
"`rfl` will close this goal."
msgstr ""

#: Game.Doc.doc
msgid "Contradiction is a tactic that detects if you have contradictory assumptions and if so, closes the goal."
msgstr ""

#: Game.Doc.doc
msgid "Given the following:\n"
"```\n"
"Assumptions:\n"
"h : A = B\n"
"\n"
"Goal:\n"
"some expression involving A\n"
"```\n"
"\n"
"`rw [h]` would change the goal by replacing every occurrence of `A` with `B`.\n"
"\n"
"By default, rw uses an equation in the forward direction, matching the left-hand side of the equation with an occurrence of that in the goal, and replaces it with the right-hand side. \n"
"\n"
"The notation ‚Üêt can be used to instruct the tactic to use the equality t in the reverse direction."
msgstr ""

#: Game.Doc.doc
msgid "Having the goal of the form:\n"
"```\n"
"P ‚à® Q\n"
"```\n"
"for `P Q : Prop`, `left` transforms the goal to `P`."
msgstr ""

#: Game.Doc.doc
msgid "Having the goal of the form:\n"
"```\n"
"P ‚à® Q\n"
"```\n"
"for `P Q : Prop`, `right` transforms the goal to `Q`."
msgstr ""

#: Game.Doc.doc
msgid "[[mathlib_doc]]\n"
"There is an alternative syntax for `have` which you can view in the right side pane. In any case, it will be introduced later on when its more convenient to use.\n"
"`have name := ........`"
msgstr ""

#: Game.Doc.doc
msgid "Refer to `Prop` documentation if you need to.\n"
"\n"
"## Overview\n"
"For the following proof state:\n"
"```\n"
"Objects\n"
"P : Prop\n"
"\n"
"Assumptions\n"
"hP : P\n"
"\n"
"Goal:\n"
"P\n"
"```\n"
"Remember that `hP : P` where `P : Prop` means `hP` is a proof of `P`.\n"
"\n"
"Since the goal is to prove `P`, the only thing we have to do is to let Lean know that we do have such a proof. In other words, `hP` is EXACTLY whats needd to prove the goal. The type of `hP` EXACTLY matches the goal.\n"
"\n"
"exact h asserts that h is exactly whats needed to prove the goal which makes sense because h is a proof of P.(It doesn't matter what P is)\n"
"This is done by `exact h`."
msgstr ""

#: Game.Doc.doc
msgid "```\n"
"`have name-of-object : type := by ...` \n"
"```\n"
"where `...` is the proof.\n"
"`name-of-object` can be whatever you want, leaving it empty would  give the theorem a name automatically. The `type` in this case is the statement we want to prove."
msgstr ""

#: Game.Doc.doc
msgid "The `contradiction` tactic works for the following proofs states:\n"
"```\n"
"h : False\n"
"```\n"
"\n"
"```\n"
"hP : P\n"
"hnP : ¬¨P\n"
"```\n"
"\n"
"and\n"
"```\n"
"hP : P\n"
"```\n"
"where Lean knows that `¬¨P` is true.\n"
"\n"
"Example:\n"
"-- disjoint\n"
"You need to show that having two sets being disjoint (i.e sharing no common element) and having a common element is a contradiction."
msgstr ""

#: Game.Doc.doc
msgid "Another way to express this is that you have two possibilities one of which(or both) is supposed to be true, and you know its definitely not the second option. All is left is the first option. \n"
"\n"
"Given the statement, its either 'this' or 'that'. If we know its not 'that' then its definitely 'this'."
msgstr ""

#: Game.Doc.doc
msgid "A summary of all the terminology presented throughout the game, in order of appearance.\n"
"\n"
"Theorems represent an implication say:\n"
"```\n"
"thm : P ‚Üí Q\n"
"```\n"
"\n"
"They work for `P`,`Q` of any type. What `thm` means is the following, give me an object of type `P` and i will return an object of type `Q`. \n"
"\n"
"Therefore, theorems expect arguments given in a specific order after which the obtained expression is an object which has the conclusion as its type.\n"
"\n"
"For\n"
"```\n"
"thm : P ‚Üí Q\n"
"hP : P\n"
"```\n"
"`(thm hP) : Q`\n"
"\n"
"For the special case where `P : Prop`, `Q : Prop` ,the interpretation of `thm` is what implication in logic means.  \n"
"\n"
"What `thm` means is the following, give me an object of type `P` which in this case is a proof of `P` and i will return an object of type `Q` which in this case is a proof of `Q`. \n"
"\n"
"In other words, `thm` means 'If P is true, then Q is true'."
msgstr ""

#: Game.Doc.doc
msgid "## Definition\n"
"A set is a collection of 'entities' or 'objects' that satisfy a certain property. The objects in a set are called 'elements' of the set.\n"
"\n"
"A finite set is a set with finitely many elements.\n"
"\n"
"## Examples\n"
"The set `Knight` would be the set of inhabitants of the island that are knights i.e satisfying the property of always telling the truth, the set `Knave` being the set of inhabitants of the island that are knives i.e the ones that always lie. \n"
"\n"
"## In Lean\n"
"```\n"
"Set K\n"
"```\n"
"\n"
"```\n"
"Finset K\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid "## Objects\n"
"\n"
"The objects involved are:\n"
"- of type inhabitant indicated by a capital letter\n"
"- the two finite sets `Knight` , `Knaves`.\n"
"\n"
"As a proof state:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"B : Inhabitant \n"
"C : Inhabitant\n"
"Knight : Finset Inhabitant\n"
"Knave : Finset Inhabitant\n"
"```\n"
"There will be at most three inhabitants in the puzzles for simplicity, but you can ofcourse have more.\n"
"\n"
"## Assumptions\n"
"Knights tell the true and knaves lie. So no one can be both at the same time i.e `Knight ‚à© Knave = ‚àÖ`\n"
"\n"
"Moreover, every inhabitant is either a knight or a knave i.e `A ‚àà Knight ‚à® A ‚àà Knave` for any `A : Inhabitant`.\n"
"\n"
"As a proof state:\n"
"```\n"
"Assumptions:\n"
"h : Knight ‚à© Knave = ‚àÖ \n"
"Or : A ‚àà Knight ‚à® A ‚àà Knave\n"
"```\n"
"\n"
"## Summary\n"
"Putting every together:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"B : Inhabitant \n"
"C : Inhabitant\n"
"Knight : Finset Inhabitant\n"
"Knave : Finset Inhabitant\n"
"\n"
"Assumptions\n"
"h : Knight ‚à© Knave = ‚àÖ \n"
"Or : A ‚àà Knight ‚à® A ‚àà Knave\n"
"```\n"
"\n"
"## Translating statements to formal notation\n"
"Knight version...\n"
"Given inhabitant `A`:\n"
"\n"
"The translation we use is based on the following:\n"
"- If `A` is a knight, then `A`'s statement is true.\n"
"- If `A`'s statement is true, then `A` is a knight.\n"
"\n"
"Formally:\n"
"```\n"
"A ‚àà Knight ‚Üí stA\n"
"stA ‚Üí A ‚àà Knight\n"
"```\n"
"\n"
"If,\n"
"```\n"
"A says B is a knave\n"
"```\n"
"\n"
"then,\n"
"```\n"
"A ‚àà Knight ‚Üí B ‚àà Knave\n"
"B ‚àà Knave ‚Üí A ‚àà Knight\n"
"```\n"
"\n"
"Combining them using `‚Üî`:\n"
"```\n"
"A ‚àà Knight ‚Üî B ‚àà Knave\n"
"```\n"
"\n"
"### equivalent translations, using knaves\n"
"Given inhabitant `A`:\n"
"\n"
"The translation we use is based on the following:\n"
"- If `A` is a knave, then `A`'s statement is false, i.e its negation is true.\n"
"- If `A`'s statement is false, then `A` is a knave.\n"
"\n"
"Formally:\n"
"```\n"
"A ‚àà Knave ‚Üí ¬¨stA\n"
"¬¨stA ‚Üí A ‚àà Knave\n"
"```\n"
"\n"
"If,\n"
"```\n"
"A says B is a knave\n"
"```\n"
"\n"
"then,\n"
"```\n"
"A ‚àà Knave ‚Üí ¬¨(B ‚àà Knave)\n"
"¬¨(B ‚àà Knave) ‚Üí A ‚àà Knave\n"
"```\n"
"\n"
"Combining them using `‚Üî`:\n"
"```\n"
"A ‚àà Knave ‚Üî ¬¨(B ‚àà Knave)\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid "### **Logic Constants & Operators**\n"
"### **Equational Reasoning**\n"
"| $Name~~~$ | $Ascii~~~$ | $Unicode$ | $Unicode Cmd$ |\n"
"| --- | :---: | :---: | --- |\n"
"|     |       |       | `mul_left_cancel\\0`|\n"
"| True | `True` |  |  |\n"
"| False | `False` |  |  |\n"
"| Not | `Not` | ¬¨ | `\\n` `\\not` `\\neg` `\\lnot` |\n"
"| And | `/\\` | ‚àß | `\\and` `\\an` `\\wedge` |\n"
"| Or | `\\/` | ‚à® | `\\v` `\\or` `\\vee` |\n"
"| Implies | `->` | ‚Üí | `\\r` `\\imp` `\\->` `\\to` `\\r-` `\\rightarrow` |\n"
"| Iff | `<->` | ‚Üî | `\\iff` `\\lr-` `\\lr` `\\<->` `\\leftrightarrow` |\n"
"| For All | `foral` | ‚àÄ | `\\all` `\\forall` |\n"
"| Exists | `exists` | ‚àÉ | `\\ex` `\\exists` |\n"
"\n"
"### **Other Unicode**\n"
"| $Name$ | $Unicode~~~$ | $Unicode Cmd$ |\n"
"| --- | :---: | --- |\n"
"| Angle brackets | ‚ü® ‚ü© | `\\<` `\\>` `\\langle` `\\rangle` |\n"
"| Subscript Numbers | ‚ÇÅ ‚ÇÇ ‚ÇÉ ... | `\\1` `\\2` `\\3` ... |\n"
"| Left Arrow | ‚Üê | `\\l` `\\leftarrow` `\\gets` `\\<-` |\n"
"| Turnstyle | ‚ä¢ | `\\‚îÇ-` `\\entails` `\\vdash` `\\goal` |\n"
"\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"Unicode & Text \\\\\n"
"\\hline\n"
"\\text{mul\\_left\\_cancel‚ÇÄ} & `mul\\_left\\_cancel\\0` \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"mul_left_cancel‚ÇÄ written as mul_left_cancel\\0"
msgstr ""

#: Game.Doc.doc
msgid "[[mathlib_doc]]"
msgstr ""

#: Game.Doc.doc
msgid "As an implication\n"
"```\n"
"Knight ‚à© Knave = ‚àÖ ‚Üí\n"
"A ‚àà Knight ‚à® A ‚àà Knave ‚Üí\n"
"(A ‚àà Knight ‚Üî A ‚àà Knave) ‚Üí False\n"
"```"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "`rfl`, A Number Equals Itself"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "In this exercise, we will prove `2 = 2`\n"
"\n"
"`rfl` will do the job.\n"
"\n"
"`rfl` is short for reflexivity, which is the property that for any number `a`, `a = a`"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "Notice that 'level completed! üéâ' on the bottom. We say that the goal is closed/proven."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "`exact` , goal is true by assumption"
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "In this level, we have `Objects`, `Assumptions`, and the `Goal`.\n"
"\n"
"# Objects\n"
"Objects will always be variables(letter symbols) we are working with. What these variables denote is specified after the `:`, what is after the `:` is called the type of the object.  \n"
"\n"
"Here, `x`  denotes a number but we don't know which number it is. The `: ‚Ñï` in `x : ‚Ñï` means that `x` is a variable of type natural number(positive numbers like `1`,`2`,`3`, and so on...). \n"
"\n"
"# Assumptions\n"
"As for the assumptions, we have `h : x=2` which means that `h` is an object of type `x=2`. This essentially means that `h` is an object asserting that the proposition(or statement) `x=2` is true. In other words, we know that `x=2` and `h` is a proof of that. \n"
"\n"
"# Goal\n"
"Our goal is to prove that `x = 2`.\n"
"Always look at the assumptions which represent everything you know. Well, we already have that `h` is a proof of the goal. \n"
"We should let Lean know. Using `exact h` accomplishes this."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "The `exact` in `exact h` tells Lean that `h`'s type EXACTLY matches the goal. In other words, `h` is EXACTLY what we need to prove the goal. Lean verifies this and reports that there are no more goals to prove. We are done.\n"
"\n"
"The `assumption` tactic can also be used here which searches for an assumption that matches the goal, and closes the goal if it finds one."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Substituting Variables By Their Values"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "We will learn how to substitute a variable with its value, for example how to substitiute `x` by `2` if we know that `x=2`.\n"
"\n"
"This can be done using the tactic `rw` (short for rewrite).\n"
"\n"
"`rw` takes a term of type `A=B` and replaces all the `A`s in the goal with `B`s.\n"
"So `rw [h]` where `h : x=3` will replace all the `x`s of the goal with `3`."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Do `rw [¬´{h}¬ª]` or `rw [¬´{g}¬ª]` and observe what happens."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "You should use `¬´{h}¬ª` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "`rw [h]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "You should use `¬´{g}¬ª` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "`rw [g]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Our goal is now `3 + 3 = 6`. The `rw` tactic implicitly executes `rfl` after doing the rewrite which unfolds the numbers `3` and `6` to what they are defined as, and it turns out both sides are identical. I would recommend the natural number game if you want to learn more.\n"
"\n"
"Another solution:\n"
"```\n"
"rw [h,g]\n"
"```\n"
"instead of \n"
"```\n"
"rw [h]\n"
"rw [g]\n"
"```"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "`Nat.mul_left_cancel` , Divide both sides of an equation"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "We know that `4 * y = 16`. Dividing both sides by `4` gives us `y = 4` which is the goal.\n"
"\n"
"The theorem to do this is:\n"
"```\n"
"Nat.mul_left_cancel firstarg secondarg\n"
"```\n"
"where the `firstarg` is a theorem that the number you are cancelling from both sides is positive, in our case this would be `four_pos`. \n"
"\n"
"The `secondarg` would be the equation you are working with, in this case `h`.\n"
"\n"
"`Nat.mul_left_cancel firstarg secondarg` would be a proof of the resulting equation after cancelling the positive number specified in `firstarg` from both sides of the equation specified in `secondarg`.\n"
"\n"
"Give this proof to Lean using `exact`."
msgstr ""

#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "Here is the type signature of Nat.mul_left_cancel:\n"
"  ```\n"
"Nat.mul_left_cancel {n m k : ‚Ñï} (np : 0 < n) (h : n * m = n * k) : m = k\n"
"  ```\n"
"  `Nat.mul_left_cancel` takes two arguments which are:\n"
"   - `np`, a proof that some number `n` is positive.\n"
"   - `h`, the equation which has `n` on both sides of the equation multiplied on the left.\n"
"\n"
"  The result is canceling `n` from both sides of the equation."
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "Equational Reasoning"
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "In this world, you will learn how to solve equations."
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "This should look familiar.\n"
"\n"
"If it doesn't, then replace `P` by `x=2`.\n"
"\n"
"`hP` is of type `P` and `P` is of type `Prop`. So, `hP` is a proof of `P`. Our goal is to prove `P`. We already have such a proof which is `hP`, `hP` is EXACTLY what we need to prove the goal. The type of `hP` EXACTLY matches the goal."
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Type `exact hP`!"
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "In the next levels, we will discuss how to construct new propositions from old ones whose meaning and truth value would depend on those old ones."
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "And"
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "In this level, we introduce the `‚àß` logical connective (read as 'and'). You can think of `‚àß` as taking to input proposition and outputting a new proposition.\n"
"\n"
"Remember the example given at the beginning of the world? We restate it here:\n"
"Given the two propositions `x=2`(`P`), `y=6`(`Q`) , we can construct a new propositon `x=2 ‚àß y=6`(`P ‚àß Q`) which is read as `x=2 and y=6`(`P and Q`).\n"
"\n"
"What is the truth value of this new proposition `x=2 ‚àß y=6`(`P ‚àß Q`)? \n"
"Well, it would depend on truth value of the two component propositions `x=2`(`P`) ,`y=6`(`Q`).\n"
"\n"
"What possibilities are there for each's truth value? `x=2` (`P`) can either be true or false and similarly for `y=6`(`Q`). Here is a truth table that goes through all these possibilities: \n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"x=2 & y=6 & x=2 ‚àß y=6 \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & F \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"\n"
"The proposition `x=2 ‚àß y=6`(`P ‚àß Q`) is true when `x=2`(`P`) is true AND `y=6`(`Q`) is true.\n"
"In other words, if `P` is true AND `Q` is true. This is how things work regarless of what `P` is, what `Q` is. The only thing that matters is their truth value.\n"
"Therefore, the more general truth table is the same:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & F \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"\n"
"Notice that `P ‚àß Q` is true when both `P` is true and `Q` is true, being false otherwise.\n"
"\n"
"From this, we conclude that we can introduce `‚àß` if we have a proof of `P` and a proof of `Q`. The `‚àß` introduction rule takes these two proofs giving us `P ‚àß Q`:\n"
"```\n"
"  And.intro  (left : P) (right : Q) : P ‚àß Q\n"
"```\n"
"\n"
"Use it to construct an object of type `P ‚àß Q`, and use `exact` to close the goal."
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "Try `exact And.intro hP hQ` or `constructor`"
msgstr ""

#: Game.Levels.Logic.L02_And
msgid ""
msgstr ""

#: Game.Levels.Logic.L07_Or
msgid "Or, `‚à®`"
msgstr ""

#: Game.Levels.Logic.L07_Or
msgid "In this level, we introduce the `‚à®` logical connective read as 'or'.\n"
"\n"
"Its truth table is as follows:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚à® Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & T \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"From this truthtable, we conclude that to prove `P ‚à® Q`,  we need either `P` being true or `Q` being true or both.\n"
"\n"
"You can tell Lean which side of `‚à®` you want to prove by simply executing `left` or `right`.\n"
"\n"
"In our case, we know the left side of `‚à®` is true, so use `left`."
msgstr ""

#: Game.Levels.Logic.L07_Or
msgid "We have a proof that `P` is true, and we want to prove `P`"
msgstr ""

#: Game.Levels.Logic.L07_Or
msgid ""
msgstr ""

#: Game.Levels.Logic.L09_Implication
msgid "Implication, ‚Üí"
msgstr ""

#: Game.Levels.Logic.L09_Implication
msgid "In this level, we introduce the logical implication `‚Üí` connective.\n"
"Logical implication `P ‚Üí Q` is made up of two components:\n"
"- The premise, which in this case is `P`\n"
"- The conclusion, which in this case is `Q`\n"
"\n"
"# truth table\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & T \\\\\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"A statement `P ‚Üí Q` is false when `P` is true and `Q` false, it's true otherwise.\n"
"This is because this is the only case where the meaning of `P ‚Üí Q` is violated i.e we have that `P` is true so `Q` is supposed to be true as well but its not.\n"
"\n"
"We know `P` (i.e `P = True`) , and we know `P ‚Üí Q` (i.e `P = True ‚Üí Q = True`). We can now conclude `Q` (i.e `Q = True`).\n"
"\n"
"What logical implication does is that it takes evidence or proof for `P` and transforms it returning a proof of `Q`.\n"
"The truth of `P` IMPLIES the truth of `Q`. A proof of `P` IMPLIES a proof of `Q`.\n"
"\n"
"In other words, it acts like a function. If you give `P ‚Üí Q` a proof of `P`, you get a proof of `Q`."
msgstr ""

#: Game.Levels.Logic.L09_Implication
msgid "In this level, you will learn how to deal with an implication as the goal you have to prove."
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid ""
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "The goal, translated to normal english is: 'If P is true, then P is true'.\n"
"\n"
"To prove such a goal, we need to assume that `P` is true. Then, we have to prove that `P` is true.\n"
"\n"
"To do this, we need to assume the premise i.e introduce it to our assumptions. We can do this using `intro`.\n"
"\n"
"After that , we have to prove the consequent."
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "use `intro name` to give the introduced hypothesis a name"
msgstr ""

#: Game.Levels.Logic.L11_Not
msgid "Not Connective, ¬¨"
msgstr ""

#: Game.Levels.Logic.L11_Not
msgid "In this level we introduce the negation, the `¬¨` connective (read as 'not').\n"
"\n"
"Notice that this is the first logical connective that applies on one proposition only and not two.\n"
"\n"
"The job of this connective(as the name implies), is to negate a proposition meaning that:\n"
"- For `P` true, `¬¨P` is false.\n"
"- For `P` false, `¬¨P` is true.\n"
"\n"
"In truth table form:\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & ¬¨P \\\\\n"
"\\hline\n"
"T & F \\\\\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"But we don't need to introduce a new symbol, it can be defined in terms of what we already know.\n"
"\n"
"Consider the following truth table: \n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & P ‚Üí False \\\\\n"
"\\hline\n"
"T & F  \\\\\n"
"F & T  \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that regardless of the truth value of `P`, the two propositions `¬¨P` and `P ‚Üí False` have the same truth table. Therefore, they can be used interchangeably.(we say that these two expressions are logically equivalent, but let's leave this to a future level)\n"
"\n"
"In fact, this is how `¬¨P` is defined in Lean. You can do `unfold Not at hnP` to replace `¬¨P` with its implication form.\n"
"\n"
"Remember that an implication acts like a function, that takes a proof of whats on the left hand returning a proof of whats on the right hand side.\n"
"\n"
"For this level, `¬¨P` being true tells us that a proof of `P` gives us a proof of `False`. We have a proof of `P`. Therefore we can obtain a proof of `False` which is the goal."
msgstr ""

#: Game.Levels.Logic.L11_Not
msgid "In the next level, we will explore what it means to have proven `False`."
msgstr ""

#: Game.Levels.Logic.L12_False
msgid "From `False`, anything follows."
msgstr ""

#: Game.Levels.Logic.L12_False
msgid "We proved `False`, what does this mean? What can we conclude? What does `False` IMPLY?\n"
"\n"
"Let's check the `‚Üí` truth table:\n"
"$$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$$\n"
"\n"
"Let's focus on part of the truth table where `P` is `False`, because we want to see what `False` implies.\n"
"$$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"Q & False ‚Üí Q \\\\\n"
"\\hline\n"
"T & T \\\\\n"
"\\hline\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$$\n"
"\n"
"We have that the implication `False ‚Üí Q` is true regardless what `Q` represents and regardless whether `Q` is true or is false. \n"
"So `False` implies any proposition. This principle is known as: 'From `False` anything follows'.\n"
"\n"
"Use this implication to prove `Q` where `Q` is any proposition."
msgstr ""

#: Game.Levels.Logic.L12_False
msgid "Having proven `False`, instead of going through this to prove `Q` you can use the the `contradiction` tactic. If you were able to prove `False`, then the `contradiction` tactic will prove the goal regardless what the goal is because 'from `False`, anything follows'.\n"
"\n"
"Proving `False` is what's usually called deriving a contradiction, and note that to prove `False` you would first need to have a proof `P`, and a proof of `¬¨P` i.e `P ‚Üí False`."
msgstr ""

#: Game.Levels.Logic
msgid "Logic"
msgstr ""

#: Game.Levels.Logic
msgid "In this world, we will be dealing with `Objects` of type `Prop` i.e propositions. You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time). You have seen propositions before like `x=2`, `y=6` etc..\n"
"\n"
"When you have `h : P` where `P : Prop` , then we say `h` is a proof of the statement `P`(imagine `x=2` instead of `P` if you wish). \n"
"\n"
"In a proof state, this would look like the following:\n"
"```\n"
"Objects\n"
"P : Prop\n"
"Assumptions\n"
"h : P\n"
"```\n"
"\n"
"Moreover, we will discuss constructing new propositions from old ones.\n"
"\n"
"Here's an example in natural language, given the two propositions 'The sun is shining' , 'It is Monday', you can construct 'The sun is shining and it is monday'. \n"
"\n"
"Another example would be, having the following:\n"
"```\n"
"h : `x=2`\n"
"h' : `y=6`\n"
"```\n"
"where `P` is `x=2` and `Q` is `y=6`, we can construct a new proposition `P ‚àß Q` which is read as `x=2 and y=6`. Here we know what `P`,`Q` stand for. But, the proposition `P ‚àß Q` can still be constructed and reasoned about regardless. Think of reasoning about unknown numbers like `x`,`y` etc..."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "`disjoint` theorem"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "Before diving into an actual knights and knaves puzzle, lets explore basic results implied by the assumptions of this puzzle.\n"
"\n"
"We will first look at the assumption that no one can be a knight and a knave at the same time.\n"
"It is represented as:\n"
"```\n"
"h : left ‚à© right = ‚àÖ \n"
"```\n"
"\n"
"In our problem, we have:\n"
"```\n"
"Aleft: A ‚àà left\n"
"Aright: A ‚àà right\n"
"```\n"
"This means that `A` belongs to both `left` and `right` i.e `A ‚àà left ‚à© right`.\n"
"\n"
"So, we do have someone who is both a knight and a knave. This contradicts `h`.\n"
"\n"
"This would contradict `h` giving us `False` which is the goal.\n"
"\n"
"To show `A ‚àà left ‚à© right`, use the following\n"
"```\n"
"Finset.mem_inter : a ‚àà s‚ÇÅ ‚à© s‚ÇÇ ‚Üî a ‚àà s‚ÇÅ ‚àß a ‚àà s‚ÇÇ\n"
"```\n"
"Use `have` so it would be added to the assumptions.\n"
"\n"
"Heres an example:\n"
"`have twoEqualstwo : 2=2 := rfl` will add an object named `twoEqualstwo` of type `2=2` to the proof state which would look as follows:\n"
"```\n"
"Assumptions:\n"
"twoEqualstwo : 2=2\n"
"```\n"
"\n"
"You can choose any name after `have` and any type after `:`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "dis22"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "We know that `left ‚à© right = ‚àÖ`, so replace it with `‚àÖ` using `rw` getting `A ‚àà ‚àÖ`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "Remember that the empty is the set with no elements by definition. But we have found one, namely `A`. This directly contradicts the definition of `‚àÖ` so `contradiction` will work here."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "This works for any two disjoint sets, specifically the two sets `Knight`,`Knave`.\n"
"\n"
"Even if we didn't have `A_not_in_empty` in the assumptions, `contradiction` would have worked here because Lean knows the following theorem: \n"
"```\n"
"Finset.not_mem_empty.{u_1} {Œ± : Type u_1} (a : Œ±) : a ‚àâ ‚àÖ\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "`inleft_notinright`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "The lemma `inleft_notinright` in this level applies to any two sets that are disjoint. The two we are interested in of course are `Knight`,`Knave`.\n"
"\n"
"The reasoning goes as follows:\n"
"\n"
"Assume `A ‚àà right`. This is done using `intro` tactic."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "Look familiar? This is exactly like the previous level which gave us `disjoint` theorem."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "In the next level, you will use this theorem to prove that if `A` is a knight, then `A` is not a knave."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knight_NotKnave
msgid "A Knight is not a knave."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knight_NotKnave
msgid "If you are a knight, then you are definitely not a knave. Recall that knights always tell the truth and knaves always lie.\n"
"\n"
"This is implied by the assumption:\n"
"```\n"
"h : Knight ‚à© Knave = ‚àÖ \n"
"```\n"
"\n"
"Note that this level is identical to the previous one except the fact that the set `left` is now called `Knight` and the set `right` is now called `Knave`.\n"
"\n"
"This doesn't change anything of course, what changes are the names you and Lean would be seeing. If everything is renamed consistently, nothing changes.\n"
"\n"
"You can use the theorem proved in the previous level `inleft_notinright` giving it the necessary arguments."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knight_NotKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_inright
msgid "`inright_notinleft`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_inright
msgid "The lemma `inright_notinleft` in this level applies to any two sets that are disjoint. The two we are interested in of course are `Knight`,`Knave`.\n"
"\n"
"The reasoning goes as follows:\n"
"\n"
"Assume `A ‚àà left`. This is done using `intro` tactic."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_inright
msgid "Look familiar? This is exactly like the previous level which gave us `disjoint` theorem."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_inright
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_Knave_NotKnight
msgid "A Knave is not a knight."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_Knave_NotKnight
msgid "If you are a knave, then you are definitely not a knight. Recall that knights always tell the truth and knaves always lie.\n"
"\n"
"This is implied by the assumption:\n"
"```\n"
"h : Knight ‚à© Knave = ‚àÖ \n"
"```\n"
"\n"
"Note that this level is identical to the previous one except the fact that the set `left` is now called `Knight` and the set `right` is now called `Knave`.\n"
"\n"
"This doesn't change anything of course, what changes are the names you and Lean would be seeing. If everything is renamed consistently, nothing changes.\n"
"\n"
"You can use the theorem proved in the previous level `inright_notinleft` giving it the necessary arguments."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_Knave_NotKnight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notright
msgid "`notright_left`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notright
msgid "In this level, we have `P ‚à® Q` which means that `P` is true or `Q` is true. Since we also know `¬¨Q` i.e `Q` is not true, the only option leftis `P` being true.\n"
"\n"
"As a truth table:\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P  & P ‚à® False \\\\\n"
"\\hline\n"
"T  & T \\\\\n"
"F  & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that `P`, `P ‚à® False` always have the same truth value.\n"
"\n"
"This truth table is represented as the following theorem:\n"
"```\n"
"or_false_iff (p : Prop) : p ‚à® False ‚Üî p\n"
"```\n"
"\n"
"We will first start by transforming `P ‚à® Q` into `P ‚à® False` using `¬¨Q`.\n"
"\n"
"`¬¨Q` means that `Q` is False i.e `Q = False`.\n"
"We have the following theorem:\n"
"```\n"
"eq_false {p : Prop} (h : ¬¨p) : p = False\n"
"```\n"
"\n"
"Use `have` and `eq_false` to get `Q = False`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notright
msgid "Replace `Q` in `Or` with `False`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notright
msgid "`P` and `P ‚à® False` have the same truth value. We know `P ‚à® False` is true, therefore `P` is true."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notright
msgid "Instead of doing it manually, you can instead use `simp` tactic. \n"
"\n"
"The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or some assumption.\n"
"\n"
"`simp [notright] at Or` does the job. It simplifies `Or` using `notright` and various theorems called 'simp lemmas' some of which are `eq_false`, `or_false_iff`.\n"
"\n"
"`simp` will simplify `Or` with the theorems you gave, in this case `notright : ¬¨Q`. The resulting simplified expression would be `Or : P`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L07_NotKnave_Knight
msgid "If you're not a knave, then the only option left is a knight."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L07_NotKnave_Knight
msgid "You are either a knight or a knave (`h`). If you are not a knave (`h'`), then the only option left is being a knight.\n"
"\n"
"In other words,  \n"
"\n"
"In this level, we know:\n"
"```\n"
"A ‚àà Knight ‚à® A ‚àà Knave\n"
"A ‚àâ Knave\n"
"```\n"
"In our case, `P` is `A ‚àà Knight`. Since we know `A ‚àâ Knave` then we can say that `A ‚àà Knave = False`. Replacing this in the `‚à®` expression gives us `A ‚àà Knight ‚à® False`.\n"
"\n"
"In other words, we have that `A ‚àà Knight ‚à® False` is true. So we must have `A ‚àà Knight`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L07_NotKnave_Knight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L08_notleft
msgid "`notleft_right`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L08_notleft
msgid "Truth table:\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P  & False ‚à® P \\\\\n"
"\\hline\n"
"T  & T \\\\\n"
"F  & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that `P`, `False ‚à® P` always have the same truth value."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L08_notleft
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L09_NotKnight_Knave
msgid "If you're not a knight, then the only option left is a knave."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L09_NotKnight_Knave
msgid "You are either a knight or a knave. If you are not a knight, then the only option left is being a knave.\n"
"\n"
"false_or\n"
"\n"
"In this level, we know:\n"
"```\n"
"A ‚àà Knight ‚à® A ‚àà Knave\n"
"A ‚àâ Knight\n"
"```\n"
"In our case, `P` is `A ‚àà Knave`. Since we know `A ‚àâ Knight` then we can say that `A ‚àà Knight = False`. Replacing this in the `‚à®` expression gives us `False ‚à® A ‚àà Knave`.\n"
"\n"
"So we must have `A ‚àà Knave`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L09_NotKnight_Knave
msgid "Let's recap what we have proven.\n"
"\n"
"Given the following proof state:\n"
"```\n"
"(Knight : Finset K ) (Knave : Finset K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h'' : A ‚àà Knight ‚à® A ‚àà Knave)\n"
"```\n"
"\n"
"We can conclude the following implications:\n"
"A ‚àà Knight ‚Üí A ‚àâ Knave (using `h`) \n"
"A ‚àâ Knave ‚Üí A ‚àà Knight (using `h''`)\n"
"which can be combined into: A ‚àà Knight ‚Üî A ‚àâ Knave.\n"
"\n"
"Similarly for the other two levels, we can conclude A ‚àâ Knight ‚Üî A ‚àà Knave\n"
"\n"
"These two theorems will be very useful in the following world. They are now unlocked as the following:\n"
"```\n"
"\n"
"```\n"
"\n"
"------------------------\n"
"\n"
"We have proven:\n"
"```\n"
"(Knight : Finset K) (Knave : Finset K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h' : A ‚àà Knight)\n"
"  : A ‚àâ Knave \n"
"\n"
"(Knight : Finset K ) (Knave : Finset K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h' : ¬¨ (B ‚àà Knave))\n"
"(h'' : B ‚àà Knight ‚à® B ‚àà Knave)\n"
"  :  B ‚àà Knight := by\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas
msgid "Knights and Knaves, lemmas"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas
msgid "We will introduce the knights and knaves puzzle here. In this world, you will have to prove basic but important theorems which will be used in the world after this one to solve actual knights and knaves puzzles.\n"
"\n"
"The setting is an island  in which certain inhabitants called 'knights' always tell the truth, and others called 'knaves' always lie.\n"
"\n"
"Every inhabitant is either a knight or a knave, there is no third option. Formally:\n"
"```\n"
"A ‚àà Knight ‚à® A ‚àà Knave.\n"
"```\n"
"\n"
"Let `Knight` be the set of inhabitants that are knights, i.e always tell the truth.\n"
"Let `Knave` be the set of inhabitants that are knaves, i.e always lies.\n"
"In a proof state, this would look like:\n"
"```\n"
"Objects\n"
"Knight Knave : Finset Inhabitant\n"
"```\n"
"`Knight` is a finite set where its elements are of type `Inhabitant` and these elements satisfy the propery of always telling the truth.\n"
"`Knave` is a finite set where its elements are of type `Inhabitant` and these elements satisfy the property of always lying.\n"
"\n"
"Since knights always tell the truth and knaves always lie, no inhabitant can be both a knight and a knave. So the intersection of the two sets is empty i.e `Knight ‚à© Knave = ‚àÖ`. We say the two sets `Knight`, `Knave` are disjoint.\n"
"\n"
"The statement `A ‚àà Knight` is read as: `A` belongs to the finite set `Knight`(`A in Knight`), and it should be understood as 'A IS Knight' i.e 'A' always tells the truth.\n"
"Similarly, the statement `A ‚àâ Knight` is read as: `A` doesn't belong to the finite set `Knight`(`A not in Knight`), and it should be understood as 'A ISNOT Knight'.\n"
"The same reasoning applies to `x ‚àà Knave`, `x ‚àâ Knave`.\n"
"\n"
"The objective is to conclude who is a knight and who is a knave, based on the statements of several inhabitants. This will be done using logical reasoning. Every inhabitant will make at most one statement.\n"
"\n"
"get a taste:\n"
"Logic Puzzles: Knights and Knaves - YouTube\n"
"https://www.youtube.com/watch?v=jY6dvQUHIOs"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "Let's solve the previously mentioned 'I am a knave' puzzle.\n"
"\n"
"Suppose we have an inhabitant A which says: \n"
"A : 'I am a knave.'\n"
"\n"
"Merely uttering this statement is a contradiction. This is equivalent to the liars paradox(https://en.wikipedia.org/wiki/Liar_paradox). A saying 'I am a knave' is like A saying 'I am a liar' or 'I am lying'. \n"
"\n"
"If `A` were telling the truth(i.e a knight), then `A` would be lying which is a contradiction. \n"
"\n"
"Similarly if `A` were lying(i.e a knave) then A would be telling the truth. \n"
"\n"
"Regardless of what A is, we fall into contradiction. The proof will take all cases for A, which are either the fact of always telling the truth(Knight) or always lying(Knave) and will show this contradiction.\n"
"\n"
"Remember that `A` is either a knight or a knave, represented by `h1` , and our reasoning was taking every case and showing that we reach the same conclusion in both(which is a contradiction i.e `False`). This is known as a proof by cases.\n"
"\n"
"For this, we need the `cases` tactic. Try `cases h1` and see what happens."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "Notice that `h1` is now replaced by `h_1`, and we have two goals to prove instead of one. \n"
"The difference between each is that in the first, A is a knight(`h_1 : A ‚àà Knight`) and in the second A is a knave(`h_1 : A ‚àà Knave`).  \n"
"\n"
"Combine the statement of `A` and the fact `A` is a knight to conclude the truth of `A`'s statement."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "So now we have that A is a knave, in addition to what we already knew (A being a knight). \n"
"\n"
"But this contradicts the fact that these two sets are disjoint."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "Three of the inhabitants `A`, `B`, and `C` were standing together in a garden. \n"
"\n"
"A stranger passed by and asked A, 'Are you a knight or a knave?' A answered, but rather indistinctly, so the stranger could not make out what he said. \n"
"\n"
"The stranger then asked B, 'What did A say?' B replied, 'A said that he is a knave.' At this point the third man, C, said, 'Don't believe B; he is lying!' \n"
"\n"
"The question is, what are B and C?\n"
"\n"
"First of all, lets simplify the statements. C's statement can be simplified to 'B is a knave.'\n"
"\n"
"The statements are:\n"
"```\n"
"B says that A said 'I am a knave'\n"
"C says that B is a knave\n"
"```\n"
"\n"
"The formalization is given in the proof state.\n"
"\n"
"Note that for the statement of `B`, if `B` where telling the truth then `A` indeed made such a statement which is the statement 'I am a Knave' and the formalization of that is `A ‚àà Knight ‚Üî A ‚àà Knave`. Use IamKnave."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "We know that `A` saying 'I am a knave' leads to contradiction.\n"
"\n"
"In implication form, `IamKnave` is of the following form:\n"
"```\n"
"(Knight ‚à© Knave = ‚àÖ) ‚Üí \n"
"(A ‚àà Knight ‚à® A ‚àà Knave) ‚Üí \n"
"(A ‚àà Knight ‚Üî A ‚àà Knave) ‚Üí False\n"
"```\n"
"\n"
"So, `IamKnave h h1` is of the following type:\n"
"```\n"
"(A ‚àà Knight ‚Üî A ‚àà Knave) ‚Üí False\n"
"```\n"
"which is \n"
"```\n"
"¬¨(A ‚àà Knight ‚Üî A ‚àà Knave)\n"
"```\n"
"\n"
"Store this in an object using `have`, you don't have to specify the type."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "Now that we know `¬¨ (A ‚àà Knight ‚Üî A ‚àà Knave )` , we can conclude `B ‚àà Knave` using `stBn`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "Now that we know `B ‚àà Knave`, we can conclude `C ‚àà Knight` using `stC`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "Now that we know `B ‚àà Knave`, `C ‚àà Knight`, we can conclude `B ‚àà Knave ‚àß C ‚àà Knight` using both."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "A says 'I am a knave or B is a knave'.\n"
"\n"
"Formally,\n"
"```\n"
"A ‚àà Knave ‚Üî ¬¨ (A ‚àà Knave ‚à® B ‚àà Knave)\n"
"```\n"
"\n"
"If `A ‚àà Knave` then we get `A ‚àâ Knave` which is a contradiction.\n"
"\n"
"So, we can conclude that `A ‚àâ Knave`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "Now that we know that `A` is not a knave, then `A` is a knight."
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "From this, we can conclude that `A ‚àà Knave ‚à® B ‚àà Knave`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "Since `A ‚àâ Knave`, we can conclude `B ‚àà Knave`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "Suppose `A` says 'I am a knave, but B is not'.\n"
"\n"
"If we assume `A ‚àà Knight`, then we get `A ‚àà Knave` which is a contradiction.\n"
"\n"
"So `A ‚àâ Knight`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "So, `A ‚àà Knave`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "Since `A ‚àà Knave`, `A ‚àâ Knave ‚à® B ‚àà Knave`"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "Since `A ‚àâ Knave ‚à® B ‚àà Knave` and `A ‚àà Knave` then `B ‚àà Knave`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves
msgid "Knights And Knaves"
msgstr ""

#: Game.Levels.KnightsAndKnaves
msgid "Suppose the island has an inhabitant `A` which says the following statement,\n"
"```\n"
"A says 'I am a knave'\n"
"```\n"
"\n"
"Formally, the statement 'I am a knave' is `A ‚àà Knave`.\n"
"\n"
"Remember that if `A` were a knight, then `A`'s statement is true. This can be translated to an implication: `A ‚àà Knight ‚Üí A ‚àà Knave`\n"
"\n"
"If `A`'s statement were true, then `A` is telling the truth so `A` must be a knight. `A ‚àà Knave ‚Üí A ‚àà Knight`\n"
"\n"
"The two can be combined as `A ‚àà Knight ‚Üî A ‚àà Knave`\n"
"\n"
"`P ‚Üî Q`  is defined as `(P ‚Üí Q) ‚àß (Q ‚Üí P)`. But what does it mean? Let's construct its truth table and find out.(make it as the level itself??)\n"
"\n"
"Remember,\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & T \\\\\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"Q & P & Q ‚Üí P \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & T \\\\\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"\n"
"The result is\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q & Q ‚Üí P & P ‚Üí Q ‚àß Q ‚Üí P\\\\\n"
"\\hline\n"
"T & T & T & T & T \\\\\n"
"T & F & F & T & F \\\\\n"
"F & T & T & F & F \\\\\n"
"F & F & T & T & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"So, `P ‚Üî Q` is true when `P,Q` are true or `P,Q` are false, i.e when `P` and `Q` have the same truth value. Therefore, `P` and `Q` are equivalent from a truth value perspective regardless what the statement of `P` and of `Q` is.\n"
"\n"
"To extract for example the forward direction `P ‚Üí Q` from `h :P ‚Üî Q`, you do `h.mp`. This is a modus ponens version for `‚Üî`. The reversed version `h.mpr` gives `Q ‚Üí P`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "A: B is a knight and C is a knight.\n"
"\n"
"B: C is a knight and A is a knave.\n"
"\n"
"Formally,\n"
"```\n"
"stA : A ‚Üî B ‚àà Knight ‚àß C ‚àà Knight\n"
"stB : B ‚Üî C ‚àà Knight ‚àß A ‚àà Knave\n"
"```\n"
"\n"
"\n"
"\n"
"Using `¬¨C`, we get `¬¨C ‚à® A` which gives `¬¨B` using `stBn`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Assuming `A` is true:\n"
"- Prove `BC : B ‚àß C` from `stA` using `A`\n"
"- Prove `CnA : C ‚àß ¬¨A` from `stB` using `B`\n"
"- Prove `cont :False` from `A`,`¬¨A` which is the goal."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Assuming `C` is true:\n"
"- `B` from `stB` using `C ‚àß ¬¨A`\n"
"- `A` from `stA` using `B ‚àß C`\n"
"- `False` from `A`,`¬¨A`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid "A: C is a knight or B is a knight.\n"
"\n"
"B: A is a knight, if and only if C is a knight.\n"
"\n"
"Everytime you need to assume, and for every bullet point, you would need to use the `have` tactic.\n"
"\n"
"Assuming `¬¨A`,\n"
"- Prove `¬¨C ‚àß ¬¨B` from `stAn`\n"
"- Prove `¬¨(A ‚Üî C)` from `stBn`\n"
"- Prove `A ‚Üî C` from `¬¨A, ¬¨C`\n"
"- Prove `False` from `¬¨(A ‚Üî C) , (A ‚Üî C)`\n"
"\n"
"We have proven `¬¨A ‚Üí False` which is `¬¨¬¨A` i.e `A`.\n"
"\n"
"Notice that `¬¨A` means `¬¨C, ¬¨B` where ¬¨B gives that A and C dont have the same type. This is a contradiction of course so the proposition ¬¨A is not true which means that A is true.  \n"
"\n"
"Now we know A, which gives C ‚à® B\n"
"¬¨B means C, and it also means ¬¨(A ‚Üî C). But we know A ‚Üî C from A,C so we get a contradiction.\n"
"\n"
"lets take cases for C ‚à® B. Having C gives us (A ‚Üî C) which gives us B. So we get as a final answer, A ‚àß B ‚àß C. \n"
"Having B, we get that (A ‚Üî C) which gives us C. The final answer is A ‚àß B ‚àß C.\n"
"\n"
"Now we know A,B. From B we get that A ‚Üî C, which means C.\n"
"\n"
"Now we know A,B,C."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "similar explanation to lvl 2"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "A: B is a knight or C is a knight.\n"
"B: C is a knave, if and only if A is a knave"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "Knights and Knaves, Second Approach"
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "In this world, we also deal with the knights and knaves puzzle with the difference being the representation of the problems in Lean and therefore the solution to the puzzles as well.\n"
"\n"
"The setup is as follows:\n"
"We exploit the binary nature of an inhabitant. There are two options and no third, either a knight or a knave. So, we declare an object of type `Prop` for every inhabitant. \n"
"\n"
"Say we had three inhabitants `A,B,C` , we would declare the following propositions:\n"
"```\n"
"variable {A B C : Prop}\n"
"```\n"
"Now, we intrepret having a proof of `A` as `A` being a knight, and having a proof of `¬¨A` as `A` being a knave.\n"
"\n"
"We have the following correspondence:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"\\text{Old way} & \\text{New way} \\\\\n"
"\\hline\n"
"h : A ‚àà Knight & h : A \\\\\n"
"\\hline\n"
"h : A ‚àâ Knight & h : ¬¨A \\\\\n"
"\\hline\n"
"h : A ‚àà Knave  & h : ¬¨A \\\\\n"
"\\hline\n"
"h : A ‚àâ Knave  & h : ¬¨¬¨A \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"The translation of statements made by each inhabitant into a propositional formula remains the same, using `‚Üî` but of course instead of `A ‚àà Knight` we just have `A` and instead of `A ‚àà Knave` we just have `¬¨A`.\n"
"\n"
"Notice that there are no explicit assumptions in this representation, but that doesn't mean that this representation is less faithful.\n"
"\n"
"We know that any proposition is either true or false, in our context this would translate to every inhabitant is either a knight or a knave. \n"
"```\n"
"A ‚àà Knight ‚à® A ‚àà Knave \n"
"```\n"
"translates to\n"
"```\n"
"A ‚à® ¬¨A\n"
"```\n"
"\n"
"Moreoever, we know that `A ‚àß ¬¨A` is false, which would translate to the fact that no inhabitant can be both a knight or a knave.\n"
"```\n"
"A ‚àà Knight ‚àß A ‚àà Knave\n"
"```\n"
"which within the previous representation of finite sets would mean that the set knight and the set knave are disjoint.\n"
"```\n"
"Knight ‚à© Knave = ‚àÖ\n"
"```\n"
"\n"
"Correspondence:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"\\text{Old way} & \\text{New way} \\\\\n"
"\\hline\n"
"h : A ‚àà Knight ‚à® A ‚àà Knave & h : A ‚à® ¬¨A \\\\\n"
"\\hline\n"
"h : Knight ‚à© Knave = ‚àÖ & h: A ‚àß ¬¨A  \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"All puzzles were generated(and possibly modified) from https://www.wolframcloud.com/objects/demonstrations/KnightsAndKnavesPuzzleGenerator-source.nb."
msgstr ""

#: Game
msgid "Reasoning"
msgstr ""

#: Game
msgid "This is a gamification of mathematical proofs. Every level has a `Goal`, which is what you are trying to prove. Closing the `Goal` means you have proved the theorem and there is nothing else to do.\n"
"\n"
"You will use the `Lean` theorem prover, and its mathematical library `mathlib`.\n"
"\n"
"# Right Side Pane\n"
"Let's explain what's going on in the right side pane.\n"
"\n"
"This is where you can find the tactics, definitions, and theorems at your disposal which were introduced in previous levels.\n"
"\n"
"Clicking on one will display an overview and some examples. This will be available to you at all times when working on the levels. Refer back to it whenever you need to.\n"
"\n"
"Any new tactic, theorem, or definition introduced in a level will be highlighted in a yellow color.\n"
"\n"
"We now discuss each section in the right side pane.\n"
"## Tactics\n"
"In this puzzle game, you will use tactics to manipulate the `Goal` and close it, essentially proving the `Goal`. Tactics will be incrementally introduced, and tactics that haven't been introduced yet will have a lock icon which means you can't use them yet. \n"
"\n"
"## Definitions\n"
"The point of this game is not just to showcase ***Lean***, but also to learn some mathematics. Relevant definitions will be displayed here.\n"
"\n"
"## Theorems\n"
"Here is listed theorems to use throughout the levels. Some you would have proved in previous levels and others are presented for you to use but without having proved them. An intuitive definition of why the theorem makes sense will be presented as well when it is introduced.\n"
"\n"
"# Level Structure\n"
"Within every level, you have the `Objects`(if any), `Assumptions`(if any), and `Goal` for the current level. This is called the initial proof state. \n"
"\n"
"There will also be a text input to execute tactics accordingly.\n"
"\n"
"***Lean*** tracks the proof state as you execute tactics and makes sure you made no mistakes.\n"
"You will execute tactics one by one until Lean tells you that you have closed the goal.\n"
"\n"
"# More info\n"
"You can click the hamburger menu in the top right then 'Game Info' for more information."
msgstr ""

#: Game
msgid "For example: Game version, Credits, Link to Github and Zulip, etc.\n"
"\n"
"Many technical details have been skipped for the sake of not getting bogged down with Lean and its mathematical library mathlib, but focus on the aspects of reasoning and proof. You can visit https://leanprover-community.github.io/mathlib4_docs/ for more information about any tactic used by searching `Mathlib.Tactic.tacticname`, and theorems.\n"
"\n"
"Zulip chat for lean has been a very useful resource to resolve issues when formalizing the exercises, you can visit it and ask questions in the '#new members' stream. You can also view messages without signing up. There are other streams dedicated to various topics you can check out as well. \n"
"\n"
"# Editor Mode \n"
"## copy and paste your solutions somewhere else\n"
"Some levels will force you to use editor mode. Editor mode is necessary for multiline tactics. Moreover, you should get used to it because it mimics a vscode Lean environment which is the most common way Lean is run.\n"
"\n"
"To access editor mode, click on the icon to the left of the hamburger menu in the top right.\n"
"You can copy and paste your solutions if you have Lean setup, or you can use the lean web editor: https://live.lean-lang.org/ if you want to experiment with your solutions outside the lean game.\n"
"Make sure to have `import Mathlib.Tactic` at the top and then to copy whats above the editor area which is the problem statement. Each problem statement is of the form `example ... :=  by` and after that is where your solution should go.\n"
"\n"
"## vscode like environment\n"
"Hovering over things will give you useful information.\n"
"# Links \n"
"https://leanprover-community.github.io/\n"
"https://lean-lang.org/\n"
"https://lean-lang.org/documentation/\n"
"\n"
"https://github.com/leanprover-community/mathlib4\n"
"\n"
"https://leanprover.zulipchat.com/\n"
"https://zulip.com/case-studies/lean/\n"
"\n"
"# how to navigate documentation\n"
"You can use https://leanprover-community.github.io/mathlib4_docs/ for Lean and mathlib related documentation. You can see 'Lean', 'Mathlib' in the left side pane, clicking on either will expand them. A more effective way of finding what you want is using the search feature of this page , using 'Go To Definition' if you have vscode setup for Lean and mathlib, or hovering over things to get more information\n"
"\n"
"-- consider removing # Rules\n"
"# Rules\n"
"You can relax the rules.\n"
"\n"
"This is not recommended for people who have never heard about Lean before. Moreover, relaxing the rules would ruin the coherence and structured/guided experience you would have when playing the game normally. If that is what you are looking for, then don't relax the rules."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
