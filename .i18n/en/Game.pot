msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Sun Jun  2 18:14:51 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.BasicAlgebra.L01_Intro
msgid "A Number Equals Itself"
msgstr ""

#: Game.Levels.BasicAlgebra.L01_Intro
msgid "In this exercise, we will prove `2 = 2`\n"
"\n"
"`rfl` will do the job.\n"
"\n"
"`rfl` is short for reflexivity, which is the property that for any number `a`, `a = a`"
msgstr ""

#: Game.Levels.BasicAlgebra.L01_Intro
msgid "`rfl` is short for reflexivity, which is the property that for any number `a`, `a = a`.\n"
"\n"
"The `rfl` tactic will close all goals of the form `X=X`, regardless of what `X` is.\n"
"\n"
"## examples\n"
"```\n"
"x - 7 = x - 7\n"
"```\n"
"`rfl` will close this goal."
msgstr ""

#: Game.Levels.BasicAlgebra.L02_Introduction
msgid "Introd"
msgstr ""

#: Game.Levels.BasicAlgebra.L02_Introduction
msgid "In this level, we have `Objects`, `Assumptions`, and the `Goal`.\n"
"\n"
"For this world, objects will always be variables we are working with. `x : ‚Ñï` means that `x` is a variable of type natural number(positive numbers). \n"
"\n"
"As for the assumptions, we have `h` which is a proof of `x = 2`. \n"
"\n"
"Our goal is to prove that `x = 2`. To do this, we should let Lean know that we have a term that 'exactly' matches that goal. Notice that we do, that term is `h`!\n"
"\n"
"Using `exact h` will do."
msgstr ""

#: Game.Levels.BasicAlgebra.L02_Introduction
msgid ""
msgstr ""

#: Game.Levels.BasicAlgebra.L02_Introduction
msgid "## Overview\n"
"Having h : P and P as your goal, exact h will close the goal. exact h asserts that h is exactly whats needed to prove the goal which makes sense because h is a proof of P.(It doesn't matter what P is)"
msgstr ""

#: Game.Levels.BasicAlgebra.L02_Introduction
msgid ""
msgstr ""

#: Game.Levels.BasicAlgebra.L03_lvl2
msgid "Substituting Variables By Their Values"
msgstr ""

#: Game.Levels.BasicAlgebra.L03_lvl2
msgid "We will learn how to substitute a variable with its value, for example how to substitiute `x` by `2` if we know that `x=2`.\n"
"\n"
"This can be done using the tactic `rw` (short for rewrite).\n"
"\n"
"`rw` takes a term of type `A=B` and replaces all the `A`s in the goal with `B`s"
msgstr ""

#: Game.Levels.BasicAlgebra.L03_lvl2
msgid "Do `rw [¬´{h}¬ª]` or `rw [¬´{g}¬ª]` and observe what happens."
msgstr ""

#: Game.Levels.BasicAlgebra.L03_lvl2
msgid "You should use `¬´{h}¬ª` now."
msgstr ""

#: Game.Levels.BasicAlgebra.L03_lvl2
msgid "You should use `¬´{g}¬ª` now."
msgstr ""

#: Game.Levels.BasicAlgebra.L03_lvl2
msgid "Our goal is now `3 + 3 = 6` which Lean knows to be true because it's a direct consequence of the definition of the natural numbers. \n"
"\n"
"Notice we didn't use the fact `i` which is that `z=10`. You should ignore any assumptions you think are irrelevant to proving the goal."
msgstr ""

#: Game.Levels.BasicAlgebra.L04_Normalize
msgid "Normalize Equations"
msgstr ""

#: Game.Levels.BasicAlgebra.L04_Normalize
msgid "In this level, we will learn about normalizing equations using the `norm_num` tactic.\n"
"\n"
"`norm_num` is short for normalize numerical expressions like carrying out calculations and simplifying the expression.\n"
"\n"
"We will also learn how to apply a tactic to an assumption instead of the goal.\n"
"\n"
"We want to use `norm_num` on `h`, so simply write `norm_num at h`."
msgstr ""

#: Game.Levels.BasicAlgebra.L04_Normalize
msgid "Now `h` looks exactly like the goal. Let Lean know!!"
msgstr ""

#: Game.Levels.BasicAlgebra.L04_Normalize
msgid "Remember the `exact` tactic, try `exact h`."
msgstr ""

#: Game.Levels.BasicAlgebra.L04_Normalize
msgid ""
msgstr ""

#: Game.Levels.BasicAlgebra.L04_Normalize
msgid "Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `‚Åª¬π` `^` and `%`\n"
"over numerical types such as `‚Ñï`, `‚Ñ§`, `‚Ñö`, `‚Ñù`, `‚ÑÇ`."
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid "some title"
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid "Here, we introduce a multiplication cancellation tactic.\n"
"\n"
"To be able to achieve this, we need to rewrite `16` in `h` as `4 * 4` to be able to cancel the `4` on both sides of the equation , proving `y=4`. \n"
"\n"
"But first, we need to construct an object of type `16 = 4 * 4` (a proof) and add it to our assumptions.\n"
"\n"
"This is exactly what `have` does\n"
"\n"
"The syntax is \n"
"`have name-of-object : type := by ...` where `...` is the proof.\n"
"\n"
"The type here is `16 = 4 * 4`, you can pick anything as `name-of-object` like `helper`. For the proof, we need to carry out the calculation of `4 * 4` and as in the previous level, the tactic for that is `norm_num`. Typing that as the proof will work.\n"
"\n"
"Alternative syntax:\n"
"`have name := ........`"
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid "Try `have helper : 16=4*4 := by norm_num`"
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid "Now we want to replace the `16` in `¬´{helper}¬ª` with `4 * 4`"
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid "`rw [¬´{helper}¬ª] at h`"
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid "Now that we have `4` on both sides, we want to cancel this `4`\n"
"\n"
"This is possible using the theorem `Nat.mul_left_cancel` which has the following type :\n"
"```\n"
"mul_left_cancel(a‚úù : a * b = a * c) :\n"
"b = c\n"
"\n"
"```\n"
"`mul_left_cancel` takes one argument which is the equation you are working with, then cancels `a` from both sides giving a proof of `b=c`. This is exactly what we want to prove the goal."
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid "Notice that `mul_left_cancel h` has type `y = 4`. So, `exact mul_left_cancel h` will do it."
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid ""
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid ""
msgstr ""

#: Game.Levels.BasicAlgebra.L05_Lvl3
msgid "some info"
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid "Final"
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid "A similar problem to the previous one."
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid "First start by substitute the value of `y` in `h`"
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid "Now simplify `h`"
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid "We need to isolate `3*x` on the left side of the equation. You can do this using the `eq_add_of_add_neg_eq` theorem which is of type:\n"
"```\n"
"eq_add_of_add_neg_eq (h : a + -c = b) : a = b + c\n"
"```\n"
"We can use this theorem with the `have` tactic to construct a term of type `3 * x = 12 + 6`"
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid "Simplify `¬´{helper}¬ª`"
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid "Now, like the previous exercise, you need to construct a term of type `(18:‚Ñ§)=3*6`"
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid "Replace the `18` with 3*6"
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid "Cancel `3` from both sides and your done\n"
"\n"
"This time, use `mul_left_cancel`"
msgstr ""

#: Game.Levels.BasicAlgebra.L06_Final
msgid ""
msgstr ""

#: Game.Levels.BasicAlgebra
msgid "Basic Algebra"
msgstr ""

#: Game.Levels.BasicAlgebra
msgid "In this world, you will learn how to solve equations."
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Notice that the objects of interest are now of type `Prop` (i.e proposition). A proposition is a statement/assertion that can take only one of two values, either true or false. Having `hP:P` means that we have a proof of `P`, and therefore you can think about this as `P` being true.\n"
"\n"
"`hP` 'exactly' matches the goal. `hP` is 'exactly' what you need to close the goal. This is to emphasize that for the tactic `exact h`, the type of h doesn't matter."
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Type `exact hP`!"
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Notice that `hQ` and `hR` were not used. We couldn't use them in any case because `Q` and `R` are not related to `P`. In the next levels, we will discuss how to construct new propositions from old ones which would in a sense depend on the old ones."
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "And"
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "In this level, we will learn about the `‚àß` logical connective, known as 'And'.\n"
"In logic, for `P,Q` propositions, `P and Q` is true when both `P` is true and `Q` is true.\n"
"\n"
"\n"
"# Two ways of dealing with ‚àß in the goal(Try both!)\n"
"In Lean, to prove `P ‚àß Q`, you need a proof of `P` and a proof of `Q`.\n"
"\n"
"## first way\n"
"Giving these two proofs to the And introduction rule will construct a proof of `P ‚àß Q`.\n"
"\n"
"Here's the type of `And.intro`:\n"
"```\n"
"  And.intro  (left : P) (right : Q) : P ‚àß Q\n"
"```\n"
"where `P Q : Prop`\n"
"\n"
"## second way\n"
"Using the `constructor` tactic will split a goal of the form `P ‚àß Q` into two subgoals `P`,`Q` where you can deal with eac one separetly"
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "Try `exact And.intro hP hQ` or `constructor`"
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "Notice that the goal is now `P`"
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "After closing the goal `P`, you now have to close the goal `Q`"
msgstr ""

#: Game.Levels.Logic.L02_And
msgid ""
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "Or"
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "In this level, you will learn about the `Or` logical connective.\n"
"\n"
"# truth table\n"
"```\n"
"| P | Q | P ‚à® Q  |\n"
"|---|---|--------|\n"
"| T | T |   T    |\n"
"| T | F |   T    |\n"
"| F | T |   T    |\n"
"| F | F |   F    |\n"
"```\n"
"\n"
"From the truth table, we can see that if one of `P`,`Q` is true then `P ‚à® Q` is true. \n"
"Therefore, if we have `P ‚à® Q` as our goal, it is enough to prove `P` or to prove `Q`.\n"
"This is exactly what the `left` and `right` tactic does. \n"
"The `left` tactic transforms our goal from `P ‚à® Q` to `P` and similarily for the `right` tactic. This is because Lean understands that if `P` is true, then `P ‚à® Q` is true."
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "Use either `left` or `right`"
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "`p` is exactly the goal"
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "`q` is exactly the goal"
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid ""
msgstr ""

#: Game.Levels.Logic
msgid "Logic"
msgstr ""

#: Game.Levels.Logic
msgid "In this world, we will be dealing with `Objects` of type `Prop` i.e propositions. You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time).\n"
"\n"
"Moreover, these statements are denoted by a symbol like `p`,`q`,`r`.\n"
"\n"
"# examples of propositions\n"
"'The Lean theorem prover had a 4.70 release' is a true statement.\n"
"'World War 2 ended in 1950' is a false statement. It ended in 1945.\n"
"\n"
"# Building New Propositions From Previous Ones\n"
"In this world, you will also learn how to construct new propositions by connecting other propositions with logical connectives\n"
"\n"
"## Logical Connectives\n"
"\n"
"### `And` , `‚àß`\n"
"Let `p` denote the proposition 'The official language of France is french'(which is true).\n"
"Let `q` denote the prposition 'The official language of Germany is german'(which is true as well).\n"
"Combining these two prpositions together gives us the proposition `p ‚àß q` which translate to English: 'The official language of Franch is french `And` the official language of Germany is german'. Because the two propositions connected by the `And` are true, then the entire statement is true as well. It's not hard to see that `p` or `q` being false would make `p ‚àß q` false\n"
"\n"
"# truth table\n"
"```\n"
"| P | Q | P ‚àß Q  |\n"
"|---|---|--------|\n"
"| T | T |   T    |\n"
"| T | F |   F    |\n"
"| F | T |   F    |\n"
"| F | F |   F    |\n"
"```\n"
"\n"
"Image \"images/Logic/Truth-Table-And.png\""
msgstr ""

#: Game.Levels.SetTheoryLemmas.L01_Introduction
msgid "Intro"
msgstr ""

#: Game.Levels.SetTheoryLemmas.L01_Introduction
msgid "Hi"
msgstr ""

#: Game.Levels.SetTheoryLemmas.L01_Introduction
msgid "."
msgstr ""

#: Game.Levels.SetTheoryLemmas
msgid "Set Theory Lemmas"
msgstr ""

#: Game.Levels.SetTheoryLemmas
msgid "This introduction is shown before one enters level 1 of the demo world. Use markdown."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_Introduction
msgid "Intro"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_Introduction
msgid "# Xor"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_Introduction
msgid "This last message appears if the level is solved."
msgstr ""

#: Game.Levels.KnightsAndKnaves
msgid "Knights And Knaves"
msgstr ""

#: Game
msgid "Hello World Game111!!"
msgstr ""

#: Game
msgid "This is a gamification of mathematical proofs. Every level has a `Goal`, which is what you are trying to prove. Closing the `Goal` means you have proved theorem and there is nothing else to do.\n"
"\n"
"You will use the Lean theorem prover, and its mathematical library mathlib.\n"
"\n"
"# Right Side Pane\n"
"Let's explain what's going on in the right side pane.\n"
"\n"
"Anything you click on will display an overview and some examples. Refer back to it whenever you need to.\n"
"\n"
"## Tactics\n"
"In this puzzle game, you will use tactics to manipulate the `Goal` and close it, essentially proving the `Goal`. Tactics will be incrementally introduced, and tactics that haven't been introduced yet will have a lock icon which means you can't use them yet. \n"
"## Definitions\n"
"The point of this game is not just to showcase lean, but also to learn some mathematics. Relevant definitions will be displayed here\n"
"\n"
"## Theorems\n"
"Here is listed theorems to use throughout the levels. Some you would have proved in previous levels and others are presented for you to use but without proof.\n"
"\n"
"# Level Structure\n"
"Within every level, the `Objects`, `Assumptions`, and `Goal` for the current level will be display with a text input to execute tactics accordingly. Click on the main node in the `Basic Algebra` world to see what that looks like!"
msgstr ""

#: Game
msgid "Here you can put additional information about the game. It is accessible\n"
"from the starting through the drop-down menu.\n"
"\n"
"For example: Game version, Credits, Link to Github and Zulip, etc.\n"
"\n"
"Many technical details have been skipped for the sake of not getting bogged down with Lean, but focus on the aspects of reasoning and proof. You can visit https://leanprover-community.github.io/mathlib4_docs/ for more information about any tactic used by searching `Mathlib.Tactic.tacticname`, and theorems.\n"
"\n"
"Zulip chat for lean has been a very useful to resolve issues when formalizing the exercises, you can visit it and ask questions in the '#new members' stream. You can also view messages without signing up"
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
