msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Wed Jan 29 21:49:06 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Doc.doc
msgid "## Implication defintion\n"
"`¬¨P` is equivalent to `P ‚Üí False`\n"
"\n"
"Given\n"
"```\n"
"hnP : ¬¨P\n"
"```\n"
"unfold Not at hnP will result in:\n"
"```\n"
"hnP : P ‚Üí False\n"
"```\n"
"\n"
"## truth table\n"
"$\n"
"\\begin{array}{|c c|} \n"
"\\hline\n"
"P & ¬¨P \\\\\n"
"\\hline\n"
"T & F \\\\\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that this definition is an implication and that the truth table with `¬¨P` and the truth table with `P ‚Üí False` are identical.\n"
"\n"
"What this means is that to prove `¬¨P`, we assume `P` and derive a contradiction i.e constructing an object of type `False`. \n"
"In other words, having `¬¨P` as a goal, you have to start the proof with `intro` because you are proving an implication."
msgstr ""

#: Game.Doc.doc
msgid "Proving `False` means deriving a contradiction.\n"
"\n"
"A contradiction is when `P` and `¬¨P` are both true. We say that `P` and `¬¨P` contradict each other.\n"
"\n"
"# Principle of explosion, from `False` anything follows.\n"
"This principle asserts that if you have contradictory assumptions then you can prove anything.\n"
"```\n"
"hP: P\n"
"hnP: ¬¨P\n"
"```\n"
"Since `hnP : ¬¨P` is `P ‚Üí False` , we can obtain `hnP hP : False`.\n"
"\n"
"Moreover, we know that `hFQ : False ‚Üí Q` for any `Q : Prop` and so `hFQ (hnP hP) : Q`. (using `contradiction` after having proven `False` will close any goal as well)"
msgstr ""

#: Game.Doc.doc
msgid "You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time).\n"
"\n"
"Moreover, these statements are denoted by a symbol like `P`,`Q`,`R`.\n"
"\n"
"For an object of type `P` where `P` is of type Prop, i.e `h : P` where `P : Prop`, `h` would be a proof or a witness that `P` is true.\n"
"\n"
"# Constructing new propositions from old ones\n"
"The atomic propositions in the compound proposition `p ‚àß q` are : `p`, `q`. Of course, `p ‚àß q` can be used to construct more complicated propositions.\n"
"\n"
"## Connecting Propositions With A Logical Connective\n"
"This truth value depends on the truth value of the propositions it was built out of and the rules of the logical connective. This is clearly illustrated in a truth table. \n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects."
msgstr ""

#: Game.Doc.doc
msgid "Logical implication `P ‚Üí Q` is made up of two components:\n"
"- The premise, which in this case is `P`\n"
"- The conclusion, which in this case is `Q`\n"
"\n"
"P ‚Üí Q is read as 'If P is true, then Q is true.\n"
"\n"
"# truth table\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\\\\\n"
"\\hline\n"
"F & T & T \\\\\\\\\n"
"\\hline\n"
"F & F & T \\\\\\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"A statement `P ‚Üí Q` is false when `P` is true and `Q` false, it's true otherwise.\n"
"\n"
"# Implication as a function\n"
"What logical implication does is that it takes evidence or proof for `P` and transforms it returning a proof of `Q`.\n"
"The truth of `P` IMPLIES the truth of `Q`. A proof of `P` IMPLIES a proof of `Q`.\n"
"\n"
"In other words, it acts like a function. If you give `P ‚Üí Q` a proof of `P`, you get a proof of `Q`."
msgstr ""

#: Game.Doc.doc
msgid "Truth table:\n"
"\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"# Truth table\n"
"The truth table of a logical connective illustrates the rule for that logical connective , i.e the truth value of the compound statement depending on the truth value of the propositions it connects.\n"
"The following truth table illustrates this for the previously discussed `‚àß` connective.\n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"T & F & F \\\\\n"
"F & T & F \\\\\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that `P ‚àß Q` is true when both `P` is true and `Q` is true, being false otherwise."
msgstr ""

#: Game.Doc.doc
msgid "# Truth Table\n"
"$\n"
"\\begin{array}{|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚à® Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & T \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"From the truth table, we can see that if one of `P`,`Q` is true then `P ‚à® Q` is true. \n"
"\n"
"Therefore, if we have `P ‚à® Q` as our goal, it is enough to prove `P` or to prove `Q`.\n"
"\n"
"Having `P ‚à® Q` as the goal, you can tell Lean that you want to prove the left side by simply typing `left` or the right side by simply typing `right`."
msgstr ""

#: Game.Doc.doc
msgid "`‚à©` is an operator on sets.\n"
"\n"
"Applying it to two sets `A`,`B`:\n"
"```\n"
"A ‚à© B\n"
"```\n"
"\n"
"`A ‚à© B` is itself another set, containing elements that are in both `A` and `B`.\n"
"In other words, `x ‚àà A ‚à© B ‚Üî x ‚àà A ‚àß x ‚àà B`.\n"
"\n"
"`A ‚à© B = ‚àÖ` means that `A` and `B` have no common element i.e no element of `A` belongs to both and no element of `B` belongs to both.\n"
"In other words, `x ‚àà A ‚Üí x ‚àâ B` , `x ‚àà B ‚Üí x ‚àâ A` which are `inleft_notinright` and `inright_notinleft` respectively."
msgstr ""

#: Game.Doc.doc
msgid "`rfl` is short for reflexivity. In the context of numbers, it is the property that for any number `a`, `a = a`.\n"
"\n"
"`rfl` also applies more generally, `rfl` will close any goal of the form `A=B` where `A`,`B` are identical. If needed, `rfl` will unfold both sides into their definitions and then check if they are equal. In other words, `rfl` can prove the equality of two things that are 'equal by definition'.\n"
"\n"
"In fact, `rfl` is not a tactic but syntactic sugar for `exact rfl`. `rfl` is of type `a = a` for any `a`.\n"
"\n"
"## examples\n"
"```\n"
"x - 7 = x - 7\n"
"```\n"
"`rfl` will close this goal."
msgstr ""

#: Game.Doc.doc
msgid "The assumption tactic searches for an assumption that matches the goal, and closes the goal if it finds one.\n"
"\n"
"Given,\n"
"```\n"
"Objects\n"
"P : Prop\n"
"\n"
"Assumptions\n"
"hP : P\n"
"\n"
"Goal\n"
"P\n"
"```\n"
"`assumption` will close the goal."
msgstr ""

#: Game.Doc.doc
msgid "Given,\n"
"```\n"
"PorQ : P ‚à® Q\n"
"\n"
"Goal\n"
"some-goal\n"
"```\n"
"`cases PorQ` will first assume `P` and ask you to prove `some-goal` and then it will assume `Q` and ask you to prove `some-goal`. So in both cases, `some-goal` is true. Therefore we can conclude `some-goal`. This is called a proof by cases."
msgstr ""

#: Game.Doc.doc
msgid "`intro` tactic is used to deal with goals of the form `P ‚Üí Q`.\n"
"\n"
"Having the following:\n"
"```\n"
"Goal:\n"
"P ‚Üí Q\n"
"```\n"
"We want to prove that 'If `P` is true, then `Q` is true'. \n"
"\n"
"To do this, we first need to assume `P` then prove `Q`. Assuming `P` is done using `intro name` for any 'name'."
msgstr ""

#: Game.Doc.doc
msgid "The `constructor` tactic will split a goal of the form `P ‚àß Q` into two subgoals `P`,`Q` where you can deal with each one separately."
msgstr ""

#: Game.Doc.doc
msgid "Contradiction is a tactic that detects if you have contradictory assumptions and if so, closes the goal.\n"
"\n"
"Having\n"
"```\n"
"h : False\n"
"```\n"
"or\n"
"```\n"
"hP : P \n"
"hnP : ¬¨P\n"
"```\n"
"(or other 'simple' contradictions)\n"
"`contradiction` will close any goal."
msgstr ""

#: Game.Doc.doc
msgid "Given the following:\n"
"```\n"
"Assumptions:\n"
"h : A = B\n"
"\n"
"Goal:\n"
"some expression involving A\n"
"```\n"
"\n"
"`rw [h]` would change the goal by replacing every occurrence of `A` with `B`.\n"
"\n"
"By default, rw uses an equation in the forward direction, matching the left-hand side of the equation `h` with an occurrence of `A` in the goal, and replaces it with the right-hand side i.e `B`. \n"
"\n"
"The notation `rw [‚Üêh]` can be used to instruct the tactic to use the equality `h` in the reverse direction i.e replace an occurrence of `B` with `A`.\n"
"\n"
"## Behavior with `=` and `‚Üî`\n"
"For `rw [h]`, the behavior is exactly the same for both, whether you had `h : x=2` or `h : P ‚Üî Q`."
msgstr ""

#: Game.Doc.doc
msgid "Having the goal of the form:\n"
"```\n"
"P ‚à® Q\n"
"```\n"
"for `P Q : Prop`, `left` transforms the goal to `P`."
msgstr ""

#: Game.Doc.doc
msgid "Having the goal of the form:\n"
"```\n"
"P ‚à® Q\n"
"```\n"
"for `P Q : Prop`, `right` transforms the goal to `Q`."
msgstr ""

#: Game.Doc.doc
msgid "## Syntax\n"
"\n"
"### without specifying the type\n"
"`have name := some-term `\n"
"where `name` is the new assumption that will appear which will have `some-type` where `some-term : some-type` and `some-type : Prop` i.e `some-term` is a proof of some proposition.\n"
"\n"
"### with specifying the type\n"
"```\n"
"have name : some-proposition := by\n"
"  proof steps\n"
"  ...\n"
"  proof steps\n"
"```\n"
"You would need to use editor mode if there are multiple proof steps.\n"
"\n"
"Inside the have block, you would have a new goal which is `some-proposition` say `x=2` , `A ‚àà Knight` etc...\n"
"\n"
"Not specifying the `type` when using `have` doesn't allow you to use tactics.\n"
"\n"
"## Examples\n"
"\n"
"Given the following assumptions from lemmas world, level 1:\n"
"```\n"
"Assumptions:\n"
"Aleft : A ‚àà left \n"
"Aright : A ‚àà right \n"
"h: left ‚à© right = ‚àÖ\n"
"AinBothInter: A ‚àà left ‚àß A ‚àà right ‚Üí A ‚àà left ‚à© right\n"
"```\n"
"\n"
"### without specifying the type\n"
"`have AinBoth := AinBothInter (And.intro Aleft Aright)` will add the following to the assumptions:\n"
"```\n"
"AinBoth : A ‚àà left ‚à© right\n"
"```\n"
"\n"
"### specifying the type\n"
"`have  AinBoth : A ‚àà left ‚à© right := by AinBothInter (And.intro Aleft Aright)` will add the following to the assumptions in the proof state:\n"
"```\n"
"AinBoth : A ‚àà left ‚à© right\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid "`And.intro` takes a proof of `P`, a proof of `Q`, and gives a proof of `P ‚àß Q` where `P Q : Prop`.\n"
"\n"
"Given,\n"
"```\n"
"hP : P\n"
"hQ : Q\n"
"```\n"
"we have `And.intro hP hQ : P ‚àß Q`"
msgstr ""

#: Game.Doc.doc
msgid "Refer to `Prop` documentation if you need to.\n"
"\n"
"## Overview\n"
"For the following proof state:\n"
"```\n"
"Objects\n"
"P : Prop\n"
"\n"
"Assumptions\n"
"hP : P\n"
"\n"
"Goal:\n"
"P\n"
"```\n"
"Remember that `hP : P` where `P : Prop` means `hP` is a proof of `P`.\n"
"\n"
"Since the goal is to prove `P`, the only thing we have to do is to let Lean know that we do have such a proof. In other words, `hP` is EXACTLY whats needd to prove the goal. The type of `hP` EXACTLY matches the goal.\n"
"\n"
"exact h asserts that h is exactly whats needed to prove the goal which makes sense because h is a proof of P.(It doesn't matter what P is)\n"
"This is done by `exact h`."
msgstr ""

#: Game.Doc.doc
msgid "Here we introduce the `have` tactic which allows us to add theorems to the context(which you would have to prove, of course). \n"
"\n"
"```\n"
"`have name-of-object : type := by ...` \n"
"```\n"
"where `...` is the proof.\n"
"`name-of-object` can be whatever you want, leaving it empty would  give the theorem a name automatically. The `type` in this case is the statement we want to prove."
msgstr ""

#: Game.Doc.doc
msgid "The `contradiction` tactic works for the following proofs states:\n"
"```\n"
"h : False\n"
"```\n"
"\n"
"```\n"
"hP : P\n"
"hnP : ¬¨P\n"
"```\n"
"\n"
"and\n"
"```\n"
"hP : P\n"
"```\n"
"where Lean knows that `¬¨P` is true.\n"
"\n"
"Example:\n"
"-- disjoint\n"
"You need to show that having two sets being disjoint (i.e sharing no common element) and having a common element is a contradiction."
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid "Another way to express this is that you have two possibilities one of which(or both) is supposed to be true, and you know its definitely not the second option. All is left is the first option. \n"
"\n"
"Given the statement, its either 'this' or 'that'. If we know its not 'that' then its definitely 'this'."
msgstr ""

#: Game.Doc.doc
msgid "```\n"
"theorem inleft_notinright\n"
"(h : left ‚à© right = ‚àÖ )\n"
"(Aleft : A ‚àà left)\n"
": A ‚àâ right\n"
"```\n"
"\n"
"Given the following proof state:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"left right : Finset Inhabitant\n"
"\n"
"Assumptions\n"
"h : left ‚à© right = ‚àÖ\n"
"Aleft : A ‚àà left\n"
"\n"
"Goal\n"
"A ‚àâ right\n"
"```\n"
"\n"
"exact `inleft_notinright h Aleft` will close the goal."
msgstr ""

#: Game.Doc.doc
msgid "```\n"
"theorem disjoint\n"
"(h : left ‚à© right = ‚àÖ )\n"
"(Aleft : A ‚àà left)\n"
"(Aright : A ‚àà right)\n"
": False\n"
"```\n"
"\n"
"Given the following proof state:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"left right : Finset Inhabitant\n"
"\n"
"Assumptions\n"
"h : left ‚à© right = ‚àÖ \n"
"Aleft : A ‚àà left\n"
"Aright : A ‚àà right\n"
"\n"
"Goal\n"
"False\n"
"```\n"
"\n"
"`exact disjoint h Aleft Aright` will close the goal"
msgstr ""

#: Game.Doc.doc
msgid "A summary of all the terminology presented throughout the game, in order of appearance.\n"
"\n"
"Theorems represent an implication say:\n"
"```\n"
"thm : P ‚Üí Q\n"
"```\n"
"\n"
"They work for `P`,`Q` of any type. What `thm` means is the following, give me an object of type `P` and i will return an object of type `Q`. \n"
"\n"
"Therefore, theorems expect arguments given in a specific order after which the obtained expression is an object which has the conclusion as its type.\n"
"\n"
"For\n"
"```\n"
"thm : P ‚Üí Q\n"
"hP : P\n"
"```\n"
"`(thm hP) : Q`\n"
"\n"
"For the special case where `P : Prop`, `Q : Prop` ,the interpretation of `thm` is what implication in logic means.  \n"
"\n"
"What `thm` means is the following, give me an object of type `P` which in this case is a proof of `P` and i will return an object of type `Q` which in this case is a proof of `Q`. \n"
"\n"
"In other words, `thm` means 'If P is true, then Q is true'."
msgstr ""

#: Game.Doc.doc
msgid "## Definition\n"
"A set is a collection of 'entities' or 'objects' that satisfy a certain property. The objects in a set are called 'elements' of the set.\n"
"\n"
"A finite set is a set with finitely many elements.\n"
"\n"
"## Examples\n"
"The set `Knight` would be the set of inhabitants of the island that are knights i.e satisfying the property of always telling the truth, the set `Knave` being the set of inhabitants of the island that are knaves i.e the ones that always lie.\n"
"\n"
"## In Lean\n"
"\n"
"```\n"
"Set K\n"
"Set Inhabitant\n"
"```\n"
"\n"
"```\n"
"Finset K\n"
"Finset Inhabitant\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid "Given the following proof state:\n"
"```\n"
"left : Finset K\n"
"```\n"
"\n"
"`A ‚àà left` read as 'A in left'.\n"
"\n"
"`A ‚àâ left` read as 'A not in left' means `¬¨(A ‚àà left)` , `A ‚àà left ‚Üí False`."
msgstr ""

#: Game.Doc.doc
msgid "## Objects\n"
"\n"
"The objects involved are:\n"
"- of type inhabitant indicated by a capital letter\n"
"- the two finite sets `Knight` , `Knaves`.\n"
"\n"
"As a proof state:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"B : Inhabitant \n"
"C : Inhabitant\n"
"Knight : Finset Inhabitant\n"
"Knave : Finset Inhabitant\n"
"```\n"
"There will be at most three inhabitants in the puzzles for simplicity, but you can ofcourse have more.\n"
"\n"
"## Assumptions\n"
"Knights tell the true and knaves lie. So no one can be both at the same time i.e `Knight ‚à© Knave = ‚àÖ`\n"
"\n"
"Moreover, every inhabitant is either a knight or a knave i.e `A ‚àà Knight ‚à® A ‚àà Knave` for any `A : Inhabitant`.\n"
"\n"
"As a proof state:\n"
"```\n"
"Assumptions:\n"
"h : Knight ‚à© Knave = ‚àÖ \n"
"Or : A ‚àà Knight ‚à® A ‚àà Knave\n"
"```\n"
"\n"
"## Summary\n"
"Putting every together:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"B : Inhabitant \n"
"C : Inhabitant\n"
"Knight : Finset Inhabitant\n"
"Knave : Finset Inhabitant\n"
"\n"
"Assumptions\n"
"h : Knight ‚à© Knave = ‚àÖ \n"
"Or : A ‚àà Knight ‚à® A ‚àà Knave\n"
"```\n"
"\n"
"## Translating statements to formal notation\n"
"Given an inhabitant `A`,\n"
"\n"
"The translation we use is based on the following:\n"
"- If `A` is a knight, then `A`'s statement is true.\n"
"- If `A`'s statement is true, then `A` is telling the truth i.e is a knight.\n"
"\n"
"Formally:\n"
"```\n"
"A ‚àà Knight ‚Üí statement-of-A\n"
"statement-of-A ‚Üí A ‚àà Knight\n"
"```\n"
"where `statement-of-A : Prop` represents `A`'s statement.\n"
"\n"
"Combining them we get,\n"
"```\n"
"stA : A ‚àà Knight ‚Üî statement-of-A\n"
"```\n"
"\n"
"### Quick Example\n"
"If,\n"
"```\n"
"A says B is a knave\n"
"```\n"
"\n"
"then,\n"
"```\n"
"A ‚àà Knight ‚Üí B ‚àà Knave\n"
"B ‚àà Knave ‚Üí A ‚àà Knight\n"
"```\n"
"\n"
"Combining them using `‚Üî`:\n"
"```\n"
"stA : A ‚àà Knight ‚Üî B ‚àà Knave\n"
"```\n"
"\n"
"### equivalent translations, using knaves\n"
"Given inhabitant `A`,\n"
"\n"
"The translation we use is based on the following:\n"
"- If `A` is a knave, then `A`'s statement is false, i.e its negation is true.\n"
"- If `A`'s statement is false, then `A` is lying i.e is a knave.\n"
"\n"
"Formally:\n"
"```\n"
"A ‚àà Knave ‚Üí ¬¨statement-of-A\n"
"¬¨statement-of-A ‚Üí A ‚àà Knave\n"
"```\n"
"where `statement-of-A : Prop` represents `A`'s statement.\n"
"\n"
"Combining them we get,\n"
"```\n"
"stAn : A ‚àà Knave ‚Üî ¬¨statement-of-A\n"
"```\n"
"\n"
"### Quick Example\n"
"If,\n"
"```\n"
"A says B is a knave\n"
"```\n"
"\n"
"then,\n"
"```\n"
"A ‚àà Knave ‚Üí ¬¨(B ‚àà Knave)\n"
"¬¨(B ‚àà Knave) ‚Üí A ‚àà Knave\n"
"```\n"
"\n"
"Combining them using `‚Üî`:\n"
"```\n"
"stAn : A ‚àà Knave ‚Üî ¬¨(B ‚àà Knave)\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid "### **Logic Constants & Operators**\n"
"| $Name~~~$ | $Ascii~~~$ | $Unicode$ | $Unicode Cmd$ |\n"
"| --- | :---: | :---: | --- |\n"
"| True | `True` |  |  |\n"
"| False | `False` |  |  |\n"
"| Not | `Not` | ¬¨ |  `\\not` `\\neg`  |\n"
"| And | `/\\` | ‚àß | `\\and`  |\n"
"| Or | `\\/` | ‚à® |  `\\or`  |\n"
"| Implies | `->` | ‚Üí |  `\\imp` |\n"
"| Iff | `<->` | ‚Üî | `\\iff` |\n"
"\n"
"### **Other Unicode**\n"
"| $Name$ | $Unicode~~~$ | $Unicode Cmd$ |\n"
"| --- | :---: | --- |\n"
"| Angle brackets | ‚ü®‚ü© | `\\<>` |\n"
"| Left Arrow | ‚Üê | `\\l` `\\leftarrow` `\\gets` `\\<-` |"
msgstr ""

#: Game.Doc.doc
msgid "`P ‚Üî Q`  is defined as `(P ‚Üí Q) ‚àß (Q ‚Üí P)`. \n"
"\n"
"Its truth table looks like the folowing:\n"
"$\n"
"\\begin{array}{|c c|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q & Q ‚Üí P & P ‚Üí Q ‚àß Q ‚Üí P\\\\\n"
"\\hline\n"
"T & T & T & T & T \\\\\n"
"\\hline\n"
"T & F & F & T & F \\\\\n"
"\\hline\n"
"F & T & T & F & F \\\\\n"
"\\hline\n"
"F & F & T & T & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"So, `P ‚Üî Q` is true when `P,Q` are true or `P,Q` are false, i.e when `P` and `Q` have the same truth value. Therefore, `P` and `Q` are equivalent from a truth value perspective regardless what the statement of `P` and of `Q` is.\n"
"\n"
"## Extracting Each Implication\n"
"```\n"
"h : P ‚Üî Q\n"
"h.mp : P ‚Üí Q\n"
"h.mpr : Q ‚Üí P\n"
"```\n"
"`h.mp` is the forward direction and `h.mpr` is the backward direction.\n"
"\n"
"## `P ‚Üî Q` is `P = Q`\n"
"Since `P`, `Q` have the same truth value , they can be used interchangeably.\n"
"You can think of `P ‚Üî Q` as `P = Q` and use `rw` in the same way you would if there was an actual `=` in the expression.\n"
"\n"
"For example:\n"
"```\n"
"h : P ‚Üî Q\n"
"hP : P\n"
"```\n"
"Doing `rw [h] at hP` results in:\n"
"```\n"
"h : P ‚Üî Q\n"
"hP : Q\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid ""
msgstr ""

#: Game.Doc.doc
msgid "As an implication\n"
"```\n"
"Knight ‚à© Knave = ‚àÖ ‚Üí\n"
"A ‚àà Knight ‚à® A ‚àà Knave ‚Üí\n"
"(A ‚àà Knight ‚Üî A ‚àà Knave) ‚Üí False\n"
"```"
msgstr ""

#: Game.Doc.doc
msgid "```\n"
"theorem inright_notinleft\n"
"(h : left ‚à© right = ‚àÖ )\n"
"(Aright : A ‚àà right)\n"
": A ‚àâ left\n"
"```\n"
"\n"
"Given the following proof state:\n"
"```\n"
"Objects\n"
"A : Inhabitant\n"
"left right : Finset Inhabitant\n"
"\n"
"Assumptions\n"
"h : left ‚à© right = ‚àÖ\n"
"Aright : A ‚àà right\n"
"\n"
"Goal\n"
"A ‚àâ left\n"
"```\n"
"\n"
"exact `inright_notinleft h Aright` will close the goal."
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "`rfl`, A Number Equals Itself"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "In this exercise, we will prove `2 = 2`\n"
"\n"
"`rfl` will do the job.\n"
"\n"
"`rfl` is short for reflexivity, which is the property that for any number `a`, `a = a`"
msgstr ""

#: Game.Levels.EquationalReasoning.L01_rfl
msgid "Notice that 'level completed! üéâ' on the bottom. We say that the goal is closed/proven."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "`exact` , goal is true by assumption"
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "In this level, we have `Objects`, `Assumptions`, and the `Goal`.\n"
"\n"
"# Objects\n"
"Objects will always be variables(letter symbols) we are working with. What these variables denote is specified after the `:`, what is after the `:` is called the type of the object.  \n"
"\n"
"Here, `x`  denotes a number but we don't know which number it is. The `: ‚Ñï` in `x : ‚Ñï` means that `x` is a variable of type natural number(positive numbers like `1`,`2`,`3`, and so on...). \n"
"\n"
"# Assumptions\n"
"As for the assumptions, we have `h : x=2` which means that `h` is an object of type `x=2`. This essentially means that `h` is an object asserting that the proposition(or statement) `x=2` is true. In other words, we know that `x=2` and `h` is a proof of that. \n"
"\n"
"# Goal\n"
"Our goal is to prove that `x = 2`.\n"
"Always look at the assumptions which represent everything you know. Well, we already have that `h` is a proof of the goal. \n"
"We should let Lean know. Using `exact h` accomplishes this."
msgstr ""

#: Game.Levels.EquationalReasoning.L02_exact
msgid "The `exact` in `exact h` tells Lean that `h`'s type EXACTLY matches the goal. In other words, `h` is EXACTLY what we need to prove the goal. Lean verifies this and reports that there are no more goals to prove. We are done.\n"
"\n"
"The `assumption` tactic can also be used here which searches for an assumption that matches the goal, and closes the goal if it finds one."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Substituting Variables By Their Values"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "We will learn how to substitute a variable with its value, for example how to substitiute `x` by `2` if we know that `x=2`.\n"
"\n"
"This can be done using the tactic `rw` (short for rewrite).\n"
"\n"
"`rw` takes a term of type `A=B` and replaces all the `A`s in the goal with `B`s.\n"
"So `rw [h]` where `h : x=3` will replace all the `x`s of the goal with `3`."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Do `rw [¬´{h}¬ª]` or `rw [¬´{g}¬ª]` and observe what happens."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "You should use `¬´{h}¬ª` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "`rw [h]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "You should use `¬´{g}¬ª` now."
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "`rw [g]`"
msgstr ""

#: Game.Levels.EquationalReasoning.L03_rw
msgid "Our goal is now `3 + 3 = 6`. The `rw` tactic implicitly executes `rfl` after doing the rewrite which unfolds the numbers `3` and `6` to what they are defined as, and it turns out both sides are identical.\n"
"\n"
"Another solution:\n"
"```\n"
"rw [h,g]\n"
"```\n"
"instead of\n"
"```\n"
"rw [h]\n"
"rw [g]\n"
"```"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "`Nat.mul_left_cancel` , Divide both sides of an equation"
msgstr ""

#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "We know that `4 * y = 16`. Dividing both sides by `4` gives us `y = 4` which is the goal.\n"
"\n"
"The theorem to do this is:\n"
"```\n"
"Nat.mul_left_cancel firstarg secondarg\n"
"```\n"
"where the `firstarg` is a theorem that the number you are cancelling from both sides is positive, in our case this would be `four_pos`. \n"
"\n"
"The `secondarg` would be the equation you are working with, in this case `h`.\n"
"\n"
"`Nat.mul_left_cancel firstarg secondarg` would be a proof of the resulting equation after cancelling the positive number specified in `firstarg` from both sides of the equation specified in `secondarg`.\n"
"\n"
"Give this proof to Lean using `exact`."
msgstr ""

#: Game.Levels.EquationalReasoning.L04_mul_left_cancel
msgid "Here is the type signature of Nat.mul_left_cancel:\n"
"  ```\n"
"Nat.mul_left_cancel {n m k : ‚Ñï} (np : 0 < n) (h : n * m = n * k) : m = k\n"
"  ```\n"
"  `Nat.mul_left_cancel` takes two arguments which are:\n"
"   - `np`, a proof that some number `n` is positive.\n"
"   - `h`, the equation which has `n` on both sides of the equation multiplied on the left.\n"
"\n"
"  The result is canceling `n` from both sides of the equation."
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "Equational Reasoning"
msgstr ""

#: Game.Levels.EquationalReasoning
msgid "In this world, you will learn how to solve equations."
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "This should look familiar.\n"
"\n"
"If it doesn't, then replace `P` by `x=2`.\n"
"\n"
"`hP` is of type `P` and `P` is of type `Prop`. So, `hP` is a proof of `P`. Our goal is to prove `P`. We already have such a proof which is `hP`, `hP` is EXACTLY what we need to prove the goal. The type of `hP` EXACTLY matches the goal."
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "Type `exact hP`!"
msgstr ""

#: Game.Levels.Logic.L01_Intro
msgid "In the next levels, we will discuss how to construct new propositions from old ones whose meaning and truth value would depend on those old ones."
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "And , `‚àß`"
msgstr ""

#: Game.Levels.Logic.L02_And
msgid "In this level, we introduce the `‚àß` logical connective (read as 'and').\n"
"\n"
"Remember the following example:\n"
"Given the two propositions `x=2`(`P`), `y=6`(`Q`) , we can construct a new propositon `x=2 ‚àß y=6`(`P ‚àß Q`) which is read as `x=2 and y=6`(`P and Q`).\n"
"\n"
"What is the truth value of this new proposition `x=2 ‚àß y=6`(`P ‚àß Q`)? \n"
"Well, it would depend on truth value of the two component propositions `x=2`(`P`) ,`y=6`(`Q`).\n"
"\n"
"What possibilities are there for each's truth value? `x=2` (`P`) can either be true or false and similarly for `y=6`(`Q`). Here is a truth table that goes through all these possibilities: \n"
"`T` stands for true\n"
"`F` stands for false\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"x=2 & y=6 & x=2 ‚àß y=6 \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & F \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"\n"
"The proposition `x=2 ‚àß y=6`(`P ‚àß Q`) is true when `x=2`(`P`) is true AND `y=6`(`Q`) is true.\n"
"In other words, if `P` is true AND `Q` is true. This is how things work regardless of what `P` is, what `Q` is. The only thing that matters is their truth value.\n"
"Therefore, the more general truth table is the same:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚àß Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & F \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that `P ‚àß Q` is true when both `P` is true and `Q` is true, being false otherwise.\n"
"\n"
"From this, we conclude that we can introduce `‚àß` if we have a proof of `P` and a proof of `Q`.\n"
"```\n"
"  And.intro  (left : P) (right : Q) : P ‚àß Q\n"
"```\n"
"\n"
"You can think of `And.intro` as a function that takes two inputs: a proof of `P`, a proof of `Q` and returns a proof of `P ‚àß Q`.\n"
"\n"
"For example:\n"
"```\n"
"And.intro arg1 arg2 \n"
"```\n"
"where `arg1 : P` , `arg2 : Q` , `(And.intro arg1 arg2) : P ‚àß Q`. \n"
"\n"
"Use it to construct an object of type `P ‚àß Q`, and use `exact` to close the goal."
msgstr ""

#: Game.Levels.Logic.L02_And
msgid ""
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "Or, `‚à®`"
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "In this level, we introduce the `‚à®` logical connective read as 'or'.\n"
"\n"
"Its truth table is as follows:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚à® Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & T \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"From this truthtable, we conclude that to prove `P ‚à® Q`,  we need either `P` being true or `Q` being true or both.\n"
"\n"
"You can tell Lean which side of `‚à®` you want to prove by simply executing `left` or `right`.\n"
"\n"
"In our case, we know the left side of `‚à®` is true, so use `left`."
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid "We have a proof that `P` is true, and we want to prove `P`"
msgstr ""

#: Game.Levels.Logic.L03_Or
msgid ""
msgstr ""

#: Game.Levels.Logic.L04_Implication
msgid "Implication, ‚Üí"
msgstr ""

#: Game.Levels.Logic.L04_Implication
msgid "In this level, we introduce the logical implication `‚Üí` connective.\n"
"Logical implication `P ‚Üí Q` is made up of two components:\n"
"- The premise, which in this case is `P`\n"
"- The conclusion, which in this case is `Q`\n"
"\n"
"`P ‚Üí Q` is read as 'If `P` is true, then `Q` is true.\n"
"The truth of `P` IMPLIES the truth of `Q`. A proof of `P` IMPLIES a proof of `Q`.\n"
"\n"
"# truth table\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"A statement `P ‚Üí Q` is false when `P` is true and `Q` false, it's true otherwise.\n"
"This is because this is the only case where the meaning of `P ‚Üí Q` is violated i.e we have that `P` is true so `Q` is supposed to be true as well but its not.\n"
"\n"
"When `P` is false, the implication `P ‚Üí Q` is always false because the implication does not tell us what should happen when `P` is false.\n"
"\n"
"In the current proof state, we know `P` (i.e `P` is true) , and we know `P ‚Üí Q` (i.e `P ‚Üí Q` is true). Therefore, we can conclude `Q` (i.e `Q` is true ).\n"
"\n"
"You can think of logical implication as a function with one input and one output. It takes a proof of `P` and returns a proof of `Q`."
msgstr ""

#: Game.Levels.Logic.L04_Implication
msgid "In the next level, you will learn how to deal with an implication as the goal you have to prove."
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "Proving an implication, Implication as the goal"
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "The goal, translated to english is: 'If P is true, then P is true'.\n"
"\n"
"To prove such a goal, we need to assume that `P` is true. Then, we have to prove that `P` is true.\n"
"\n"
"To do this, we need to assume the premise i.e introduce it to our assumptions. We can do this using `intro`.\n"
"\n"
"After that , we have to prove the consequent."
msgstr ""

#: Game.Levels.Logic.L05_ImpGoal
msgid "use `intro name` to give the introduced hypothesis a name"
msgstr ""

#: Game.Levels.Logic.L06_Not
msgid "Not Connective, ¬¨"
msgstr ""

#: Game.Levels.Logic.L06_Not
msgid "In this level we introduce the negation, the `¬¨` connective (read as 'not').\n"
"\n"
"Notice that this is the first logical connective that applies on one proposition only and not two.\n"
"\n"
"The job of this connective(as the name implies), is to negate a proposition meaning that:\n"
"- For `P` true, `¬¨P` is false.\n"
"- For `P` false, `¬¨P` is true.\n"
"\n"
"In truth table form:\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & ¬¨P \\\\\n"
"\\hline\n"
"T & F \\\\\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that since `P` is true, `¬¨P` should be false but in this proof state it is true (by `hnP`). This is a contradiction. The goal is to prove `False` which means to prove a contradiction.\n"
"\n"
"Note that we don't need to introduce a new symbol to define negation, it can be defined in terms of what we already know.\n"
"\n"
"Consider the following truth table: \n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P & P ‚Üí False \\\\\n"
"\\hline\n"
"T & F  \\\\\n"
"F & T  \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"Notice that regardless of the truth value of `P`, the two propositions `¬¨P` and `P ‚Üí False` have the same truth table. Therefore, they can be used interchangeably.(we say that these two expressions are logically equivalent, but let's leave this to a future level)\n"
"\n"
"What `¬¨P` means is that if `P` were true, then we can deduce a contradiction. We know that `P` is true. Therefore, we can prove a contradiction which is the goal.\n"
"\n"
"To see `¬¨P` in its implication form, you can do `unfold Not` to unfold the definition of `¬¨`. Note that this would apply to the goal, and so `unfold Not at hnP` applies at `hnP`."
msgstr ""

#: Game.Levels.Logic.L06_Not
msgid "Remember that an implication acts like a function, that takes a proof of whats on the left hand returning a proof of whats on the right hand side.\n"
"\n"
"For this level, `¬¨P` being true tells us that a proof of `P` gives us a proof of `False`. We have a proof of `P`. Therefore we can obtain a proof of `False` which is the goal."
msgstr ""

#: Game.Levels.Logic.L06_Not
msgid "Remember that an implication acts like a function, that takes a proof of whats on the left hand returning a proof of whats on the right hand side.\n"
"\n"
"For this level, `¬¨P` being true tells us that a proof of `P` gives us a proof of `False`. We have a proof of `P`. Therefore we can obtain a proof of `False` which is the goal."
msgstr ""

#: Game.Levels.Logic.L06_Not
msgid "In the next level, we will explore what it means to have proven `False`."
msgstr ""

#: Game.Levels.Logic.L07_False
msgid "From `False`, anything follows."
msgstr ""

#: Game.Levels.Logic.L07_False
msgid "We proved `False`, what does this mean? What can we conclude? What does `False` IMPLY?\n"
"\n"
"Let's check the `‚Üí` truth table:\n"
"$$\n"
"\\begin{array}{|c|c|c|}\n"
"\\hline\n"
"P & Q & P ‚Üí Q \\\\\n"
"\\hline\n"
"T & T & T \\\\\n"
"\\hline\n"
"T & F & F \\\\\n"
"\\hline\n"
"F & T & T \\\\\n"
"\\hline\n"
"F & F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$$\n"
"\n"
"Let's focus on part of the truth table where `P` is `False`, because we want to see what `False` implies.\n"
"$$\n"
"\\begin{array}{|c|c|c|}\n"
"\\hline\n"
"Q & False ‚Üí Q \\\\\n"
"\\hline\n"
"T & T \\\\\n"
"\\hline\n"
"F & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$$\n"
"\n"
"We have that the implication `False ‚Üí Q` is true regardless what `Q` represents and regardless whether `Q` is true or is false. \n"
"So `False` implies any proposition. This principle is known as: 'From `False` anything follows'.\n"
"\n"
"Use the implication `False.elim (h : False) : C` to prove `Q` where `Q` is any proposition."
msgstr ""

#: Game.Levels.Logic.L07_False
msgid "Having proven `False`, instead of going through this to prove `Q` you can use the the `contradiction` tactic. If you were able to prove `False`, then the `contradiction` tactic will prove the goal regardless what the goal is because 'from `False`, anything follows'.\n"
"\n"
"Proving `False` is what's usually called deriving a contradiction, and note that to prove `False` you would first need to have a proof `P`, and a proof of `¬¨P` i.e `P ‚Üí False`."
msgstr ""

#: Game.Levels.Logic.L08_LogicalEquivalence
msgid "Logical Equivalence, `‚Üî`"
msgstr ""

#: Game.Levels.Logic.L08_LogicalEquivalence
msgid "`P ‚Üî Q`  is defined as `(P ‚Üí Q) ‚àß (Q ‚Üí P)`.\n"
"\n"
"Its truth table looks like the folowing:\n"
"$\n"
"\\begin{array}{|c c|c c|c|} \n"
"\\hline\n"
"P & Q & P ‚Üí Q & Q ‚Üí P & P ‚Üí Q ‚àß Q ‚Üí P\\\\\n"
"\\hline\n"
"T & T & T & T & T \\\\\n"
"\\hline\n"
"T & F & F & T & F \\\\\n"
"\\hline\n"
"F & T & T & F & F \\\\\n"
"\\hline\n"
"F & F & T & T & T \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"So, `P ‚Üî Q` is true when `P,Q` are true or `P,Q` are false, i.e when `P` and `Q` have the same truth value. Therefore, `P` and `Q` are equivalent from a truth value perspective regardless what the statement of `P` and of `Q` is.\n"
"\n"
"In this level we have `PsameQ : P ‚Üî Q`(`P`, `Q` have the same truth value) and `hP : P`(`P` is true) and so `Q` is true as well.\n"
"\n"
"There are a number of ways to prove this level:\n"
"- You can extract the forward direction of `h :P ‚Üî Q` which is `h.mp : P ‚Üí Q` and use `hP : P` to prove `Q`(`h.mpr : Q ‚Üí P` is the backward direction).\n"
"- Since `PsameQ` means that `P` and `Q` have the same truth value, you can pretend `‚Üî` is instead `=` and use `rw` at `hP : P` to obtain `hP : Q` and then close the goal."
msgstr ""

#: Game.Levels.Logic.L08_LogicalEquivalence
msgid ""
msgstr ""

#: Game.Levels.Logic
msgid "Logic"
msgstr ""

#: Game.Levels.Logic
msgid "In this world, we will be dealing with `Objects` of type `Prop` i.e propositions. You can think of a proposition as a statement that is either true or false(obviously, it can't be both at the same time). You have seen propositions before like `x=2`, `y=6` etc..\n"
"\n"
"When you have `h : P` where `P : Prop` , then we say `h` is a proof of the statement `P`(imagine `x=2` instead of `P` if you wish).\n"
"\n"
"In a proof state, this would look like the following:\n"
"```\n"
"Objects\n"
"P : Prop\n"
"Assumptions\n"
"h : P\n"
"```\n"
"\n"
"Moreover, we will discuss constructing new propositions from old ones.\n"
"\n"
"Here's an example in natural language, given the two propositions 'The sun is shining' , 'It is Monday', you can construct 'The sun is shining and it is monday'. \n"
"\n"
"Another example would be, having the following:\n"
"```\n"
"h : `x=2`\n"
"h' : `y=6`\n"
"```\n"
"where `P` is `x=2` and `Q` is `y=6`, we can construct a new proposition `P ‚àß Q` which is read as `x=2 and y=6`. Here we know what `P`,`Q` stand for. But, the proposition `P ‚àß Q` can still be constructed and reasoned about regardless. Think of reasoning about unknown numbers like `x`,`y` etc..."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "`disjoint` theorem"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "Before diving into an actual knights and knaves puzzle, lets explore basic results implied by the assumptions of this puzzle.\n"
"\n"
"We will first look at the assumption that no one can be a knight and a knave at the same time.\n"
"It is represented as:\n"
"```\n"
"h : Knight ‚à© Knave = ‚àÖ \n"
"```\n"
"\n"
"The reasoning in this level applies to any two finite sets, so we use the two sets `left`,`right`.\n"
"\n"
"In our problem, we have:\n"
"```\n"
"Aleft: A ‚àà left\n"
"Aright: A ‚àà right\n"
"h : left ‚à© right = ‚àÖ\n"
"```\n"
"This means that `A` belongs to both `left` and `right` i.e `A ‚àà left ‚à© right`.\n"
"\n"
"So, we do have someone who is both a knight and a knave. \n"
"This would contradict `h` giving us `False` which is the goal.\n"
"\n"
"To show `A ‚àà left ‚à© right`, use the following\n"
"```\n"
"Finset.mem_inter : a ‚àà s‚ÇÅ ‚à© s‚ÇÇ ‚Üî a ‚àà s‚ÇÅ ‚àß a ‚àà s‚ÇÇ\n"
"```\n"
"\n"
"Notice `have`, ... explain"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "The backward direction `Finset.mem_inter.mpr : a ‚àà s‚ÇÅ ‚àß a ‚àà s‚ÇÇ ‚Üí a ‚àà s‚ÇÅ ‚à© s‚ÇÇ` is needed here."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "But,  `left ‚à© right = ‚àÖ` so `A ‚àà ‚àÖ` \n"
"\n"
"We know that `left ‚à© right = ‚àÖ`, so replace it with `‚àÖ` using `rw` getting `A ‚àà ‚àÖ`.\n"
"\n"
"`rw [h]` would apply on the goal, but we want it to apply at `¬´{AinInter}¬ª`. And so `rw [h] at ¬´{AinInter}¬ª` will do."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "So now we have `A ‚àà ‚àÖ` but the empty set is by defintion the set with no elements i.e `¬¨ (A ‚àà ‚àÖ)` written as `A_not_in_empty : A ‚àâ ‚àÖ`. Therefore, `False`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "Remember `A ‚àâ ‚àÖ` is `A ‚àà ‚àÖ ‚Üí False` , or use `contradiction`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L01_whydisjoint
msgid "We have proved the following theorem which you can use in future levels:\n"
"```\n"
"theorem disjoint\n"
"(h : left ‚à© right = ‚àÖ )\n"
"(Aleft : A ‚àà left)\n"
"(Aright : A ‚àà right)\n"
": False\n"
"```\n"
"\n"
"Example:\n"
"For a goal `False`:\n"
"```\n"
"exact disjoint h Aleft Aright\n"
"```\n"
"would close the goal\n"
"\n"
"The two assumptions `AinInter` and `AnotEmpty` are always true for any sets, and are available in Lean but where added explictly to this level for your convenience and to make things easier to explain. So, the `disjoint` theorem can just use them instead of having to take them as arguments.\n"
"\n"
"The theorem `disjoint` can be used for any two disjoint sets, specifically the two sets `Knight`,`Knave`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "`inleft_notinright`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "For two disjoint sets `left`,`right`(i.e with no common element), `A ‚àà left` means `A` can't be in `right` i.e `¬¨ (A ‚àà right)` or `A ‚àâ right`.\n"
"\n"
"The reasoning goes as follows:\n"
"Assume `A ‚àà right`. This is done using `intro` tactic."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "This proof state is what `disjoint` was created to deal with."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L02_inleft
msgid "We have proved the following theorem that you can use in future levels:\n"
"```\n"
"theorem inleft_notinright\n"
"(h : left ‚à© right = ‚àÖ )\n"
"(Aleft : A ‚àà left)\n"
": A ‚àâ right\n"
"```\n"
"\n"
"Example:\n"
"For a goal `A ‚àâ right`:\n"
"`exact inleft_notinright h Aleft` will close the goal.\n"
"\n"
"The theorem `inleft_notinright` can be used for any two disjoint sets. The two we are interested in of course are `Knight`,`Knave`.\n"
"\n"
"In the next level, you will use this theorem to prove that if `A` is a knight (`A ‚àà Knight`), then `A` is not a knave (`A ‚àâ Knave`)."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knight_NotKnave
msgid "A Knight is not a knave."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knight_NotKnave
msgid "If you are a knight, then you are definitely not a knave. Recall that knights always tell the truth and knaves always lie.\n"
"\n"
"This is implied by the assumption:\n"
"```\n"
"h : Knight ‚à© Knave = ‚àÖ \n"
"```\n"
"\n"
"Note that this level is identical to the previous one except the fact that the set `left` is now called `Knight` and the set `right` is now called `Knave`.\n"
"\n"
"This doesn't change anything of course, what changes are the names you and Lean would be seeing. If everything is renamed consistently, nothing changes.\n"
"\n"
"You can use the theorem proved in the previous level `inleft_notinright` giving it the necessary arguments."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L03_Knight_NotKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_inright
msgid "`inright_notinleft`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_inright
msgid "The reasoning goes as follows:\n"
"\n"
"Assume `A ‚àà left`. This is done using `intro` tactic."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_inright
msgid "Look familiar? This is exactly like the previous level which gave us `disjoint` theorem."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L04_inright
msgid "We have proved the following theorem that you can use in future levels:\n"
"```\n"
"theorem inright_notinleft\n"
"(h : left ‚à© right = ‚àÖ )\n"
"(Aright : A ‚àà right)\n"
": A ‚àâ left\n"
"```\n"
"\n"
"Example:\n"
"For a goal `A ‚àâ left`:\n"
"`exact inright_notinleft h Aright` will close the goal.\n"
"\n"
"The theorem `inright_notinleft` can be used for any two disjoint sets. The two we are interested in of course are `Knight`,`Knave`.\n"
"\n"
"In the next level, you will use this theorem to prove that if `A` is a knave (`A ‚àà Knave`), then `A` is not a knight (`A ‚àâ Knight`)."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_Knave_NotKnight
msgid "A Knave is not a knight."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_Knave_NotKnight
msgid "If you are a knave, then you are definitely not a knight. Recall that knights always tell the truth and knaves always lie.\n"
"\n"
"This is implied by the assumption:\n"
"```\n"
"h : Knight ‚à© Knave = ‚àÖ \n"
"```\n"
"\n"
"Note that this level is identical to the previous one except the fact that the set `left` is now called `Knight` and the set `right` is now called `Knave`.\n"
"\n"
"This doesn't change anything of course, what changes are the names you and Lean would be seeing. If everything is renamed consistently, nothing changes.\n"
"\n"
"You can use the theorem proved in the previous level `inright_notinleft` giving it the necessary arguments."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L05_Knave_NotKnight
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notleft
msgid "`notleft_right`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notleft
msgid "Truth table:\n"
"$\n"
"\\begin{array}{|c|c|} \n"
"\\hline\n"
"P  & False ‚à® P \\\\\n"
"\\hline\n"
"T  & T \\\\\n"
"F  & F \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"Notice that `P`, `False ‚à® P` always have the same truth value.\n"
"\n"
"In this level, we have `P ‚à® Q` which means that `P` is true or `Q` is true. Since we also know `¬¨P` i.e `P` is not true, the only option left is `Q` being true.\n"
"\n"
"We will first start by transforming `P ‚à® Q` into `False ‚à® Q` using `¬¨P`.\n"
"\n"
"`¬¨P` means that `P` is False i.e `P = False`.\n"
"We have the following theorem:\n"
"```\n"
"eq_false (h : ¬¨p) : p = False\n"
"```\n"
"\n"
"Use `have` and `eq_false` to get `P = False`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notleft
msgid "Replace `P` in `Or` with `False`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notleft
msgid "Since `False ‚à® Q` is true, then either `Q` is true or `False` is true. Therefore, `Q` must be true.\n"
"\n"
"Use the theorem `false_or_iff (p : Prop) : (False ‚à® p) ‚Üî p` to reduce `False ‚à® Q` to `Q`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L06_notleft
msgid "Instead of doing it manually, you can instead use `simp` tactic.\n"
"\n"
"The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or some assumption.\n"
"\n"
"`simp [notleft] at Or` does the job. It simplifies `Or` using `notleft` and various theorems called 'simp lemmas' , the ones relevant here are `false_or_iff` and `eq_false`.\n"
"\n"
"`simp` will simplify `Or` with the theorems you gave, in this case `notleft : ¬¨P`. The resulting simplified expression would be `Or : P`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L07_NotKnight_Knave
msgid "If you're not a knight, then the only option left is a knave."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L07_NotKnight_Knave
msgid "You are either a knight or a knave. If you are not a knight, then the only option left is being a knave.\n"
"\n"
"In this level, we know:\n"
"```\n"
"A ‚àà Knight ‚à® A ‚àà Knave\n"
"A ‚àâ Knight\n"
"```\n"
"and want to prove:\n"
"```\n"
"A ‚àà Knave\n"
"```\n"
"\n"
"In other words, we know that the left side of `‚à®` is not true and we want to prove the right side. This is a job for `notleft_right`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L07_NotKnight_Knave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L08_notright
msgid "`notright_left`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L08_notright
msgid "In this level, we have `P ‚à® Q` which means that `P` is true or `Q` is true. Since we also know `¬¨Q` i.e `Q` is not true, the only option left is `P` being true.\n"
"\n"
"We will first start by transforming `P ‚à® Q` into `P ‚à® False` using `¬¨Q`.\n"
"\n"
"`¬¨Q` means that `Q` is False i.e `Q = False`.\n"
"We have the following theorem:\n"
"```\n"
"eq_false (h : ¬¨p) : p = False\n"
"```\n"
"\n"
"Use `have` and `eq_false` to get `Q = False`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L08_notright
msgid "Replace `Q` in `Or` with `False`"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L08_notright
msgid "Since `P ‚à® False` is true, then either `P` is true or `False` is true. Therefore, `P` must be true.\n"
"\n"
"Use `or_false_iff (p : Prop) : (p ‚à® False) ‚Üî p` to reduce `Or : P ‚à® False` to `Or : P` , then use `Or : P` to prove the goal."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L08_notright
msgid "Instead of doing it manually, you can instead use `simp` tactic.\n"
"\n"
"The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or some assumption.\n"
"\n"
"`simp [notright] at Or` does the job. It simplifies `Or` using `notright` and various theorems called 'simp lemmas' , the ones relevant here are `or_false_iff` and `eq_false`.\n"
"\n"
"`simp` will simplify `Or` with the theorems you gave, in this case `notright : ¬¨Q`. The resulting simplified expression would be `Or : P`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L09_NotKnave_Knight
msgid "If you're not a knave, then the only option left is a knight."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L09_NotKnave_Knight
msgid "You are either a knight or a knave. If you are not a knave, then the only option left is being a knight.\n"
"\n"
"In this level, we know:\n"
"```\n"
"A ‚àà Knight ‚à® A ‚àà Knave\n"
"A ‚àâ Knave\n"
"```\n"
"and want to prove:\n"
"```\n"
"A ‚àà Knight\n"
"```\n"
"\n"
"In other words, we know that the right side of `‚à®` is not true and we want to prove the left side. This is a job for `notright_left`."
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas.L09_NotKnave_Knight
msgid "Let's recap what we have proven.\n"
"\n"
"Given the following proof state:\n"
"```\n"
"(Knight : Finset K ) (Knave : Finset K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h'' : A ‚àà Knight ‚à® A ‚àà Knave)\n"
"```\n"
"\n"
"We can conclude the following implications:\n"
"A ‚àà Knight ‚Üí A ‚àâ Knave (using `h`) \n"
"A ‚àâ Knave ‚Üí A ‚àà Knight (using `h''`)\n"
"which can be combined into: A ‚àà Knight ‚Üî A ‚àâ Knave.\n"
"\n"
"Similarly for the other two levels, we can conclude A ‚àâ Knight ‚Üî A ‚àà Knave\n"
"\n"
"These two theorems will be very useful in the following world. They are now unlocked as the following:\n"
"```\n"
"\n"
"```\n"
"\n"
"------------------------\n"
"\n"
"We have proven:\n"
"```\n"
"(Knight : Finset K) (Knave : Finset K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h' : A ‚àà Knight)\n"
"  : A ‚àâ Knave \n"
"\n"
"(Knight : Finset K ) (Knave : Finset K)\n"
"(h : Knight ‚à© Knave = ‚àÖ )\n"
"(h' : ¬¨ (B ‚àà Knave))\n"
"(h'' : B ‚àà Knight ‚à® B ‚àà Knave)\n"
"  :  B ‚àà Knight := by\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas
msgid "Knights and Knaves, lemmas"
msgstr ""

#: Game.Levels.KnightsAndKnavesLemmas
msgid "We will introduce the knights and knaves puzzle here. In this world, you will have to prove basic but important theorems which will be used in the world after this one to solve actual knights and knaves puzzles.\n"
"\n"
"The setting is an island  in which certain inhabitants called 'knights' always tell the truth, and others called 'knaves' always lie.\n"
"\n"
"Every inhabitant is either a knight or a knave, there is no third option. Formally:\n"
"```\n"
"A ‚àà Knight ‚à® A ‚àà Knave.\n"
"```\n"
"\n"
"Let `Knight` be the set of inhabitants that are knights, i.e always tell the truth.\n"
"Let `Knave` be the set of inhabitants that are knaves, i.e always lies.\n"
"In a proof state, this would look like:\n"
"```\n"
"Objects\n"
"Knight Knave : Finset Inhabitant\n"
"```\n"
"`Knight` is a finite set where its elements are of type `Inhabitant` and these elements satisfy the propery of always telling the truth.\n"
"`Knave` is a finite set where its elements are of type `Inhabitant` and these elements satisfy the property of always lying.\n"
"\n"
"Since knights always tell the truth and knaves always lie, no inhabitant can be both a knight and a knave. So the intersection of the two sets is empty i.e `Knight ‚à© Knave = ‚àÖ`. We say the two sets `Knight`, `Knave` are disjoint.\n"
"\n"
"The statement `A ‚àà Knight` is read as: `A` belongs to the finite set `Knight`(`A in Knight`), and it should be understood as 'A IS Knight' i.e 'A' always tells the truth.\n"
"Similarly, the statement `A ‚àâ Knight` is read as: `A` doesn't belong to the finite set `Knight`(`A not in Knight`), and it should be understood as 'A ISNOT Knight'.\n"
"The same reasoning applies to `x ‚àà Knave`, `x ‚àâ Knave`.\n"
"\n"
"The objective is to conclude who is a knight and who is a knave, based on the statements of several inhabitants. This will be done using logical reasoning. Every inhabitant will make at most one statement.\n"
"\n"
"get a taste:\n"
"Logic Puzzles: Knights and Knaves - YouTube\n"
"https://www.youtube.com/watch?v=jY6dvQUHIOs"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "I am a knave"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "Let's solve the previously mentioned 'I am a knave' puzzle.\n"
"\n"
"Suppose we have an inhabitant `A` which says:\n"
"```\n"
"A : I am a knave.\n"
"```\n"
"\n"
"We repeat the representation here.\n"
"\n"
"Formally, the statement 'I am a knave' is `A ‚àà Knave`.\n"
"\n"
"Remember that if `A` were a knight, then `A`'s statement is true. As an implication:\n"
"```\n"
"A ‚àà Knight ‚Üí A ‚àà Knave\n"
"```\n"
"\n"
"If `A`'s statement were true, then `A` is telling the truth so `A` must be a knight. As an implication:\n"
"```\n"
"A ‚àà Knave ‚Üí A ‚àà Knight\n"
"```\n"
"\n"
"The two can be combined as\n"
"```\n"
"stA : A ‚àà Knight ‚Üî A ‚àà Knave\n"
"```\n"
"\n"
"Similarly, if `A` were a knave then `A`'s statement is false. As an implication:\n"
"```\n"
"A ‚àà Knave ‚Üí ¬¨(A ‚àà Knave)\n"
"```\n"
"\n"
"If `A`'s statement were false `A` must be a knave. As an implication:\n"
"```\n"
"¬¨(A ‚àà Knave) ‚Üí (A ‚àà Knave)\n"
"```\n"
"\n"
"Both can be combined as:\n"
"```\n"
"stAn : A ‚àà Knave ‚Üî ¬¨(A ‚àà Knave)\n"
"```\n"
"\n"
"If `A` were a knight (i.e telling the truth), then `A` would be a knave which is a contradiction.\n"
"\n"
"Similarly if `A`  were a knave(i.e lying) then `A` would be a knight which is a contradiction.\n"
"\n"
"Regardless of what `A` is, we fall into contradiction. The proof will take all cases for `A`, which are either the fact of always telling the truth(Knight) or always lying(Knave) and will show this contradiction.\n"
"\n"
"Remember that `A` is either a knight or a knave, represented by `h1` , and our reasoning was taking every case and showing that we reach the same conclusion `False` in both. This is known as a proof by cases.\n"
"\n"
"For this, we need the `cases` tactic. Try `cases h1` and see what happens."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "Notice that `h1` is now replaced by `h_1`, and we have two goals to prove instead of one. \n"
"The difference between each is that in the first, A is a knight(`h_1 : A ‚àà Knight`) and in the second A is a knave(`h_1 : A ‚àà Knave`).  \n"
"\n"
"Conclude  `AKnave : A ‚àà Knave` using `stA` , `h_1`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "So now we have `h_1 : A ‚àà Knight` and `¬´{AKnave}¬ª : A ‚àà Knave`. \n"
"\n"
"But, remember that `Knight` and `Knave` are disjoint i.e have no common element , `h : Knight ‚à© Knave = ‚àÖ`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "Remember the `disjoint` theorem"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "Notice that h_1 is now `A ‚àà Knave`.\n"
"\n"
"Conclude `A ‚àà Knight` using `stA` , `h_1`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "So now we have `h_1 : A ‚àà Knave` and `¬´{AKnight}¬ª : A ‚àà Knight`. \n"
"\n"
"But, remember that `Knight` and `Knave` are disjoint i.e have no common element , `h : Knight ‚à© Knave = ‚àÖ`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "Remember the `disjoint` theorem"
msgstr ""

#: Game.Levels.KnightsAndKnaves.L01_IamKnave
msgid "If you have heard about the liar's paradox before (https://en.wikipedia.org/wiki/Liar_paradox), then this should look familiar.\n"
"\n"
"A saying 'I am a knave' is like A saying 'I am a liar' or 'I am lying'.\n"
"\n"
"In this level, we have proven the following theorem which is now available to you:\n"
"```\n"
"IamKnave (h : Knight ‚à© Knave = ‚àÖ) (h1 : A ‚àà Knight ‚à® A ‚àà Knave) (stA : A ‚àà Knight ‚Üî A ‚àà Knave) : False\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "From Raymond Smullyan's book called 'What is the name of this book', part 1 chapter 3 problem 26\n"
"\n"
"Three of the inhabitants `A`, `B`, and `C` were standing together in a garden.\n"
"\n"
"A stranger passed by and asked `A`, 'Are you a knight or a knave?'. `A` answered, but rather indistinctly, so the stranger could not make out what he said.\n"
"\n"
"The stranger then asked `B`, 'What did `A` say?'.\n"
"`B` replied, '`A` said that he is a knave.' \n"
"\n"
"At this point the third man, `C`, said, 'Don't believe `B`; he is lying!'\n"
"\n"
"The question is, what are `B` and `C`?\n"
"\n"
"First of all, lets simplify the statements. C's statement can be simplified to 'B is a knave.'\n"
"\n"
"The statements are:\n"
"```\n"
"B says that A said 'I am a knave'\n"
"C says that B is a knave\n"
"```\n"
"\n"
"The formalization is given in the proof state.\n"
"\n"
"Note that for the statement of `B`, if `B` where telling the truth then `A` indeed made such a statement which is the statement 'I am a Knave' and the formalization of that is `A ‚àà Knight ‚Üî A ‚àà Knave`. So we get `stB : B ‚àà Knight ‚Üî (A ‚àà Knight ‚Üî A ‚àà Knave)`"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "We know that `A` saying 'I am a knave' leads to contradiction.\n"
"\n"
"In implication form, `IamKnave` is of the following form:\n"
"```\n"
"(Knight ‚à© Knave = ‚àÖ) ‚Üí\n"
"(A ‚àà Knight ‚à® A ‚àà Knave) ‚Üí\n"
"(A ‚àà Knight ‚Üî A ‚àà Knave) ‚Üí False\n"
"```\n"
"\n"
"So, `IamKnave h h1` is of the following type:\n"
"```\n"
"(A ‚àà Knight ‚Üî A ‚àà Knave) ‚Üí False\n"
"```\n"
"which is \n"
"```\n"
"¬¨(A ‚àà Knight ‚Üî A ‚àà Knave)\n"
"```\n"
"\n"
"Store this in an object using `have`, you don't have to specify the type."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "Conclude `B ‚àà Knave` using `stBn` and `¬´{this}¬ª`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "Conclude `C ‚àà Knight` using `stC` and `¬´{BKnave}¬ª`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid "Conclude `B ‚àà Knave ‚àß C ‚àà Knight` from `¬´{BKnave}¬ª : B ‚àà Knave`, `¬´{CKnight}¬ª : C ‚àà Knight` and use exact to close the goal."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob26
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "`A` says 'I am a knave or `B` is a knave'.\n"
"\n"
"Formally,\n"
"```\n"
"stA : A ‚àà Knave ‚Üî ¬¨ (A ‚àà Knave ‚à® B ‚àà Knave)\n"
"```\n"
"\n"
"We have `¬¨(P ‚à® Q)` when `P` is false and `Q` is false, i.e `¬¨P ‚àß ¬¨Q`.\n"
"Therefore, we represent `stA` as the following:\n"
"```\n"
"stA : A ‚àà Knave ‚Üî A ‚àâ Knave ‚àß B ‚àâ Knave\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "Assuming `AKnave : A ‚àà Knave`:\n"
"- Prove `ABnotKnave : A ‚àâ Knave ‚àß B ‚àâ Knave` using `stAn`,`AKnave`.\n"
"- Prove `False` using `ABnotKnave.left : A ‚àâ Knave` , `AKnave : A ‚àà Knave`"
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "Prove `AKnight : A ‚àà Knight` using `¬´{AnKnave}¬ª : A ‚àâ Knave` , `notright_left`"
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "Prove `AorBKn: A ‚àà Knave ‚à® B ‚àà Knave` using `¬´{AKnight}¬ª`, `stA`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "Prove `BKnave : B ‚àà Knave` using `¬´{AorBKn}¬ª` , `¬´{AnKnave}¬ª`"
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid "Prove the goal using `AKnight` , `BKnave`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.IKnaveOrKnave
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "From Raymond Smullyan's book called 'What is the name of this book', part 1 chapter 3 problem 33\n"
"\n"
"Suppose `A` says 'I am a knave, but `B` is not' i.e `A ‚àà Knave ‚àß B ‚àâ Knave`.\n"
"\n"
"Formally,\n"
"```\n"
"stA: A ‚àà Knight ‚Üí A ‚àà Knave ‚àß B ‚àâ Knave\n"
"stAn : A ‚àà Knave ‚Üî ¬¨(A ‚àà Knave ‚àß B ‚àâ Knave)\n"
"```\n"
"\n"
"For `stAn`, the statement is equivalent to:\n"
"```\n"
"stAn : A ‚àà Knave ‚Üî A ‚àâ Knave ‚à® B ‚àà Knave\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "Assuming `AKnight : A ‚àà Knight`:\n"
"- Prove `AKnBnKn : A ‚àà Knave ‚àß B ‚àâ Knave` using `AKnight`, `stA`\n"
"- Prove `False` using `disjoint` , `AKnBnKn.left : A ‚àà Knave` , `AKnight : A ‚àà Knight`."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "Prove `AKnave : A ‚àà Knave` using `notleft_right` , `¬´{AnKnight}¬ª : A ‚àâ Knight`"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "Prove `AnKnBKn : A ‚àâ Knave ‚à® B ‚àà Knave` using `¬´{AKnave}¬ª : A ‚àà Knave` ,`stAn`"
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "Prove `BKnave : B ‚àà Knave` using  `A ‚àâ Knave ‚à® B ‚àà Knave` and `¬´{AKnave}¬ª : A ‚àà Knave`. Use `simp` here."
msgstr ""

#: Game.Levels.KnightsAndKnaves.prob33
msgid "In the next world, we present a different way to represent the knights and knaves puzzle which would affect what the solution looks like(the patterns of reasoning won't change though, only their execution)."
msgstr ""

#: Game.Levels.KnightsAndKnaves
msgid "Knights And Knaves"
msgstr ""

#: Game.Levels.KnightsAndKnaves
msgid "Suppose the island has an inhabitant `A` which says the following statement,\n"
"```\n"
"A says 'I am a knave'\n"
"```\n"
"\n"
"Formally, the statement 'I am a knave' is `A ‚àà Knave`.\n"
"\n"
"Remember that if `A` were a knight, then `A`'s statement is true. As an implication:\n"
"```\n"
"A ‚àà Knight ‚Üí A ‚àà Knave\n"
"```\n"
"\n"
"If `A`'s statement were true, then `A` is telling the truth so `A` must be a knight. As an implication:\n"
"```\n"
"A ‚àà Knave ‚Üí A ‚àà Knight\n"
"```\n"
"\n"
"The two can be combined as \n"
"```\n"
"stA : A ‚àà Knight ‚Üî A ‚àà Knave\n"
"```\n"
"\n"
"Similarly, if `A` were a knave then `A`'s statement is false. As an implication:\n"
"```\n"
"A ‚àà Knave ‚Üí ¬¨(A ‚àà Knave)\n"
"```\n"
"\n"
"If `A`'s statement were false `A` must be a knave. As an implication:\n"
"```\n"
"¬¨(A ‚àà Knave) ‚Üí (A ‚àà Knave)\n"
"```\n"
"\n"
"Both can be combined as:\n"
"```\n"
"stAn : A ‚àà Knave ‚Üî ¬¨(A ‚àà Knave)\n"
"```"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "`A`: `B` is a knight and `C` is a knight.\n"
"\n"
"`B`: `C` is a knight and `A` is a knave."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Assuming `hA : A`:\n"
"- Prove `BC : B ‚àß C` from `stA` using `A`\n"
"- Prove `CnA : C ‚àß ¬¨A` using `stB` , `BC.left : B`\n"
"- Prove `False` using `AKnight : A`,`CnA.right : ¬¨A`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Assuming `hC : C`:\n"
"- Prove `hB : B` using `stB`, `C ‚àß ¬¨A`\n"
"- Prove `hA : A` using `stA` , `B ‚àß C`\n"
"- Prove `False` from `hA: A`,`hnA : ¬¨A`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L01_Introduction
msgid "Using `¬¨C`, we get `¬¨C ‚à® A` which gives `¬¨B` using `stBn`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid "`A`: `C` is a knight or `B` is a knight.\n"
"\n"
"`B`: `A` is a knight, if and only if `C` is a knight."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid "We want to prove `A`, to do this we will prove `¬¨¬¨A` i.e `¬¨A ‚Üí False`. The tactic `by_contra` facilitates this, assuming `¬¨A` and changing the goal to `False`.\n"
"\n"
"Assuming `nA : ¬¨A`,\n"
"- Prove `nCnB : ¬¨C ‚àß ¬¨B` from `stAn`\n"
"- Prove `AdiffC : ¬¨(A ‚Üî C)` from `stBn` , `nCnB.right : ¬¨B`\n"
"- Prove `AiffC : A ‚Üî C` from `iff_of_false (ha : ¬¨a) (hb : ¬¨b) : a ‚Üî b `, `nA:¬¨A` , `nCnB.left : ¬¨C`\n"
"- Prove `False` from `AdiffC : ¬¨(A ‚Üî C)`  `AiffC : (A ‚Üî C)`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid "Prove `CorB : C ‚à® B` using `stA` , `¬´{hA}¬ª`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid "Now consider cases for `CorB`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid "Prove `AiffC : A ‚Üî C` using `iff_of_true (ha : a) (hb : b) : a ‚Üî b` , `hA : A` , `h : C`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid "Prove `hB : B` using `stB` , `¬´{AiffC}¬ª`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid "Prove the goal using `¬´{hA}¬ª`, `¬´{hB}¬ª` ,`h`.\n"
"\n"
"Use `constructor` tactic to split the goal in two, one would be proving the left side of `‚àß` and the other being the right side.\n"
"\n"
"The proof of the second case for `h : B` is similar."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L02_iff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "`A`: `C` is a knave or `B` is a knight.\n"
"\n"
"`B`: `A` is a knave, if and only if `C` is a knight."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "We want to prove `A`, to do this we will prove `¬¨¬¨A` i.e `¬¨A ‚Üí False`. The tactic `by_contra` facilitates this, assuming `¬¨A` and changing the goal to `False`.\n"
"\n"
"Assuming `hA : ¬¨A`:\n"
"- Prove `hCnB : C ‚àß ¬¨ B` using `stAn` , `nA`.\n"
"- Prove `AsameC : ¬¨(¬¨A ‚Üî C)` using `stBn` , `hCnB.right : ¬¨B`\n"
"- Prove `nAiffC : ¬¨A ‚Üî C` using `iff_of_true` , `nA` , `hCnB.left : C`\n"
"- Prove `False` from `nAiffC` and `AsameC`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Prove `nCorB : ¬¨C ‚à® B` using `stA` , `¬´{hA}¬ª`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Take cases for `¬´{nCorB}¬ª`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Use `iff_of_true` to prove `A ‚Üî ¬¨C`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Use `iff_not_comm` to prove `C ‚Üî ¬¨A`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Prove `B` using `stB` , `CiffnA.symm : C ‚Üî ¬¨A`. (symm for symmetry)"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Given `hP : P` , `hQ : Q`, `hR : R` and the goal `P ‚àß Q ‚àß R` , you can close this goal using:\n"
"```\n"
"exact ‚ü®hP,hQ,hR‚ü©\n"
"```\n"
"where ‚ü®‚ü© is typed as \\<>.(this is to avoid nesting `And.intro` inside another)"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Prove `nAiffC : ¬¨A ‚Üî C` using `stB` , `h`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Prove `AiffnC : A ‚Üî ¬¨C` using `iff_not_comm` , `nAiffC.symm : C ‚Üî ¬¨A`(symm for symmetry)."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Prove `hC : C` using `AiffnC : A ‚Üî ¬¨C` , `hA : A`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid "Split using `constructor` or use ‚ü®‚ü© notation."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L03_
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "`A`: `B` is a knight or `C` is a knight.\n"
"`B`: `C` is a knave, if and only if `A` is a knave"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "Assuming `nB : ¬¨B`:\n"
"- Prove `CdiffA : ¬¨(¬¨C ‚Üî ¬¨A)` using `stBn` , `nB`\n"
"- Using `simp` and `nB : ¬¨B` , reduce `stA` to `stA : A ‚Üî C`. (`B ‚à® C` , `C` have the same truth value(for `C` being true or false) when `B` is false.\n"
"- Using `not_iff_not`, reduce `¬¨C ‚Üî ¬¨A` in `CdiffA` to `C ‚Üî A`.\n"
"- Prove `False` using `CdiffA` , `stA.symm : A ‚Üî C`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "Prove `CsameA : C ‚Üî A` using `stB` , `¬´{hB}¬ª`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "Prove `BorC : B ‚à® C` using `¬´{hB}¬ª`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "Prove `hA : A` using `stA` , `¬´{BorC}¬ª`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "Rewrite `CsameA` to `CsameA : C ‚Üî A` using `not_iff_not`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "Prove `hC : C` using `¬´{CsameA}¬ª` , `¬´{hA}¬ª`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid "Use constructor"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L04_orIff
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid "`A`: If `C` is a knave, then `B` is a knave.\n"
"`B`: `A` is a knight, if and only if `C` is a knave."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid "Assuming `¬¨C` to prove `False` i.e `¬¨C ‚Üí False` i.e `¬¨¬¨C` i.e `C`:\n"
"\n"
"- Since `¬¨C` is true by `nC : ¬¨C`, then `A ‚Üî ¬¨C` and `A` have the same truth value. If `A` is true then `A ‚Üî ¬¨C` is true, and if `A` is false then `A ‚Üî ¬¨C` is false.\n"
"Use `iff_true_right (ha : a) : (b ‚Üî a) ‚Üî b` to replace `A ‚Üî ¬¨C` with `A`.\n"
"In our case, `b ‚Üî a` is `A ‚Üî ¬¨C`.\n"
"\n"
"- Rewrite `¬¨C` in `stA` with true using `eq_true`\n"
"- Rewrite `True ‚Üí ¬¨B` in `stA` with `¬¨B` using `true_implies`\n"
"- Rewrite `¬¨B` in `stA` with `¬¨A` using `stBn`\n"
"- Prove `False` using `not_iff_self`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid "Rewrite `¬¨C` in `stA` as `¬¨True` using `eq_true`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid "Rewrite `¬¨True` in `stA` as `False` using `not_true`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid "Rewrite `False ‚Üí ¬¨B` in `stA` as `¬¨B` using `false_implies`"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid "Rewrite `stA` using `iff_true_iff`."
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid "- Use simp and `hC : C` to simplify `stB`\n"
"- Rewrite `stB` using `iff_not_comm` obtaining `stB : A ‚Üî ¬¨B`\n"
"- Prove `¬¨B` using and conclude the goal"
msgstr ""

#: Game.Levels.KnightsAndKnaves2.L05_imp
msgid ""
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "Knights and Knaves, Second Approach"
msgstr ""

#: Game.Levels.KnightsAndKnaves2
msgid "In this world, we also deal with the knights and knaves puzzle with the difference being the representation of the problems in Lean and therefore the solution to the puzzles as well.\n"
"\n"
"The setup is as follows:\n"
"We exploit the binary nature of an inhabitant. There are two options and no third, either a knight or a knave. So, we declare an object of type `Prop` for every inhabitant. \n"
"\n"
"Say we had three inhabitants `A,B,C` , we would declare the following propositions:\n"
"```\n"
"variable {A B C : Prop}\n"
"```\n"
"Now, we intrepret having a proof of `A` as `A` being a knight, and having a proof of `¬¨A` as `A` being a knave.\n"
"\n"
"We have the following correspondence:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"\\text{Old way} & \\text{New way} \\\\\n"
"\\hline\n"
"h : A ‚àà Knight & h : A \\\\\n"
"\\hline\n"
"h : A ‚àâ Knight & h : ¬¨A \\\\\n"
"\\hline\n"
"h : A ‚àà Knave  & h : ¬¨A \\\\\n"
"\\hline\n"
"h : A ‚àâ Knave  & h : ¬¨¬¨A \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"The translation of statements made by each inhabitant into a propositional formula remains the same, using `‚Üî` but of course instead of `A ‚àà Knight` we just have `A` and instead of `A ‚àà Knave` we just have `¬¨A`.\n"
"\n"
"Notice that there are no explicit assumptions in this representation, but that doesn't mean that this representation is less faithful.\n"
"\n"
"We know that any proposition is either true or false, in our context this would translate to every inhabitant is either a knight or a knave. \n"
"```\n"
"A ‚àà Knight ‚à® A ‚àà Knave \n"
"```\n"
"translates to\n"
"```\n"
"A ‚à® ¬¨A\n"
"```\n"
"\n"
"Moreoever, we know that `A ‚àß ¬¨A` is false, which would translate to the fact that no inhabitant can be both a knight or a knave.\n"
"```\n"
"A ‚àà Knight ‚àß A ‚àà Knave\n"
"```\n"
"which within the previous representation of finite sets would mean that the set knight and the set knave are disjoint.\n"
"```\n"
"Knight ‚à© Knave = ‚àÖ\n"
"```\n"
"\n"
"Correspondence:\n"
"$\n"
"\\begin{array}{|c|c|c|} \n"
"\\hline\n"
"\\text{Old way} & \\text{New way} \\\\\n"
"\\hline\n"
"h : A ‚àà Knight ‚à® A ‚àà Knave & h : A ‚à® ¬¨A \\\\\n"
"\\hline\n"
"h : Knight ‚à© Knave = ‚àÖ & h: A ‚àß ¬¨A  \\\\\n"
"\\hline\n"
"\\end{array}\n"
"$\n"
"\n"
"All puzzles were generated(and possibly modified) from https://www.wolframcloud.com/objects/demonstrations/KnightsAndKnavesPuzzleGenerator-source.nb."
msgstr ""

#: Game
msgid "Knights And Knaves Game"
msgstr ""

#: Game
msgid "This is a gamification of mathematical proofs. Every level has a `Goal`, which is what you are trying to prove. Closing the `Goal` means you have proved the theorem and there is nothing else to do.\n"
"\n"
"You will use the `Lean` theorem prover, and its mathematical library `mathlib`.\n"
"\n"
"# Right Side Pane\n"
"Let's explain what's going on in the right side pane.\n"
"\n"
"This is where you can find the tactics, definitions, and theorems at your disposal which were introduced in previous levels.\n"
"\n"
"Clicking on one will display an overview and some examples. This will be available to you at all times when working on the levels. Refer back to it whenever you need to.\n"
"\n"
"Any new tactic, theorem, or definition introduced in a level will be highlighted in a yellow color.\n"
"\n"
"We now discuss each section in the right side pane.\n"
"(note that you can view the official documentation of tactics or theorems by hovering over a term when you are in editor mode, you can enter editor mode by clicking the icon next to the hamburger menu that is in the top right hand corner)\n"
"## Tactics\n"
"In this puzzle game, you will use tactics to manipulate the `Goal` and close it, essentially proving the `Goal`. Tactics will be incrementally introduced, and tactics that haven't been introduced yet will have a lock icon which means you can't use them yet. \n"
"\n"
"## Definitions\n"
"The point of this game is not just to showcase ***Lean***, but also to learn some mathematics. Relevant definitions will be displayed here.\n"
"\n"
"## Theorems\n"
"Here is listed theorems to use throughout the levels. Some you would have proved in previous levels and others are presented for you to use but without having proved them. An intuitive definition of why the theorem makes sense will be presented as well when it is introduced.\n"
"\n"
"# Level Structure\n"
"Within every level, you have the `Objects`(if any), `Assumptions`(if any), and `Goal` for the current level. This is called the initial proof state. \n"
"\n"
"There will also be a text input to execute tactics accordingly.\n"
"\n"
"***Lean*** tracks the proof state as you execute tactics and makes sure you made no mistakes.\n"
"You will execute tactics one by one until Lean tells you that you have closed the goal.\n"
"\n"
"# More info\n"
"You can click the hamburger menu in the top right then 'Game Info' for more information."
msgstr ""

#: Game
msgid "Many technical details have been skipped for the sake of not getting bogged down with `Lean` and its mathematical library `mathlib`, but focus on the aspects of reasoning and proof. You can search https://leanprover-community.github.io/mathlib4_docs/ for more information about any tactic or theorem used.\n"
"\n"
"# Editor Mode \n"
"Some levels will force you to use editor mode. Editor mode is necessary for multiline tactics like `have`. Moreover, you should get used to it because it mimics a vscode `Lean` environment which is the most common way `Lean` is run.\n"
"\n"
"To access editor mode, click on the icon next to the hamburger menu in the top right.\n"
"\n"
"## vscode like environment\n"
"Hovering over things will give you the official documentation of things.\n"
"\n"
"# Links\n"
"## documentation\n"
"https://leanprover-community.github.io/\n"
"\n"
"https://lean-lang.org/\n"
"\n"
"https://lean-lang.org/documentation/\n"
"\n"
"https://github.com/leanprover-community/mathlib4\n"
"\n"
"## zulip, ask questions\n"
"Zulip chat for lean has been a very useful resource to resolve issues when formalizing the exercises, you can visit it and ask questions in the '#new members' stream. You can also view messages without signing up. There are other streams dedicated to various topics you can check out as well.\n"
"\n"
"https://leanprover.zulipchat.com/\n"
"\n"
"https://zulip.com/case-studies/lean/\n"
"\n"
"## Knights and Knaves\n"
"Sources for the puzzles:\n"
"- Puzzle Generator(some of which were taken as is, and others were modified):\n"
"https://www.wolframcloud.com/objects/demonstrations/KnightsAndKnavesPuzzleGenerator-source.nb\n"
"- Raymond smullyan's book called 'What is the name of this book'\n"
"\n"
"Insightful:\n"
"- Knights and Knaves in a logic programming language(prolog):\n"
"https://www.youtube.com/watch?v=oEAa2pQKqQU\n"
"\n"
"- Blog post series, includes introduction ,representation and formalization, automated solutions using other provers, and creating your own puzzles.\n"
"https://summerofgodel.blogspot.com/search/label/Knights%20and%20Knaves%20puzzle\n"
"\n"
"# Rules\n"
"You can relax the rules and skip levels.\n"
"\n"
"This is not recommended for people who have never heard about Lean before. Moreover, relaxing the rules would ruin the coherence and structured/guided experience you would have when playing the game normally. If that is what you are looking for, then don't relax the rules.\n"
"\n"
"# Github\n"
"The game's repository is on https://github.com/JadAbouHawili/KnightsAndKnaves-Lean4Game\n"
"\n"
"You can view the code for every level.(and the solution there if you are really stuck)\n"
"\n"
"# Shoutouts, other educational games \n"
"Knights and Knaves education game:(games on other topics are available as well)\n"
"https://en.oiler.education/bul\n"
"\n"
"Generate and solve:\n"
"https://christopherphelps.trinket.io/sites/knight_knave_puzzler"
msgstr ""

#: Game
msgid "From the basics to Knights And Knaves"
msgstr ""

#: Game
msgid "A guided experience that teaches you everything you need to know to understand and solve knights and knaves logic puzzles, including the basics of lean and basic logic.\n"
"\n"
"Based on statements made, you will deductively conclude who is a knight(truthful) and who is a knave(liar)."
msgstr ""
